# 开发环境须知
本系列技术栈要求的开发环境：
1. node 12.0以上，本人安装：14.18.1长期稳定维护版（需求win8以上系统）
2. vue3.x的语法插件：Vue language Features(volar)，vue2.x时使用的是`vetur`，这两者是有冲突的，使用`vue3.x`开发，就必须禁用`vetur`插件，使用`volar`

# 安装
终端定位到项目需要放在的路径上执行以下命令：
```
yarn create vite
```
根据命令提示步骤完成项目基础信息配置：
1. 确定项目名（最好是英文名，项目名同时也是项目根目录文件夹名）
2. 确定package.json中的name名（直接回车即可）
3. 选择框架语言（vue）
4. 选择框架语言版本（vue-ts）
以上步骤完成后，vscode打开项目，执行以下两步命令：
```
# 安装依赖
yarn
# 本地运行项目
yarn dev
```
能正常显示`vue`界面，则配置成功

# 配置alias别名
先把别名配置好，方便接下来的文件引用：
```
# vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
		alias: {
			'@': resolve('src'),
		}
	}
})
```
此时`TS`可能会有这个提示：

> 找不到模块“path”或其相应的类型声明

解决办法：
```
yarn add @types/node -D
```
此时将`src/App.vue`文件中模块以及`logo`的引用路径修改一下，页面正常显示，则配置正确
```
import HelloWorld from './components/HelloWorld.vue'
# 修改为：
import HelloWorld from '@/components/HelloWorld.vue'

<img alt="Vue logo" src="./assets/logo.png" />
# 修改为：
<img alt="Vue logo" src="@/assets/logo.png" />
```

# 集成SCSS预处理器
这里需要说一点的是，如果你用习惯了`node-sass`，那么这里会发现，你安装`node-sass`，使用`node-sass`做预处理器会报错:
```
[vite] Internal server error: Preprocessor dependency "sass" not found. Did you install it?
```
暂不清楚是node14.x的原因、还是vue3.x的原因、抑或是vite的原因，总之在这个技术栈内，**人家直接用的是sass，安装node-sass是没用的~**，所以这里执行以下安装包命令：
```
yarn add sass sass-loader -D
```
安装完成运行项目，来测试一下scss是否能正常运行，在`src`文件夹下新建`style`文件夹，并在其内新建`index.scss`以及`-settings.scss`文件：
```
# src/style/-settings.scss
@charset "UTF-8";
$pink: #ff00ff;
$red: red;

# src/style/index.scss
@charset "UTF-8";
@import "./-settings.scss";
.demo{
  color: $red;
}
```
在`main.ts`文件中引入样式表文件
```
# src/main.ts
import { createApp } from 'vue'
import App from '@/App.vue'

import '@/style/index.scss';

createApp(App).mount('#app')
```
修改`App.vue`文件，在`template`内添加内容：
```
# src/App.vue template标签内
<h1 class="demo">红色标题</h1>
```
浏览器查看标题已变成红色，则引用正常

vite配置全局scss变量，官方给的方法如下：
```
# vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'


export default defineConfig({
  plugins: [
    vue(),
  ],
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/style/-settings.scss";`,
      },
    },
  },
});
```
在页面中使用全局变量，修改`src/components/HelloWorld.vue`的页面内样式：
```
# src/components/HelloWorld.vue
<style  scoped lang="scss">
a {color:$pink}
...
</style>
```
此时运行项目，会发现报错了，研究报错会发现，报错所指向的是在`main.ts`中引入的`index.scss`文件，在网上搜了一圈并没有找到具体解决办法，报错中有一句`Plugin:vite:css`，猜测是配置全局后，其他地方的scss文件引入都会报错，将`main.ts`中引入的`index.scss`删除，再运行项目，发现全局变量已经起作用，但同时h1标题的样式已丢失，暂未找到具体原因，公共样式还是需要在`main.ts`中引入的，目前的做法是不在`vite`中配置全局变量，若要在某个页面使用变量，则在具体页面的`style`标签内`@import``scss`变量配置文件：
```
# src/components/HelloWorld.vue
<style  scoped lang="scss">
@import "@/style/-settings.scss";
a {color:$pink}
...
</style>
```
此时再运行项目，就不会再报错了~，且页面内和`main.ts`中引入的样式都能起作用

# 集成element-plus

```
yarn add element-plus
```
### 引入方式-整体引入
```
# main.ts
import { createApp } from 'vue'
import App from '@/App.vue'

// elementPlus完整引入
import ElementPlus from 'element-plus';
import 'element-plus/dist/index.css'

import "@/style/index.scss"

const app = createApp(App)

app.use(ElementPlus)
app.mount('#app')

# src/App.vue template标签内新增：
<el-button type="primary">Primary</el-button>
```
此时项目运行，按钮有样式能正常展示，则整体引入完成

### 引入方式-按需引入
安装按需加载依赖包，这个插件会自动加载组件与其对应的样式
```
yarn add unplugin-element-plus -D
```
在`src`文件夹下新建`plugins/element-plus/index.ts`文件结构，并在文件内加入以下内容：
```
import { App } from "vue";
import {
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElForm,
  ElFormItem,
  ElLoading,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
	ElInfiniteScroll,
  ElMessage,
  ElMessageBox,
  ElNotification,
} from "element-plus";

const components = [
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElForm,
  ElFormItem,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem
];

const plugins = [ElInfiniteScroll, ElLoading, ElMessage, ElMessageBox, ElNotification];

export function useElementPlus(app: App) {
    components.forEach((component: any) => {
        app.component(component.name, component);
    });
    plugins.forEach(plugin => {
        app.use(plugin);
    });
}

```
修改`vite.config.ts`文件：
```
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import ElementPlus from "unplugin-element-plus/vite";
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
		vue(),
		ElementPlus({}),
	],
  resolve: {
		alias: {
			'@': resolve('src'),
		}
	}
})
```
修改`main.ts`文件：
```
import { createApp } from 'vue'
import App from '@/App.vue'

import { useElementPlus } from "@/plugins/element-plus"; // element-plus

import "@/style/index.scss"

const app = createApp(App)

app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')
```
此时`TS`可能会提示这样的错误：
> 找不到模块“@/plugins/element-plus”或其相应的类型声明

修改`tsconfig.json`文件：
```
{
  "compilerOptions": {
    "target": "esnext",
    "useDefineForClassFields": true,
    "module": "esnext",
    "moduleResolution": "node",
    "strict": true,
    "jsx": "preserve",
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "lib": ["esnext", "dom"],
    // 新增
    "baseUrl": ".", 
    "paths":{
      "@/*": ["src/*"],
    },
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"]
}
```
此时运行项目，按钮依然可以正常显示，表示按需加载已配置完成。

修改`main.ts`中，全局配置的`size`值，页面内按钮大小也会相应做出改变

### element-plus 控制台无穷多的组件警告信息消除
使用`element-plus`的某些组件时，控制台会报很多警告信息，这是比较烦人的事情，比如在页面内引入日期选择插件：
```
# src/App.vue
# script标签内新增
import { ref } from 'vue'
const value1 = ref("")
# template标签内新增
<el-date-picker v-model="value1" type="date" placeholder="Pick a day"></el-date-picker>
</template>

```

**此时打开F12查看，会发现控制台有无穷多的警告信息，这个比较影响开发，其原因是element-plus的版本问题**

解决办法也简单，下载指定版本即可

```
yarn remove element-plus
yarn add element-plus@1.1.0-beta.24
```
此时再运行项目，控制台的那些烦人警告就都消失不见了~

# 集成vue-router

```
yarn add vue-router@next
```
在`src`文件夹下新建`router`文件夹，并在`router`文件夹下新建`index.ts`文件，写入一段测试路由信息
```
# src/router/index.ts
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
    {
        path: '/demo',
        component: () => import("../views/demo/index.vue")
    },
    {
        path: '/',
        component: () => import("../views/home/index.vue")
    },
]

const router = createRouter({
    history: createWebHistory(),
    routes
})

export default router
```
此时测试路由信息已完成导出，接着去`main.ts`文件中将导出的路由挂载到app中：
```
# main.ts
import { createApp } from 'vue'
import router from './router'
import App from './App.vue'
import { useElementPlus } from "@/plugins/element-plus"; // element-plus
import '@/style/index.scss';
const app = createApp(App)

app.use(router)
app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')

```
修改`App.vue`文件：
```
# App.vue
<template>
  <router-view />
</template>
```
此时基础的路由就以创建完成，接下来创建路由对应的页面组件,`src`文件夹下新建`views`文件来集中管理具体页面文件
```
// src/views/demo/index.vue
<template>
    <div>demo</div>
</template>

// src/views/home/index.vue
<script setup lang="ts">
// This starter template is using Vue 3 <script setup> SFCs
// Check out https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup
import HelloWorld from '@/components/HelloWorld.vue'
</script>

<template>
  <h1 class="demo">红色标题</h1>
  <img alt="Vue logo" src="@/assets/logo.png" />
  <HelloWorld msg="Hello Vue 3 + TypeScript + Vite" />
  <el-button type="primary">Primary</el-button>
</template>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```
此时启动项目，打开项目即可进入首页，访问`/demo`路径，即可进入`demo`页面


# 项目结构与框架样式完善
为方便接下来其他功能的接入，先做一些结构调整，以及框架样式的完善
```
src
├── api                                     # 存放api接口文件
├── assets                                  # 静态资源
│    └── icons                              # 图标资源
│          └── svg                          # svg图标资源
├── components                              # 通用组件
├── layout                                  # 框架UI层
│    ├── components                         # 框架组件
│    │    ├── breadCrumb                    # 面包屑
│    │    │    └── index.vue                
│    │    ├── hamBurger.vue                 # 折叠菜单按钮
│    │    │    └── index.vue             
│    │    ├── logo.vue                      # logo
│    │    │    └── index.vue             
│    │    ├── sidebarItem.vue               # 子菜单
│    │    │    └── index.vue             
│    │    ├── appMain.vue                   # 页面内容主体
│    │    ├── navbar.vue                    # header部分
│    │    ├── tags.vue                      # tag标签菜单
│    │    └── vertical.vue                  # 侧边菜单
│    └── index.vue                          # 框架主页面
├── plugins                                 # 项目插件
│    └── element-plus                       # 插件文件夹
│         └── index.ts                      # 插件内容
├── router                                  # 路由
│    ├── modules                            # 路由分模块
│    │    ├── demo.ts                      # 子模块路由
│    │    ├── home.ts                       # 子模块路由
│    │    └── nested.ts                     # 子模块路由
│    ├── index.ts                           # 路由主文件
│    └── remaining.ts                       # 其他路由
├── store                                   # 状态管理
│    ├── modules                            # 状态管理分模块
│    │    ├── app.ts                        # 子模块状态管理
│    │    └── permission.ts                 # 子模块状态管理
│    └── index.ts                           # 状态管理主文件
├── style                                   # 样式文件夹
│    ├── -layout.scss
│    ├── -public.scss
│    ├── -settings.scss
│    └── index.scss
├── utils                                   # 工具函数文件夹
├── views                                   # 视图页面文件夹
│    ├── demo
│    │    └── index.vue
│    ├── home
│    │    └── index.vue
│    └── nested
│         ├── menu1
│         │    ├── menu1-1           
│         │    │    └── index.vue  
│         │    ├── menu1-2 
│         │    │    ├── menu1-2-1  
│         │    │    │    └── index.vue  
│         │    │    ├── menu1-2-2  
│         │    │    │    └── index.vue  
│         │    │    └── index.vue     
│         │    ├── menu1-3   
│         │    │    └── index.vue           
│         │    └── index.vue             
│         ├── menu2
│         │    └── index.vue            
│         └── index.vue  
├── App.vue
├── env.d.ts
└── main.ts
```
以上是初步的项目文件结构，可以先将对应文件结构都先创建出来，新增的文件内容如下（未展示的这一步都还是空文件）：

#### src/layout/index.vue
```
# src/layout/index.vue
<script setup lang="ts">
import navbar from "./components/navbar.vue";
import appMain from "./components/appMain.vue";
import Vertical from "./components/vertical.vue";
import tags from "./components/tags.vue";
</script>

<template>
  <div class="app-wrapper">
    <!-- 侧边导航栏 -->
    <Vertical />
    <div class="main-container">
      <div class="fixed-header">
        <!-- 顶部导航栏 -->
        <navbar />
        <!-- 标签栏 -->
        <tags />
      </div>
      <!-- 主体内容 -->
      <app-main />
    </div>
  </div>
</template>

<style lang="scss" scoped>

</style>
```
#### src/layout/components/logo/index.vue
```
<script setup lang="ts">
const title = "viteDemo"
</script>

<template>
  <div class="sidebar-logo">
    <router-link :title="title" class="logo-link" to="/">
      <img class="logo-img" src="@/assets/logo.png" />
      <h1 class="logo-title">{{ title }}</h1>
    </router-link>
  </div>
</template>

<style lang="scss" scoped>
.sidebar-logo {
  position: relative;
  width: 100%;
  height: 48px;
  overflow: hidden;
  .logo-link {
    height: 100%;
    padding-left: 10px;
    text-align: left;
    .logo-img{
      width: 32px;
      height: 32px;
      display: inline-block;
      margin: 8px;
      vertical-align: top;
    }
    .logo-title {
      display: inline-block;
      margin: 0;
      color: #1890ff;
      font-weight: 600;
      font-size: 20px;
      line-height: 24px;
      margin-top: 12px;
      vertical-align: top;
    }
  }
}
</style>
```
#### src/layout/components/appMain.vue
```
<script setup lang="ts">

</script>

<template>
  <div class="app-main">
    <el-scrollbar>
      <router-view></router-view>
    </el-scrollbar>
  </div>
</template>

<style lang="scss" scoped>
.app-main {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow-x: hidden;
}
</style>
```
#### src/layout/components/navbar.vue
```
<script setup lang="ts">

</script>

<template>
  <div class="navbar"></div>
</template>

<style lang="scss" scoped>
.navbar {
  width: 100%;
  height: 48px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
}

</style>
```
#### src/layout/components/tags.vue
```
<script setup lang="ts">

</script>

<template>
  <div class="tags-view">
    <el-scrollbar wrap-class="scrollbar-wrapper" class="scroll-container"></el-scrollbar>
  </div>
</template>

<style lang="scss" scoped>
.tags-view {
  width: 100%;
  font-size: 14px;
  height: 38px;
  display: flex;
  box-shadow: 0 0 1px #888;
  .scroll-container {
    padding: 5px 0;
    white-space: nowrap;
    position: relative;
    width: 100%;
    background: #fff;
    .scrollbar-wrapper {
      position: absolute;
      height: 40px;
      overflow-x: hidden !important;
    }
  }
}
</style>
```
#### src/layout/components/vertical.vue
```
<script lang="ts">
import Logo from "./logo/index.vue"
import { defineComponent, ref } from 'vue'
import {
  Location,
  Document,
  Menu as IconMenu,
  Setting,
} from '@element-plus/icons'

export default defineComponent({
  components: {
    Location,
    Document,
    Setting,
    IconMenu,
    Logo,
  },
  setup() {
    const isCollapse = ref(false)
    const handleOpen = (key:any, keyPath:any) => {
      console.log(key, keyPath)
    }
    const handleClose = (key:any, keyPath:any) => {
      console.log(key, keyPath)
    }
    return {
      isCollapse,
      handleOpen,
      handleClose,
    }
  },
  methods:{
    routerLink(e:string){
      console.log(e);
      this.$router.push({path:e});
    }
  }
})
</script>

<template>
  <div class="sidebar-container">
    <Logo />
    <el-scrollbar wrap-class="scrollbar-wrapper">
      <el-menu
        default-active="1"
        class="el-menu-vertical-demo"
        :collapse="isCollapse"
        @open="handleOpen"
        @close="handleClose"
      >
        <el-menu-item class="submenu-title-noDropdown" index="1" v-on:click="routerLink('/')">
          <el-icon><icon-menu /></el-icon>
          <template #title>home</template>
        </el-menu-item>
        <el-sub-menu index="2">
          <template #title>
            <el-icon><location /></el-icon>
            <span>Navigator One</span>
          </template>
          <el-sub-menu index="2-1">
            <template #title>
              <span>Navigator two</span>
            </template>
            <el-menu-item index="2-1-1" v-on:click="routerLink('/nested/menu1/menu1-1')">item one</el-menu-item>
            <el-sub-menu index="2-1-2">
              <template #title>
                <span>Navigator three</span>
              </template>
              <el-menu-item index="2-1-2-1" v-on:click="routerLink('/nested/menu1/menu1-2/menu1-2-1')">item one</el-menu-item>
              <el-menu-item index="2-1-2-2" v-on:click="routerLink('/nested/menu1/menu1-2/menu1-2-2')">item two</el-menu-item>
            </el-sub-menu>
            <el-menu-item index="2-1-3" v-on:click="routerLink('/nested/menu1/menu1-3')">item three</el-menu-item>
          </el-sub-menu>
          <el-menu-item index="2-2" v-on:click="routerLink('/nested/menu2')">item four</el-menu-item>
        </el-sub-menu>
        <el-menu-item class="submenu-title-noDropdown" index="3" v-on:click="routerLink('/demo')">
          <el-icon><setting /></el-icon>
          <template #title>demo</template>
        </el-menu-item>
      </el-menu>
    </el-scrollbar>
  </div>
</template>
<style lang="scss" scoped>
</style>

```
#### src/router/index.ts
```
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
    {
        path: '/',
        component: () => import("@/layout/index.vue"),
        children:[
            {
                path: '/',
                component: () => import("@/views/home/index.vue")
            },
            {
                path: '/demo',
                component: () => import("@/views/demo/index.vue")
            },
            {
                path: "/nested",
                component: () => import("@/views/nested/index.vue"),
                redirect: "/nested/menu1/menu1-1",
                name: "Nested",
                children: [
                    {
                        path: "/nested/menu1",
                        component: () => import("@/views/nested/menu1/index.vue"),
                        name: "Menu1",
                        redirect: "/nested/menu1/menu1-1",
                        children: [
                            {
                                path: "/nested/menu1/menu1-1",
                                component: () => import("@/views/nested/menu1/menu1-1/index.vue"),
                                name: "Menu1-1",
                            },
                            {
                                path: "/nested/menu1/menu1-2",
                                component: () => import("@/views/nested/menu1/menu1-2/index.vue"),
                                name: "Menu1-2",
                                redirect: "/nested/menu1/menu1-2/menu1-2-1",
                                children: [
                                    {
                                        path: "/nested/menu1/menu1-2/menu1-2-1",
                                        component: () => import("@/views/nested/menu1/menu1-2/menu1-2-1/index.vue"),
                                        name: "Menu1-2-1",
                                    },
                                    {
                                        path: "/nested/menu1/menu1-2/menu1-2-2",
                                        component: () => import("@/views/nested/menu1/menu1-2/menu1-2-2/index.vue"),
                                        name: "Menu1-2-2",
                                    }
                                ]
                            },
                            {
                                path: "/nested/menu1/menu1-3",
                                component: () => import("@/views/nested/menu1/menu1-3/index.vue"),
                                name: "Menu1-3",
                            }
                        ]
                    },
                    {
                        path: "/nested/menu2",
                        name: "Menu2",
                        component: () => import("@/views/nested/menu2/index.vue"),
                    }
                ]
            }
        ]
    },
]

const router = createRouter({
    history: createWebHistory(),
    routes
})

export default router
```
#### src/style/-layout.scss
```
.app-wrapper{
  position: relative;
  width: 100%;
  height: 100%;
  @include clearfix;
}
$subMenuActiveText: #f4f4f5;
$menuBg: #1b2a47;
$menuHover: #2a395b;
$subMenuBg: #1f2d3d;
$subMenuHover: #001528;
$sideBarWidth: 210px;
$navTextColor: #fff;
$menuText: #7a80b4;
$menuActiveText: #7a80b4;

.main-container {
  min-height: 100%;
  padding-left:  $sideBarWidth;
  transition: padding-left .28s;
  position: relative;
}

.fixed-header {
  position: fixed;
  left: $sideBarWidth;
  top: 0;
  right: 0;
  z-index: 1000;
  transition: left 0.28s;
}

.main-hidden {
  margin-left: 0 !important;

  .fixed-header {
    width: 100% !important;

    + .app-main {
      padding-top: 37px;
    }
  }
}

.el-popper.is-light {
  border: none !important;
}

.sidebar-container {
  transition: width 0.28s;
  width: $sideBarWidth;
  background-color: $menuBg;
  height: 100%;
  position: fixed;
  font-size: 0;
  top: 0;
  bottom: 0;
  left: 0;
  z-index: 1001;
  overflow: hidden;
  box-shadow: 0 0 1px #888;

  .scrollbar-wrapper {
    overflow-x: hidden !important;
  }

  .horizontal-collapse-transition {
    transition: 0s width ease-in-out, 0s padding-left ease-in-out,
      0s padding-right ease-in-out;
  }

  .el-scrollbar__bar.is-vertical {
    right: 0;
  }

  .el-scrollbar {
    height: 100%;
  }

  &.has-logo {
    .el-scrollbar {
      height: calc(100% - 50px);
    }
  }

  .is-horizontal {
    display: none;
  }

  a {
    display: inline-block;
    width: 100%;
    overflow: hidden;
  }

  .el-menu {
    border: none;
    height: 100%;
    background-color: transparent !important;
  }
  .el-sub-menu__icon-arrow{
    position: absolute !important;
  }
  .el-menu-item,
  .el-sub-menu__title {
    color: $menuText;
  }

  // menu hover
  .submenu-title-noDropdown,
  .el-sub-menu__title {
    // background: $menuBg;

    &:hover {
      background-color: $menuHover !important;
    }
  }

  .is-active > .el-sub-menu__title,
  .is-active.submenu-title-noDropdown {
    color: $subMenuActiveText !important;

    i {
      color: $subMenuActiveText !important;
    }
  }

  .is-active {
    transition: color 0.3s;
    color: $subMenuActiveText !important;
  }

  .el-menu .el-menu--inline .el-sub-menu__title,
  & .el-sub-menu .el-menu-item {
    font-size: 12px;
    min-width: $sideBarWidth !important;
    background-color: $subMenuBg !important;

    &:hover {
      background-color: $subMenuHover !important;
    }
  }
}
.el-scrollbar__wrap {
  overflow: auto;
  height: 100%;
}

.fixed-header + .app-main {
  padding-top: 86px;
}
```
#### src/style/-public.scss
```

body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB,
    Microsoft YaHei, Arial, sans-serif;
}

html {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

label {
  font-weight: 700;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

a:focus,
a:active {
  outline: none;
}

a,
a:focus,
a:hover {
  cursor: pointer;
  color: inherit;
  text-decoration: none;
}

div:focus {
  outline: none;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.clearfix {
  &::after {
    visibility: hidden;
    display: block;
    font-size: 0;
    content: " ";
    clear: both;
    height: 0;
  }
}
```
#### src/style/-settings.scss
```
@charset "UTF-8";
$pink: #ff00ff;
$red: red;

@mixin clearfix {
  &::after {
    content: "";
    display: table;
    clear: both;
  }
}
```
#### src/style/index.scss
```
@charset "UTF-8";
@import "./-settings.scss";
@import "./-public.scss";
@import "./-layout.scss";
.demo{
  color: $red;
}
```
#### src/views/demo/index.vue
```
<template>
    <div>demo</div>
</template>
```
#### src/views/home/index.vue
```
<script setup lang="ts">
// This starter template is using Vue 3 <script setup> SFCs
// Check out https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup
import HelloWorld from '@/components/HelloWorld.vue'
</script>

<template>
  <div class="home">
    <h1 class="demo">红色标题</h1>
    <img alt="Vue logo" src="@/assets/logo.png" />
    <HelloWorld msg="Hello Vue 3 + TypeScript + Vite" />
    <el-button type="primary">Primary</el-button>
  </div>
</template>

<style>
.home{
  text-align: center;
}
</style>
```
#### src/views/nested
```
# src/views/nested/index.vue、src/views/nested/menu1/index.vue、src/views/nested/menu1-2/index.vue,
<template>
  <router-view />
</template>

# src/views/nested/menu1/menu1-1/index.vue
<template>
    <div>menu1-1</div>
</template>

# src/views/nested/menu1/menu1-2-1/index.vue
<template>
    <div>menu1-2-1</div>
</template>

# src/views/nested/menu1/menu1-2-2/index.vue
<template>
    <div>menu1-2-2</div>
</template>

# src/views/nested/menu1/menu1-3/index.vue
<template>
    <div>menu1-3</div>
</template>

# src/views/nested/menu2/index.vue
<template>
    <div>menu2</div>
</template>
```
#### src/views/error
```
# src/views/error/401/index.vue
<script setup lang="ts">

</script>
<template>
  <h2>401</h2>
</template>

<style>
</style>

# src/views/error/404/index.vue
<script setup lang="ts">

</script>
<template>
  <h2>404</h2>
</template>

<style>
</style>
```
以上内容充实后，整个项目的框架就算初步出来了，接下来是功能完善、细节处理，运行项目，导航能正常链接到各个对应页面，则一切配置都已生效

# 集成vuex
```
yarn add vuex@next
```
先做一个简单的示例，累加功能，在`helloworld`组件中按钮点击自增，在`home`页面内展示

```
# src/store/index.ts
import { createStore } from 'vuex'

const store = createStore({
    state() {
        return {
            count: 0
        }
    },
    mutations: {
        // 累加功能
        increment(state) {
            state.count++
        }
    }
})
export default store
```
此时会发现`state`报类型错误，修改如下：
```
import { createStore } from 'vuex'

//定义一个state的接口
export interface State {
    count: number
}

const store = createStore<State>({
    state() {
        return {
            count: 0
        }
    },
    mutations: {
        // 累加功能
        increment(state) {
            state.count++
        }
    }
})
export default store
```

然后修改`main.ts`文件：
```
# src/main.ts

import { createApp } from 'vue'
import router from './router'
import store from './store'
import App from './App.vue'
import { useElementPlus } from "@/plugins/element-plus"; // element-plus
import '@/style/index.scss';
const app = createApp(App)

app.use(router)
app.use(store)
app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')
```

在`helloWorld.vue`文件中增加点击按钮，以及点击事件
```
# src/components/HelloWorld.vue

<script setup lang="ts">
import { ref } from 'vue'
defineProps<{ msg: string }>()
const count = ref(0);

import { useStore } from "vuex";
const store = useStore();
function handleClickIncrement() {
  store.commit("increment");
}
</script>


# template 内新增如下代码

<el-button type="primary" @click="handleClickIncrement">累加自增</el-button>
```
然后在`demo`页面内获取`vuex`中的内容
```
# src/views/demo/index.vue
<script setup lang="ts">
import { useStore } from 'vuex'
const store = useStore()
const count = store.state.count
</script>
<template>
  <h2>vuex中的count：{{count}}</h2>
</template>

<style>
</style>
```
此时先去demo页面，默认`count`是`0`，再去首页点击累加自增按钮，然后再回到`demo`页面，此时`demo`页面内的`count`就实现了累加功能，由`0`变为`1`，实现了`vuex`的数据共享

# 进阶版vue-router配置
接下来需要完善一下路由配置，此前只是简单的将路由写在`src/router/index.ts`文件内，但当项目越来越大，以及有动态路由、静态路由、路由权限、路由白名单问题时，这么写显然是不可能的了

## 静态路由模块化引入

动态路由这一块先不管，先把静态路由处理一下，这里把静态路由按根节点菜单进行模块化拆分：

#### src/router/modules/demo.ts
```
import Layout from "@/layout/index.vue";

const router = {
  path: "/demo",
  name: "demoLayout",
  component: Layout,
  meta: {
    title: "demo小样",
    showLink: true,
    sort:2
  },
  children: [
    {
      path: "/demo",
      name: "demo",
      component: () => import("@/views/demo/index.vue"),
      meta: {
        title: "demo小样",
        showLink: true,
        sort:1
      }
    }
  ]
};

export default router;
```
#### src/router/modules/error.ts
```
import Layout from "@/layout/index.vue";

const errorRouter = {
  path: "/error",
  name: "error",
  component: Layout,
  redirect: "/error/401",
  meta: {
    icon: "el-icon-position",
    title: "错误页面",
    showLink: true,
    sort: 7
  },
  children: [
    {
      path: "/error/401",
      name: "401",
      component: () => import("@/views/error/401/index.vue"),
      meta: {
        title: "401",
        showLink: true
      }
    },
    {
      path: "/error/404",
      name: "404",
      component: () => import("@/views/error/404/index.vue"),
      meta: {
        title: "404",
        showLink: true
      }
    }
  ]
};

export default errorRouter;
```
#### src/router/modules/home.ts
```
# src/router/modules/home.ts
import Layout from "@/layout/index.vue";

const router = {
  path: "/",
  name: "layout",
  component: Layout,
  meta: {
    showLink: true,
    sort:1
  },
  children: [
    {
      path: "/",
      name: "home",
      component: () => import("@/views/home/index.vue"),
      meta: {
        title: "首页",
        showLink: true,
        sort:1
      }
    }
  ]
};

export default router;
```
#### src/router/modules/nested.ts
```
import Layout from "@/layout/index.vue";

const router = {
  path: "/nested",
  name: "Nested",
  component: Layout,
  redirect: "/nested/menu1/menu1-1",
  meta:{
    sort:3,
    showLink:true,
    title:"嵌套路由"
  },
  children:[
    {
      path: "/nested/menu1",
      component: () => import("@/views/nested/menu1/index.vue"),
      name: "Menu1",
      redirect: "/nested/menu1/menu1-1",
      meta:{
        sort:1,
        showLink:true,
        title:"嵌套路由1"
      },
      children: [
          {
              path: "/nested/menu1/menu1-1",
              component: () => import("@/views/nested/menu1/menu1-1/index.vue"),
              name: "Menu1-1",
              meta:{
                sort:1,
                showLink:true,
                title:"嵌套路由1-1"
              },
          },
          {
              path: "/nested/menu1/menu1-2",
              component: () => import("@/views/nested/menu1/menu1-2/index.vue"),
              name: "Menu1-2",
              redirect: "/nested/menu1/menu1-2/menu1-2-1",
              meta:{
                sort:2,
                showLink:true,
                title:"嵌套路由1-2"
              },
              children: [
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-1",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-1/index.vue"),
                      name: "Menu1-2-1",
                      meta:{
                        sort:1,
                        showLink:true,
                        title:"嵌套路由1-2-1"
                      },
                  },
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-2",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-2/index.vue"),
                      name: "Menu1-2-2",
                      meta:{
                        sort:2,
                        showLink:true,
                        title:"嵌套路由1-2-2"
                      },
                  }
              ]
          },
          {
              path: "/nested/menu1/menu1-3",
              component: () => import("@/views/nested/menu1/menu1-3/index.vue"),
              name: "Menu1-3",
              meta:{
                sort:3,
                showLink:true,
                title:"嵌套路由1-3"
              },
          }
      ]
    },
    {
        path: "/nested/menu2",
        name: "Menu2",
        component: () => import("@/views/nested/menu2/index.vue"),
        meta:{
          sort:2,
          showLink:true,
          title:"嵌套路由2"
        },
    }
  ]
};

export default router;
```
####  src/router/index.ts
```
import { Router,RouteComponent,createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

// 静态非白名单路由
const modules = import.meta.glob("./modules/*.ts")
const constantRoutes:RouteRecordRaw[]=[]
for(const path in modules){
	const itemModule = await modules[path]()
	constantRoutes.push(itemModule.default)
}

// 按照路由中meta下的sort等级升序来排序路由
export const ascending = (arr:any) => {
    return arr.sort((a: any, b: any) => {
        return a?.meta?.sort - b?.meta?.sort;
    });
};
// 将所有静态路由导出
export const constantRoutesArr: Array<RouteComponent> = ascending(constantRoutes)

// 过滤meta中showLink为false的路由
export const filterTree = (data:any) => {
    const newTree = data.filter((v:any) => v.meta.showLink);
    newTree.forEach((v:any) => v.children && (v.children = filterTree(v.children)));
    return newTree;
};


// 创建路由实例
export const router: Router = createRouter({
    history: createWebHistory(),
    routes: filterTree(ascending(constantRoutes)),
});
  
export default router
```
这里将静态路由模块化引入后，需要注意的是，每个模块的第一个层级的`component`都是`layout`，有嵌套的模块第一层级与之前的写法有些小改动，在使用`layout`后，原本的`src/views/nested/index.vue`这个用来做承载的`router-view`就不需要了，该文件可以删除

此时的路由配置已实现静态路由的模块化引入，点击导航栏，各个路由页面能正常跳转，说明配置生效

## 其他路由引入
除了模块化的静态路由，动态路由外，类似于登录，注册，404，401等页面是不需要权限即可访问的页面，这些页面可以归类为其他路由，静态路由的权限这里暂时先不说，之后动态路由获取的时候一起再说
```
# src/router/remaining.ts
const remainingRouter = [
  {
    path: "/login",
    name: "login",
    component: () => import("@/views/login/index.vue"),
    meta: {
      title: "登录",
      showLink: false,
      sort: 101
    }
  },
];

export default remainingRouter;
```
这里先在路由中配置登录页面的路由，并创建对应的页面
```
# src/views/login/index.vue
<script setup lang="ts">

</script>
<template>
  <h2>登录</h2>
</template>

<style>
</style>
```

接着在`src/router/index.ts`中引入路由
```
import { Router,RouteComponent,createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

// 静态白名单路由
import remainingRouter from "./remaining";
// 静态非白名单路由
const modules = import.meta.glob("./modules/*.ts")
const constantRoutes:RouteRecordRaw[]=[]
for(const path in modules){
	const itemModule = await modules[path]()
	constantRoutes.push(itemModule.default)
}

// 按照路由中meta下的sort等级升序来排序路由
export const ascending = (arr:any) => {
    return arr.sort((a: any, b: any) => {
        return a?.meta?.sort - b?.meta?.sort;
    });
};
// 将所有静态路由导出
export const constantRoutesArr: Array<RouteComponent> = ascending(constantRoutes).concat(...remainingRouter);

// 过滤meta中showLink为false的路由
export const filterTree = (data:any) => {
    const newTree = data.filter((v:any) => v.meta.showLink);
    newTree.forEach((v:any) => v.children && (v.children = filterTree(v.children)));
    return newTree;
};


// 创建路由实例
export const router: Router = createRouter({
    history: createWebHistory(),
    routes: filterTree(ascending(constantRoutes)).concat(...remainingRouter),
});
  
export default router
```
此时运行项目链接访问`login`路径，都能正常访问对应页面，则配置生效


接下来需要引入动态路由，以及将左侧菜单动态的与路由关联起来，在这之前首先要做的是集成`axios`，`svg`等图标组件引入，以及`Mock`引入，`axios`用来之后项目的前后端请求使用，`svg`图标为项目丰富图标使用类型，`Mock`则是为了在无后端接口提供的情况下，能模拟请求后端接口，实现前端独立开发

# 实现 Icon 组件
这里需要注意的是，几乎所有现代框架都在把图标方案从`font`变为`svg`，从前文引入的`element-plus`导航中的图标，可以看到，在`plus`版本，图标已经变为了`svg`，这里把几种图标组件实现都列一下，可自行选择

### 自定义 svg 图标组件
这种适合全项目都只使用`svg`图标，且不使用`element-plus`图标的情况，只需要将下载的`svg`图标放在指定文件夹内即可全局使用，可以先在`src/assets/icons/svg/`文件夹内放一些已下载的`svg`图标，这里可以为所有下载`svg`图标加一个统一的前缀`sgn-`，前缀名可自定义，保证图标名中不会出现前缀名的情况就行

然后在`src/plugins`文件夹下新建`svgBuilder`文件夹，并在其内创建`index.ts`文件：
```
import { readFileSync, readdirSync } from 'fs'

let idPerfix = ''
const svgTitle = /<svg([^>+].*?)>/
const clearHeightWidth = /(width|height)="([^>+].*?)"/g

const hasViewBox = /(viewBox="[^>+].*?")/g

const clearReturn = /(\r)|(\n)/g

function findSvgFile(dir:any):any {
	const svgRes = []
	const dirents = readdirSync(dir, {
		withFileTypes: true
	})
	for (const dirent of dirents) {
		if (dirent.isDirectory()) {
			svgRes.push(...findSvgFile(dir + dirent.name + '/'))
		} else {
			const svg = readFileSync(dir + dirent.name)
				.toString()
				.replace(clearReturn, '')
				.replace(svgTitle, ($1, $2) => {
					// console.log(++i)
					// console.log(dirent.name)
					let width = 0
					let height = 0
					let content = $2.replace(clearHeightWidth, (s1:any, s2:any, s3:any) => {
						if (s2 === 'width') {
							width = s3
						} else if (s2 === 'height') {
							height = s3
						}
						return ''
					})
					if (!hasViewBox.test($2)) {
						content += `viewBox="0 0 ${width} ${height}"`
					}
					return `<symbol id="${idPerfix}-${dirent.name.replace('.svg', '')}" ${content}>`
				})
				.replace('</svg>', '</symbol>')
			svgRes.push(svg)
		}
	}
	return svgRes
}

export const svgBuilder = (path:any, perfix = 'icon') => {
	if (path === '') return
	idPerfix = perfix
	const res = findSvgFile(path)
	// console.log(res.length)
	// const res = []
	return {
		name: 'svg-transform',
		transformIndexHtml(html:any) {
			return html.replace(
				'<body>',
				`
          <body>
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="position: absolute; width: 0; height: 0">
              ${res.join('')}
            </svg>
        `
			)
		}
	}
}
```
修改`vite.config.ts`文件
```
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import ElementPlus from "unplugin-element-plus/vite";
import { svgBuilder } from './src/plugins/svgBuilder/index';
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
		vue(),
		[svgBuilder('./src/assets/icons/svg/')],
		ElementPlus({}),
	],
  resolve: {
		alias: {
			'@': resolve('src'),
		}
	}
})

```
然后在`src/components`文件夹创建`icon`组件:
```
# src/components/SvgIcon/index.vue
<script lang="ts">
import { defineComponent, computed } from 'vue'

interface Props {
	iconClass: string
	className: string
}

export default defineComponent({
	name: 'SvgIcon',
	props: {
		iconClass: {
			type: String,
			required: true
		},
		className: {
			type: String,
			default: () => ''
		}
	},
	setup(props: Props) {
		const iconName = computed((): string => `#icon-${props.iconClass}`)
		const svgClass = computed((): string => {
			if (props.className) {
				return 'svg-icon ' + props.className
			} else {
				return 'svg-icon'
			}
		})

		return {
			iconName,
			svgClass
		}
	}
})
</script>

<template>
	<svg :class="svgClass" aria-hidden="true" v-on="$attrs">
		<use :xlink:href="iconName" />
	</svg>
</template>

<style scoped>
.svg-icon {
	width: 1em;
	height: 1em;
	vertical-align: -0.15em;
	fill: currentColor;
	overflow: hidden;
}
</style>
```
在`src/main.ts`中全局注册该组件
```
import { createApp } from 'vue'
import router from './router'
import store from './store'
import App from './App.vue'
import { useElementPlus } from "@/plugins/element-plus"; // element-plus
import SvgIcon from './components/SvgIcon/index.vue'
import '@/style/index.scss';

const app = createApp(App)

app.component('svg-icon', SvgIcon); // 全局注册svg图标组件
app.use(router)
app.use(store)
app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')
```
在`home`页面使用组件
```
<svg-icon icon-class="sgn-close"></svg-icon>
```
此时home页面预览出现关闭按钮，则代表`svg`图标插件已引入完成，此种方式的`icon`组件主要用于使已下载到项目中的`svg`文件，作为组件注册到全局使用


### 集成式图标组件
该种方式既可使用`svg`图标，也可以使用字体图标库的图标，还能使用下载的字体图标，同时还把`element-plus`的`svg`图标集成在了里面，这里首先需要安装一个插件：
```
yarn add vite-svg-loader -D
```
该插件主要可将`svg`文件作为`vue`组件进行加载，这样就解决了`element-plus`无法动态赋值问题，安装后修改`vite.config.ts`文件：
```
# 文件头部新增：
import svgLoader from "vite-svg-loader"
# plugins中新增：
svgLoader(),
```
#### 集成 font awesome 图标库
```
yarn add font-awesome @fortawesome/vue-fontawesome @fortawesome/free-solid-svg-icons @fortawesome/fontawesome-svg-core
```
修改`tsconfig.json`文件：
```
# compilerOptions 内新增:
"allowJs": false,
"incremental": true,
```
在`src/plugins`中新建`font-awesome`文件夹，并在其内新建`index.ts`文件：
```
/** 兼容fontawesome4和5版本
 * 4版本: www.fontawesome.com.cn/faicons/
 * 5版本：https://fontawesome.com/v5.15/icons?d=gallery&p=2&m=free
 * https://github.com/FortAwesome/vue-fontawesome
 */
 import { App } from "vue";
 import "font-awesome/css/font-awesome.css";
 import { library } from "@fortawesome/fontawesome-svg-core";
 import { fas } from "@fortawesome/free-solid-svg-icons";
 import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";
 
 export function useFontAwesome(app: App) {
   library.add(fas);
   app.component("font-awesome-icon", FontAwesomeIcon);
 }
```
在`src/main.ts`中引入：
```
# 头部引入
import { useFontAwesome } from "@/plugins/font-awesome";
# 全局配置注释行之上进行调用
app.use(useFontAwesome);
```
#### 集成 element-plus 图标
这里需要先下载`element-plus`的图标插件
```
yarn add @element-plus/icons
```
修改`src/plugins/element-plus/index.ts`文件：
```
import { App, Component } from "vue";
import {
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElDatePicker,
  ElForm,
  ElFormItem,
  ElLoading,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
  ElBacktop,
  ElSwitch
} from "element-plus";

import {
  Check,
  Menu,
  HomeFilled,
  SetUp,
  Edit,
  Setting,
  Lollipop,
  Link,
  Position,
  Histogram,
  RefreshRight,
  ArrowDown,
  Close,
  CloseBold
} from "@element-plus/icons";

const components:any[] = [
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElDatePicker,
  ElForm,
  ElFormItem,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
  ElBacktop,
  ElSwitch
];
// icon
export const iconComponents = [
  Check,
  Menu,
  HomeFilled,
  SetUp,
  Edit,
  Setting,
  Lollipop,
  Link,
  Position,
  Histogram,
  RefreshRight,
  ArrowDown,
  Close,
  CloseBold
];
const plugins = [ElLoading];

export function useElementPlus(app: App) {
    components.push(...iconComponents);
    components.forEach((component: Component) => {
        app.component(component.name, component);
    });
    plugins.forEach(plugin => {
        app.use(plugin);
    });
}
```
#### 集成 iconfont 图标
可以先在阿里图标库选一套心仪的图标下载到本地，将下载的文件存放到`src/assets/icons/iconfont`文件夹下，然后在`src/main.ts`文件中直接引入：
```
// 导入字体图标
import "@/assets/icons/iconfont/iconfont.js";
import "@/assets/icons/iconfont/iconfont.css";
```

#### 实现适配组件
以上的`font-awesome`图标、`element-plus`图标、`iconfont`图标、以及之前的`src/assets/icons/svg`下的`svg`图标，现在需要一个组件来满足能使用各种图标的需求，在`src/components`文件夹下新建`Icon`文件夹，其内新建`index.ts`文件、`src`文件夹，`src`文件夹下新建`Icon.vue`文件：
```
# src/components/Icon/index.ts
import { App, defineComponent } from "vue";
import icon from "./src/Icon.vue";
import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";
import { iconComponents } from "@/plugins/element-plus";

export const Icon = Object.assign(icon, {
  install(app: App) {
    app.component(icon.name, icon);
  }
});

export default {
  Icon
};
/**
 * find icon component
 * @param icon icon图标
 * @returns component
 */
export function findIconReg(icon: string) {
  const faReg = /^fa-/;
  if (faReg.test(icon)) {
    return findIcon(icon.split(faReg)[1]);
  } else {
    return findIcon(icon, false);
  }
}
export function findIcon(icon: String, isFa: Boolean = true) {
  if (isFa) {
    return defineComponent({
      name: "FaIcon",
      data() {
        return { icon: icon };
      },
      components: { FontAwesomeIcon },
      template: `<font-awesome-icon :icon="icon" />`
    });
  } else {
    const components = iconComponents.filter(
      component => component.name === icon
    );
    if (components.length > 0) {
      return components[0];
    } else {
      return null;
    }
  }
}
```
`src/components/Icon/src/Icon.vue`:
```
<script lang="ts">
export default {
  name: "Icon"
};
</script>

<script setup lang="ts">
import { ref, computed } from "vue";

const props = defineProps({
  content: {
    type: String,
    default: ""
  },
  size: {
    type: Number,
    default: 18
  },
  width: {
    type: Number,
    default: 20
  },
  height: {
    type: Number,
    default: 20
  },
  color: {
    type: String,
    default: ""
  },
  svg: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits<{
  (e: "click"): void;
}>();

let text = ref("");

let className = computed(() => {
  if (props.content.indexOf("fa-") > -1) {
    return props.content.indexOf("fa ") === 0
      ? props.content
      : ["fa", props.content];
  } else if (props.content.indexOf("el-icon-") > -1) {
    return props.content;
  } else if (props.content.indexOf("iconfont-") > -1) {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    return ["iconfont", "icon-"+props.content.split('iconfont-')[1]];
  } else {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    text.value = props.content;
    return "";
  }
});

let iconStyle = computed(() => {
  return (
    "font-size: " +
    props.size +
    "px; color: " +
    props.color +
    "; width: " +
    props.width +
    "px; height: " +
    props.height +
    "px; font-style: normal;"
  );
});

const clickHandle = () => {
  emit("click");
};
</script>

<template>
  <i
    v-if="!props.svg"
    :class="className"
    :style="iconStyle"
    v-html="text"
    @click="clickHandle"
  ></i>
  <svg
    class="icon-svg"
    v-if="props.svg"
    aria-hidden="true"
    :style="iconStyle"
    @click="clickHandle"
  >
    <use :xlink:href="`#${props.content}`" />
  </svg>
</template>
```
组件创建完成，对每种图标情况都做一下测试
##### 使用 font awesome 的 svg 图标
```
# src/app.vue script标签内
import { findIconReg } from "@/components/Icon";
# template标签内
<el-icon><component :is="findIconReg('fa-address-book')"></component></el-icon>
```
此时运行项目会发现图标并没有显示出来，控制台报了一套警告：
```
[Vue warn]: Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js"
```
这时需要修改`vite.config.ts`文件，在别名配置中加上`vue`的别名配置
```
resolve: {
  alias: {
    '@': resolve('src'),
    'vue':'vue/dist/vue.esm-bundler.js'
  }
},
```
此时再运行项目，图标就能正常显示了
##### 使用 font awesome 的字体图标
```
# src/app.vue script标签内
import Icon from "@/components/Icon/src/Icon.vue";
# template标签内
<Icon :content="'fa-address-book'"/>
```
运行项目，可以看到图标能正常显示，以上是两种引用方式，`font awesome`的`svg`图标因为是属于第三方组件，所以这里需要使用`component`去渲染第三方组件

##### 使用 iconfont 的 `svg` 图标
`iconfont`的识别前缀可在`src/assets/icons/iconfont/iconfont.json`文件中查看，`css_prefix_text`为图标的识别前缀，想使用哪个图标，找到该图标的`font_class`即可
```
# src/app.vue
# template标签内
<Icon :svg="true" :content="'icon-star'"/>
```
运行项目可发现图标已正常显示，查看源码可发现已经使用的是`svg`图标，在`src/asstes/icons/iconfont/iconfont.js`中保存有所有图标的`svg`代码，而该文件在`src/main.ts`文件中已引入

##### 使用 iconfont 的字体图标
看`src/components/Icon/src/Icon.vue`文件中代码，`className`的定义中，如果`content`中存在`iconfont-`，即判断为`iconfont`图标，并返回`iconfont icon-`具体图标，两个类名，使其符合`iconfont`字体图标的引用方式，所以这里要引用`iconfont`的字体图标如下：
```
# src/app.vue
# template标签内
<Icon :content="'iconfont-star'"/>
```
此时运行项目，就可以看到该图标已正常显示，源码中查看，可看到为字体图标的引入方式

##### 使用 element-plus 的 svg 图标
这里`element-plus`的`svg`图标已经独立出`element-plus`项目，上面配置时，已下载`@element-plus/icons`，且在`src/plugins/element-plus/index.ts`文件中，已按需加载了一些常用图标，加载时已将图标名作为组件名进行了注册，所以这里`element-plus`的`svg`图标的引入方式与`font awesome`的`svg`图标引入方式相同：
```
# src/app.vue
# template标签内
<el-icon><component :is="findIconReg('HomeFilled')"></component></el-icon>
```
此时运行项目，图标能正常显示
##### 使用 element-plus 的字体图标
此时项目依然可以使用`element-plus`的字体图标
```
# src/app.vue
# template标签内
<Icon :content="'el-icon-user'"/>
```
运行项目，图标也依然能正常显示，此时基本就涵盖了所有的图标引用方式
***第一种方式全局注册组件使用svg文件作为图标的方式，在有了集成式图标组件后，可不再使用，在iconfont.js文件已经有了svg图标的使用，两者都有较高的定制性***

不过这里也可以将该全局组件也集成到图标组件内
```
# src/components/Icon/src/Icon.vue
<script lang="ts">
export default {
  name: "Icon"
};
</script>

<script setup lang="ts">
import { ref, computed } from "vue";

const props = defineProps({
  content: {
    type: String,
    default: ""
  },
  size: {
    type: Number,
    default: 18
  },
  width: {
    type: Number,
    default: 20
  },
  height: {
    type: Number,
    default: 20
  },
  color: {
    type: String,
    default: ""
  },
  svg: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits<{
  (e: "click"): void;
}>();

let text = ref("");

let className = computed(() => {
  if (props.content.indexOf("fa-") > -1) {
    return props.content.indexOf("fa ") === 0
      ? props.content
      : ["fa", props.content];
  } else if (props.content.indexOf("el-icon-") > -1) {
    return props.content;
  } else if (props.content.indexOf("iconfont-") > -1) {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    return ["iconfont", "icon-"+props.content.split('iconfont-')[1]];
  }else {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    text.value = props.content;
    return "";
  }
});

let iconStyle = computed(() => {
  return (
    "font-size: " +
    props.size +
    "px; color: " +
    props.color +
    "; width: " +
    props.width +
    "px; height: " +
    props.height +
    "px; font-style: normal;"
  );
});

const clickHandle = () => {
  emit("click");
};
</script>

<template>
  <i
    v-if="!props.svg&&props.content.indexOf('sgn-')===-1"
    :class="className"
    :style="iconStyle"
    v-html="text"
    @click="clickHandle"
  ></i>
  <svg
    class="icon-svg"
    v-if="props.svg&&props.content.indexOf('sgn-')===-1"
    aria-hidden="true"
    :style="iconStyle"
    @click="clickHandle"
  >
    <use :xlink:href="`#${props.content}`" />
  </svg>
  <svg-icon v-if="props.svg&&props.content.indexOf('sgn-')>-1" :icon-class="props.content"></svg-icon>
</template>
```
如此的话，我们只需使用`Icon`组件，就能实现所有形式的图标引入
```
# src/app.vue
# template标签内
<Icon :svg="true" :content="'sgn-close'"/>
```
这里给这种调用`svg`文件一个特定识别标志`sgn-`，在下载`svg`文件命名时，都统一加上该前缀，这样在后期动态引入时该使用组件中的哪种形式就有了判断的标准

到此图标组件就算彻底完工了，总结一下：字体图标的引入使用的是`Icon`组件，且不传`svg`这个参数（因`svg`这个参数默认是`false`）,`svg`图标的引入有两种形式，`Icon`组件的形式多用于有具体的`svg`文件代码，如`iconfont.js`里的`svg`代码，以及下载本地`svg`文件的形式，而`component`形式则用于`svg`图标本身已经是第三方组件，需要使用组件调用的形式，如`font awesome`和`element-plus icon`

那么在动态引入时依据什么去判断使用哪种？字体图标这里只是为了兼容加上的，因为有字体图标的存在，那肯定也有对应的`svg`图标存在，所以这里只说下`svg`图标动态引入时，如何进行判断，根据动态获取到的图标字段中的前缀去判断，如果有`sng-`前缀以及`icon-`前缀，则使用`Icon`组件，且必传`svg`参数，值为`true`，其他情况使用`component`的`is`绑定形式


# 集成 axios
```
yarn add axios
# 请求调用进度条
yarn add nprogress
yarn add @types/nprogress -D
```
这里使用别人封装好的`axios`，以及`nprogress`
```
# src/utils/http/config.ts
import { AxiosRequestConfig } from "axios";
import { excludeProps } from "./utils";
/**
 * 默认配置
 */
export const defaultConfig: AxiosRequestConfig = {
  baseURL: "",
  //10秒超时
  timeout: 10000,
  headers: {
    Accept: "application/json, text/plain, */*",
    "Content-Type": "application/json",
    "X-Requested-With": "XMLHttpRequest"
  }
};

export function genConfig(config?: AxiosRequestConfig): AxiosRequestConfig {
  if (!config) {
    return defaultConfig;
  }

  const { headers } = config;
  if (headers && typeof headers === "object") {
    defaultConfig.headers = {
      ...defaultConfig.headers,
      ...headers
    };
  }
  return { ...excludeProps(config!, "headers"), ...defaultConfig };
}

export const METHODS = ["post", "get", "put", "delete", "option", "patch"];

```
此文件内的默认配置部分，需根据个人前后端项目需求进行配置，`baseURL`配置为个人后端接口

```
# src/utils/http/core.ts
import Axios, {
  AxiosRequestConfig,
  CancelTokenStatic,
  AxiosInstance
} from "axios";

import NProgress from "../progress";

import { genConfig } from "./config";

import { transformConfigByMethod } from "./utils";

import {
  cancelTokenType,
  RequestMethods,
  EnclosureHttpRequestConfig,
  EnclosureHttpResoponse,
  EnclosureHttpError
} from "./types.d";

class EnclosureHttp {
  constructor() {
    this.httpInterceptorsRequest();
    this.httpInterceptorsResponse();
  }
  // 初始化配置对象
  private static initConfig: EnclosureHttpRequestConfig = {};

  // 保存当前Axios实例对象
  private static axiosInstance: AxiosInstance = Axios.create(genConfig());

  // 保存 EnclosureHttp实例
  private static EnclosureHttpInstance: EnclosureHttp;

  // axios取消对象
  private CancelToken: CancelTokenStatic = Axios.CancelToken;

  // 取消的凭证数组
  private sourceTokenList: Array<cancelTokenType> = [];

  // 记录当前这一次cancelToken的key
  private currentCancelTokenKey = "";

  private beforeRequestCallback: EnclosureHttpRequestConfig["beforeRequestCallback"] =
    undefined;

  private beforeResponseCallback: EnclosureHttpRequestConfig["beforeResponseCallback"] =
    undefined;

  public get cancelTokenList(): Array<cancelTokenType> {
    return this.sourceTokenList;
  }

  // eslint-disable-next-line class-methods-use-this
  public set cancelTokenList(value) {
    throw new Error("cancelTokenList不允许赋值");
  }

  /**
   * @description 私有构造不允许实例化
   * @returns void 0
   */
  // constructor() {}

  /**
   * @description 生成唯一取消key
   * @param config axios配置
   * @returns string
   */
  // eslint-disable-next-line class-methods-use-this
  private static genUniqueKey(config: EnclosureHttpRequestConfig): string {
    return `${config.url}--${JSON.stringify(config.data)}`;
  }

  /**
   * @description 取消重复请求
   * @returns void 0
   */
  private cancelRepeatRequest(): void {
    const temp: { [key: string]: boolean } = {};

    this.sourceTokenList = this.sourceTokenList.reduce<Array<cancelTokenType>>(
      (res: Array<cancelTokenType>, cancelToken: cancelTokenType) => {
        const { cancelKey, cancelExecutor } = cancelToken;
        if (!temp[cancelKey]) {
          temp[cancelKey] = true;
          res.push(cancelToken);
        } else {
          cancelExecutor();
        }
        return res;
      },
      []
    );
  }

  /**
   * @description 删除指定的CancelToken
   * @returns void 0
   */
  private deleteCancelTokenByCancelKey(cancelKey: string): void {
    this.sourceTokenList =
      this.sourceTokenList.length < 1
        ? this.sourceTokenList.filter(
            cancelToken => cancelToken.cancelKey !== cancelKey
          )
        : [];
  }

  /**
   * @description 拦截请求
   * @returns void 0
   */

  private httpInterceptorsRequest(): void {
    EnclosureHttp.axiosInstance.interceptors.request.use(
      (config: EnclosureHttpRequestConfig) => {
        const $config = config;
        NProgress.start(); // 每次切换页面时，调用进度条
        const cancelKey = EnclosureHttp.genUniqueKey($config);
        $config.cancelToken = new this.CancelToken(
          (cancelExecutor: (cancel: any) => void) => {
            this.sourceTokenList.push({ cancelKey, cancelExecutor });
          }
        );
        this.cancelRepeatRequest();
        this.currentCancelTokenKey = cancelKey;
        // 优先判断post/get等方法是否传入回掉，否则执行初始化设置等回掉
        if (typeof this.beforeRequestCallback === "function") {
          this.beforeRequestCallback($config);
          this.beforeRequestCallback = undefined;
          return $config;
        }
        if (EnclosureHttp.initConfig.beforeRequestCallback) {
          EnclosureHttp.initConfig.beforeRequestCallback($config);
          return $config;
        }
        return $config;
      },
      error => {
        return Promise.reject(error);
      }
    );
  }

  /**
   * @description 清空当前cancelTokenList
   * @returns void 0
   */
  public clearCancelTokenList(): void {
    this.sourceTokenList.length = 0;
  }

  /**
   * @description 拦截响应
   * @returns void 0
   */
  private httpInterceptorsResponse(): void {
    const instance = EnclosureHttp.axiosInstance;
    instance.interceptors.response.use(
      (response: EnclosureHttpResoponse) => {
        // 请求每次成功一次就删除当前canceltoken标记
        const cancelKey = EnclosureHttp.genUniqueKey(response.config);
        this.deleteCancelTokenByCancelKey(cancelKey);
        // 优先判断post/get等方法是否传入回掉，否则执行初始化设置等回掉
        if (typeof this.beforeResponseCallback === "function") {
          this.beforeResponseCallback(response);
          this.beforeResponseCallback = undefined;
          return response.data;
        }
        if (EnclosureHttp.initConfig.beforeResponseCallback) {
          EnclosureHttp.initConfig.beforeResponseCallback(response);
          return response.data;
        }
        NProgress.done();
        return response.data;
      },
      (error: EnclosureHttpError) => {
        const $error = error;
        // 判断当前的请求中是否在 取消token数组理存在，如果存在则移除（单次请求流程）
        if (this.currentCancelTokenKey) {
          const haskey = this.sourceTokenList.filter(
            cancelToken => cancelToken.cancelKey === this.currentCancelTokenKey
          ).length;
          if (haskey) {
            this.sourceTokenList = this.sourceTokenList.filter(
              cancelToken =>
                cancelToken.cancelKey !== this.currentCancelTokenKey
            );
            this.currentCancelTokenKey = "";
          }
        }
        $error.isCancelRequest = Axios.isCancel($error);
        NProgress.done();
        // 所有的响应异常 区分来源为取消请求/非取消请求
        return Promise.reject($error);
      }
    );
  }

  public request<T>(
    method: RequestMethods,
    url: string,
    param?: AxiosRequestConfig,
    axiosConfig?: EnclosureHttpRequestConfig
  ): Promise<T> {
    const config = transformConfigByMethod(param, {
      method,
      url,
      ...axiosConfig
    } as EnclosureHttpRequestConfig);
    // 单独处理自定义请求/响应回掉
    if (axiosConfig?.beforeRequestCallback) {
      this.beforeRequestCallback = axiosConfig.beforeRequestCallback;
    }
    if (axiosConfig?.beforeResponseCallback) {
      this.beforeResponseCallback = axiosConfig.beforeResponseCallback;
    }
    return new Promise((resolve, reject) => {
      EnclosureHttp.axiosInstance
        .request(config)
        .then((response: any) => {
          resolve(response);
        })
        .catch((error: any) => {
          reject(error);
        });
    });
  }
  public post<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T> {
    return this.request<T>("post", url, params, config);
  }

  public get<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T> {
    return this.request<T>("get", url, params, config);
  }
}
export default EnclosureHttp;
```
此文件内拦截请求，以及拦截响应内的逻辑可根据自己项目的后端逻辑进行相应的修改

其余文件基本无需有改动
```
# src/utils/http/index.ts
import EnclosureHttp from "./core";
export const http = new EnclosureHttp();

# src/utils/http/types.d.ts
import Axios, {
  AxiosRequestConfig,
  Canceler,
  AxiosResponse,
  Method,
  AxiosError
} from "axios";

import { METHODS } from "./config";

export type cancelTokenType = { cancelKey: string; cancelExecutor: Canceler };

export type RequestMethods = Extract<
  Method,
  "get" | "post" | "put" | "delete" | "patch" | "option" | "head"
>;

export interface EnclosureHttpRequestConfig extends AxiosRequestConfig {
  beforeRequestCallback?: (request: EnclosureHttpRequestConfig) => void; // 请求发送之前
  beforeResponseCallback?: (response: EnclosureHttpResoponse) => void; // 相应返回之前
}

export interface EnclosureHttpResoponse extends AxiosResponse {
  config: EnclosureHttpRequestConfig;
}

export interface EnclosureHttpError extends AxiosError {
  isCancelRequest?: boolean;
}

export default class EnclosureHttp {
  cancelTokenList: Array<cancelTokenType>;
  clearCancelTokenList(): void;
  request<T>(
    method: RequestMethods,
    url: string,
    param?: AxiosRequestConfig,
    axiosConfig?: EnclosureHttpRequestConfig
  ): Promise<T>;
  post<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T>;
  get<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T>;
}

# src/utils/http/utils.ts
import { EnclosureHttpRequestConfig } from "./types.d";

export function excludeProps<T extends { [key: string]: any }>(
  origin: T,
  prop: string
): { [key: string]: T } {
  return Object.keys(origin)
    .filter(key => !prop.includes(key))
    .reduce((res, key) => {
      res[key] = origin[key];
      return res;
    }, {} as { [key: string]: T });
}

export function transformConfigByMethod(
  params: any,
  config: EnclosureHttpRequestConfig
): EnclosureHttpRequestConfig {
  const { method } = config;
  const props = ["delete", "get", "head", "options"].includes(
    method!.toLocaleLowerCase()
  )
    ? "params"
    : "data";
  return {
    ...config,
    [props]: params
  };
}

# src/utils/progress/index.ts
import NProgress from "nprogress";
import "nprogress/nprogress.css";

NProgress.configure({
  // 动画方式
  easing: "ease",
  // 递增进度条的速度
  speed: 500,
  // 是否显示加载ico
  showSpinner: true,
  // 自动递增间隔
  trickleSpeed: 200,
  // 初始化时的最小百分比
  minimum: 0.3
});

export default NProgress;

```
到此项目集成`axios`已经算基本完成，具体使用后面再做介绍

# 集成 Mock
```
yarn add mockjs vite-plugin-mock -D
```

修改`vite.config.ts`文件：
```
import { UserConfigExport, ConfigEnv, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import ElementPlus from "unplugin-element-plus/vite";
import { svgBuilder } from './src/plugins/svgBuilder/index';
import { viteMockServe } from "vite-plugin-mock";
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default ({ command, mode }: ConfigEnv): UserConfigExport => {
	const prodMock = true;
	return {
		plugins: [
			vue(),
			[svgBuilder('./src/assets/icons/svg/')],
			ElementPlus({}),
			viteMockServe({
				mockPath: "./mock", // 模拟接口api文件存放的文件夹
				watchFiles: true, // 将监视文件夹中的文件更改。 并实时同步到请求结果
				localEnabled: command === "serve", // 设置是否启用本地 xxx.ts 文件，不要在生产环境中打开它.设置为 false 将禁用 mock 功能
				prodEnabled: command !== "serve" && prodMock, // 设置生产环境是否启用 mock 功能
				injectCode: `
					import { setupProdMockServer } from './mockProdServer';
					setupProdMockServer();
				`, // 如果生产环境开启了mock功能，该代码会注入到injectFile对应的文件的底部，默认为main.{ts,js}
				injectFile:path.resolve(process.cwd(),'src/main.{ts,js}'),
				logger: true
			})
		],
		resolve: {
			alias: {
				'@': resolve('src'),
			}
		}
	}
}
```
根目录添加`mock`文件夹，并在其内创建`asyncRoutes.ts`文件，用来存放模拟后端请求的动态路由数据及接口
```
import { MockMethod } from "vite-plugin-mock";

// http://mockjs.com/examples.html#Object
const systemRouter = {
  path: "/system",
  name: "system",
  redirect: "/system/user",
  meta: {
    icon: "menu-system",
    title: "设置",
    showLink: true,
    sort: 10
  },
  children: [
    {
      path: "/system/user",
      name: "user",
      meta: {
        title: "个人中心",
        showLink: true,
        sort: 1
      }
    },
    {
      path: "/system/dict",
      name: "dict",
      meta: {
        title: "字典表",
        showLink: true,
        sort: 2
      }
    }
  ]
};


export default [
  {
    url: "/getAsyncRoutes",
    method: "post",
    response: () => {
      return {
        code: 200,
        data: [systemRouter]
      };
    }
  }
] as MockMethod[];
```

在`src`文件夹下创建`mockProdServer.ts`文件（该文件用来生产环境获取mock数据使用）:
```
import { createProdMockServer } from "vite-plugin-mock/es/createProdMockServer";
import asyncRoutesMock from "../mock/asyncRoutes";

export const mockModules = [...asyncRoutesMock];

export function setupProdMockServer() {
  createProdMockServer(mockModules);
}
```
此时`mock`功能就算已经接入成功了，接下来是配合`axios`请求`mock`中的接口，以获取`mock`中存放的数据

这里配合完善`vue-router`以及`vuex`的状态管理，来走通`axios`请求，以及获取`mock`数据

# 串联 vue-router vuex axios mock

在这之前已经写了`mock`数据，`mock/asyncRoutes.ts`文件中暴露出了一个接口，并返回了给定的数据，这一步就相当于后端程序写好了接口，并在接口中返回了前端需要的数据，前端这边需要做的是调用接口，新建`src/api/routes.ts`文件：
```
import { http } from "../utils/http";

export const getAsyncRoutes = (data?: object) => {
  return http.request("post", "/getAsyncRoutes", data);
};
```
这里调用之前已经封装好的`axios`去请求`mock`中写好的接口，然后在需要用到的地方引入这里暴露出来的方法，我们需要在路由中将动态路由，静态路由合并，组装出符合要求的路由结构数据，这个过程需要通过`vuex`去做状态管理

## 获取动态路由

```
# src/router/index.ts  新增
import Layout from "@/layout/index.vue";
const modulesRoutes = import.meta.glob("/src/views/*/*/*.vue");
// 动态路由
import { getAsyncRoutes } from "@/api/routes";


// 过滤后端传来的动态路由 重新生成规范路由
export const addAsyncRoutes = (arrRoutes: Array<RouteComponent>,isRootRedirect:Boolean) => {
    if (!arrRoutes || !arrRoutes.length) return;
    arrRoutes.forEach((v: any) => {
      if (v.redirect&&isRootRedirect) {
        v.component = Layout;
      } else {
        v.component = modulesRoutes[`/src/views${v.path}/index.vue`];
      }
      if (v.children) {
        addAsyncRoutes(v.children,false);
      }
    });
    return arrRoutes;
};

// 初始化路由
export const initRouter = () => {
  return new Promise(resolve => {
    getAsyncRoutes().then((data:any) => {
      console.log(data,"动态路由");
      if (data.length === 0) {
      } else {
        addAsyncRoutes(data,true)?.map((v: any) => {
          // 防止重复添加路由
          if (router.options.routes.findIndex(value => value.path === v.path) !== -1) {
            return;
          } else {
            // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            router.options.routes.push(v);
            // 最终路由进行升序
            ascending(router.options.routes);
            router.addRoute(v.name, v);
          }
          resolve(router);
        });
      }
      router.addRoute({path: "/:pathMatch(.*)",redirect: "/error/404"});
    });
  });
};
```
这里引入`api/routers.ts`暴露的方法，并在初始化路由时使用该方法请求数据，这里可以看到中间有个过滤后端传递过来的动态路由，生成规范路由，这一步判断`component`是否使用`layout`，我这里是通过是否有重定向以及是根节点，这两个条件，这里可根据项目需求自行修改，还需要注意的一点是，这里假定后端返回的动态路由已经是树形结构，`mock`中的数据已经是树形结构，且是符合路由规范的，但正常情况下，后端返回的路由一般为一维数组，且并不符合规范路由写法，这些都要根据后端返回的数据格式在初始化路由，获取到动态数据后，自行处理。

到了这时，动态路由获取的方法已经写好，但还并未调用，以及和静态组合的工作也还未做，此时需要通过`vuex`来管理所有路由，在导航守卫中监控`vuex`中路由存不存在，如不存在则需要在这里调用初始化路由，获取动态路由，并在初始化路由中使用`vuex`的特性，将动态路由与静态路由合并，保存在`vuex`中

## vuex进阶配置
为什么说这里要使用`vuex`来保存所有路由，`vuex`的作用是什么。我们能在`vuex`中集中管理共享的数据，能够高效的实现组件之间的数据共享，存储在`vuex`中的数据都是响应式的，能够实时保持数据与页面的同步，这里的路由数据，不仅需要在导航守卫中用到，还需要在侧边导航栏中调用数据，生成菜单栏，所以需要一个能够更方便在任何地方都可以非常快捷的获取到数据的方法，而`vuex`就能做到这一点

在这之前已经简单的将`vuex`集成到项目中了，现在需要优化一下，像路由一样，数据在`vuex`中管理，也需要分一下模块，新建`src/store/modules/routes.ts`文件：
```
import { Module } from 'vuex'
import { constantRoutesArr, ascending, filterTree } from "@/router";

const routesModule: Module = {
  namespaced: true,
  state: {
    // 静态路由
    constantRoutes: [],
    // 所有路由
    wholeRoutes: [],
  },
  mutations:{},
  actions: {
    // 获取所有路由（静态+动态获取部分）
    asyncActionRoutes({state},routes) {
      if(state.wholeRoutes.length > 0){
        return;
      }
      state.wholeRoutes = filterTree(
        ascending(ascending(constantRoutesArr).concat(routes))
      );
    },
  }
};
export default routesModule
```
这么写之后，会发现页面报`TS`类型错误，这里需要先声明类型，在根目录新建`types`文件夹，并新建`store.d.ts`文件，这个文件将是之后状态管理里的所有类型声明的集合文件
```
import { ComponentCustomProperties } from 'vue'
import { Store } from 'vuex'
import { RouteComponent } from 'vue-router'

declare interface Routes {
  constantRoutes:RouteComponent
  wholeRoutes:Array
}

declare interface State {
  routes: Routes
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $store: Store<State>
  }
}
```
然后修改`tsconfig.json`文件：
```
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "node",
    "strict": false,
    "jsx": "preserve",
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "lib": ["esnext", "dom"],
    // 新增
    "baseUrl": ".", 
    "paths":{
      "@/*": ["src/*"],
      "#/*": ["types/*"]
    },
    "types": ["node", "vite/client", "element-plus/global"],
    "typeRoots": ["./node_modules/@types/", "./types"],
    "importHelpers": true,
    "experimentalDecorators": true,
    "strictFunctionTypes": false,
    "skipLibCheck": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
  },
  "include": [
    "src/**/*.ts", 
    "src/**/*.tsx", 
    "src/**/*.vue",
    "types/*.d.ts",
    "vite.config.ts"
  ],
  "exclude": ["node_modules", "dist", "**/*.js"]
}
```
在`vite.config.ts`文件中增加文件夹别名配置：
```
resolve: {
  alias: {
    '@': resolve('src'),
    '#': resolve('types'),
  }
}
```
修改`src/store/modules/routes.ts`文件：
```
import { Module } from 'vuex'
import { Routes } from "#/store";
import { constantRoutesArr, ascending, filterTree } from "@/router";

const routesModule: Module<Routes,any> = {
  namespaced: true,
  state: {
    // 静态路由
    constantRoutes: [],
    // 所有路由
    wholeRoutes: [],
  },
  mutations:{},
  actions: {
    // 获取所有路由（静态+动态获取部分）
    asyncActionRoutes({state},routes) {
      if(state.wholeRoutes.length > 0){
        return;
      }
      state.wholeRoutes = filterTree(
        ascending(ascending(constantRoutesArr).concat(routes))
      );
    },
  }
};
export default routesModule
```
此时顺带将`src`文件夹下的`env.d.ts`文件删除，并在`types`文件夹下新建`shims-vue.d.ts`文件：
```
declare module "*.vue" {
  import { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}

declare module "*.scss" {
  const scss: Record<string, string>;
  export default scss;
}
```
根目录新增`.eslintignore`文件：
```
public
dist
*.d.ts
package.json
```
此时文件内的`TS`报错应该都已经不存在了，路由数据的状态管理模块已经创建好，接下来需要改一下`src/store/index.ts`文件，让模块化的`vuex`可以自动挂载到项目中
```
import { createStore } from 'vuex';
import { State } from '#/store';

// Vite supports importing multiple modules from the file system using the special import.meta.glob function
// see https://cn.vitejs.dev/guide/features.html#glob-import
const modulesFiles = import.meta.globEager('./modules/*.ts');
const pathList: string[] = [];

for (const path in modulesFiles) {
  pathList.push(path);
}

const modules = pathList.reduce((modules: any, modulePath: string) => {
  const moduleName = modulePath.replace(/^\.\/modules\/(.*)\.\w+$/, '$1');
  const value = modulesFiles[modulePath];
  modules[moduleName] = value.default;
  return modules;
}, {});

const store = createStore<State>({
  modules
});

export default store
```
到此，`vuex`的配置就算完成了，后期只需在此基础上新增状态管理，以及对应的在`types/store.d.ts`文件内新增类型声明即可

接下来就是通过导航守卫功能，将整条链路打通

## 导航守卫

做导航守卫之前，先引入一个别人封装好的缓存工具：
```
# src/utils/storage/index.ts
interface ProxyStorage {
  getItem(key: string): any;
  setItem(Key: string, value: string): void;
  removeItem(key: string): void;
  clear(): void;
}

//sessionStorage operate
class sessionStorageProxy implements ProxyStorage {
  protected storage: ProxyStorage;

  constructor(storageModel: ProxyStorage) {
    this.storage = storageModel;
  }

  // 存
  public setItem(key: string, value: any): void {
    this.storage.setItem(key, JSON.stringify(value));
  }

  // 取
  public getItem(key: string): any {
    return JSON.parse(this.storage.getItem(key)) || null;
  }

  // 删
  public removeItem(key: string): void {
    this.storage.removeItem(key);
  }

  // 清空
  public clear(): void {
    this.storage.clear();
  }
}

//localStorage operate
class localStorageProxy extends sessionStorageProxy implements ProxyStorage {
  constructor(localStorage: ProxyStorage) {
    super(localStorage);
  }
}
export const storageSession = new sessionStorageProxy(sessionStorage);

export const storageLocal = new localStorageProxy(localStorage);
```
以及打开超链接的一个工具函数：
```
# src/utils/link.ts
export const openLink = (link: string) => {
  const $a: HTMLElement = document.createElement("a");
  $a.setAttribute("href", link);
  $a.setAttribute("target", "_blank");
  $a.setAttribute("rel", "noreferrer noopener");
  $a.setAttribute("id", "external");
  document.getElementById("external") &&
    document.body.removeChild(document.getElementById("external"));
  document.body.appendChild($a);
  $a.click();
  $a.remove();
};
```
然后修改`src/router/index.ts`文件：
```
# 页面内新增
import NProgress from "@/utils/progress";
import store from "@/store";
import { storageSession, storageLocal } from "@/utils/storage";
import { openLink } from "@/utils/link";
import { split, uniqBy } from "lodash-es";


// 路由白名单
const whiteList = ["/login"];

router.beforeEach((to, _from, next) => {
  const userInfo = storageSession.getItem("userInfo");
  NProgress.start();
  const externalLink = to?.redirectedFrom?.fullPath;
  // @ts-ignore
  if (!externalLink) to.meta.title ? (document.title = to.meta.title) : "";
  if (userInfo&&userInfo?.accessToken) {
    if (_from?.name) {
      // 如果路由包含http 则是超链接 反之是普通路由
      if (externalLink && externalLink.includes("http")) {
        openLink(`http${split(externalLink, "http")[1]}`);
        NProgress.done();
      } else {
        next();
      }
    } else {
      // 刷新
      if (store.state.routes.wholeRoutes.length === 0){
        initRouter().then((router: Router) => {
          router.push(to.path);
        });
      }
      next();
    }
  } else {
    if (to.path !== "/login") {
      if (whiteList.indexOf(to.path) !== -1) {
        next();
      } else {
        next({ path: "/login" });
      }
    } else {
      next();
    }
  }
});

router.afterEach(() => {
  NProgress.done();
});
```
这里引入了一个新的插件，需要先进行安装：
```
yarn add lodash-es
```
此时整条链路就算完全打通了，运行项目，可以发现路由已经自动跳转到登录页，说明导航守卫已经起作用了，这里是假设我们通过`token`的方式验证登录状态，先从缓存中获取登录时我们存储在缓存中的`token`，如果`token`存在，说明已经登录，否则需要跳转登录页，或者其他在白名单内的页面（如果你浏览器打开的页面是白名单内的页面的话）

`token`存在的情况下，如果`from.name`存在，需判断路由是普通路由，还是超链接，超链接需要直接跳转，而不用走路由流程，用的是超链接跳转的工具函数；而如果`form.name`不存在，并且路由数据状态管理中的`wholeRoutes`数组为空，说明是首次或是刷新操作进入，此时需要先加载所有路由，这里开始就连上了之前已经写好的初始化路由方法，方法中先是调用了引入的用`axios`封装的请求方法，而请求方法的接口是通过`mock`数据添加的，动态数据获取后需要和静态路由整合，而动态路由和静态路由的整合，我们是写在`vuex`的模块`routes`里的，所以这里需要对初始化路由方法进行修改：

```
// 初始化路由
export const initRouter = () => {
  return new Promise(resolve => {
    getAsyncRoutes().then((data:any) => {
      console.log(data,"动态路由");
      if (data.length === 0) {
        store.dispatch('routes/asyncActionRoutes',data);
      } else {
        addAsyncRoutes(data,true)?.map((v: any) => {
          // 防止重复添加路由
          if (router.options.routes.findIndex(value => value.path === v.path) !== -1) {
            return;
          } else {
            // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            router.options.routes.push(v);
            // 最终路由进行升序
            ascending(router.options.routes);
            router.addRoute(v.name, v);
            store.dispatch('routes/asyncActionRoutes',data);
          }
          resolve(router);
        });
      }
      router.addRoute({path: "/:pathMatch(.*)",redirect: "/error/404"});
    });
  });
};
```
这一步完成，关于`vue-router`,`vuex`,`axios`,`mock`整体就已经串联起来了，运行项目，能正常展示登录页，说明暂时无太大的问题，接下来，需要修改一个登录页，方便接下来框架的搭建

## 登录逻辑优化

#### src/views/login/index.vue
```
<script setup lang="ts">
import { infoType } from "./type";
import { useRouter } from "vue-router";
import { reactive } from "vue";
import { getLogin } from "@/api/user";
import { storageSession } from "@/utils/storage";
import { warnMessage, successMessage } from "@/utils/message";
import info, { ContextProps } from "./components/default/index.vue";

const router = useRouter();
const contextInfo: ContextProps = reactive({
  userName: "",
  passWord: "",
});
const toPage = (info: Object): void => {
  storageSession.setItem("userInfo", info);
  router.push("/");
};
// 登录
const onLogin = async () => {
  let { userName, passWord } = contextInfo;
  let { code, info,data, accessToken }: infoType = await getLogin({
    username: userName,
    password: passWord,
  });
  const userInfo:any = data;
  userInfo.accessToken = accessToken
  code === 0
    ? successMessage(info) &&
      toPage(userInfo)
    : warnMessage(info);
};

</script>

<template>
  <div class="login">
    <info
      :ruleForm="contextInfo"
      @on-behavior="onLogin"
    />
  </div>
</template>
```
#### src/views/login/components/default/index.vue
```
<script setup lang="ts">
import { ref, PropType, getCurrentInstance, toRef } from "vue";
import { useRouter } from "vue-router";
import { initRouter } from "@/router";
import { storageSession } from "@/utils/storage";

export interface ContextProps {
  userName: string;
  passWord: string;
}

const props = defineProps({
  ruleForm: {
    type: Object as PropType<ContextProps>
  }
});

const emit = defineEmits<{
  (e: "onBehavior", evt: Object): void;
}>();

const instance = getCurrentInstance();

const model = toRef(props, "ruleForm");

const router = useRouter();

const rules = ref<any>({
  userName: [{ required: true, message: "请输入用户名", trigger: "blur" }],
  passWord: [
    { required: true, message: "请输入密码", trigger: "blur" },
    { min: 6, message: "密码长度必须不小于6位", trigger: "blur" }
  ],
});

// 点击登录
const onBehavior = (evt: Object): void => {
  // @ts-expect-error
  instance.refs.ruleForm.validate((valid: boolean) => {
    if (valid) {
      emit("onBehavior", evt);
    } else {
      return false;
    }
  });
};

// 表单重置
const resetForm = (): void => {
  // @ts-expect-error
  instance.refs.ruleForm.resetFields();
};

const noSecret = (): void => {
  storageSession.setItem("userInfo", {
    accessToken: "eyJhbGciOiJIUzUxMiJ9"
  });
  initRouter().then(() => {});
  router.push("/");
};
</script>

<template>
  <div class="info">
    <el-form :model="model" :rules="rules" ref="ruleForm" class="rule-form">
      <el-form-item prop="userName">
        <el-input
          clearable
          v-model="model.userName"
          placeholder="请输入用户名"
          prefix-icon="el-icon-user"
        ></el-input>
      </el-form-item>
      <el-form-item prop="passWord">
        <el-input
          clearable
          type="password"
          show-password
          v-model="model.passWord"
          placeholder="请输入密码"
          prefix-icon="el-icon-lock"
        ></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click.prevent="onBehavior">登录</el-button>
        <el-button @click="resetForm">重置</el-button>
      </el-form-item>
      <span title="测试用户 直接登录" class="secret" @click="noSecret">免密登录</span>
    </el-form>
  </div>
</template>

<style lang="scss" scoped>
.info {
  width: 30vw;
  height: 48vh;
  background: url("@/assets/login.png") no-repeat center;
  background-size: cover;
  position: absolute;
  border-radius: 20px;
  right: 100px;
  top: 30vh;
  display: flex;
  justify-content: center;
  align-items: center;
  @media screen and (max-width: 750px) {
    width: 88vw;
    right: 25px;
    top: 22vh;
  }

  .rule-form {
    width: 80%;

    .verify {
      position: absolute;
      margin: -10px 0 0 -120px;

      &:hover {
        cursor: pointer;
      }
    }

    .tips {
      color: #409eff;
      float: right;

      &:hover {
        cursor: pointer;
      }
    }
  }

  .secret {
    color: #409eff;

    &:hover {
      cursor: pointer;
    }
  }
}
</style>
```
#### src/views/login/type.ts
```
export type infoType = {
  code?: number;
  info?: string;
  data?: object;
  accessToken?: string;
};
```
#### 封装消息提示框工具函数
```
# src/utils/message/index.ts
import { ElMessage } from "element-plus";

// 消息
const Message = (message: string): any => {
  return ElMessage({
    showClose: true,
    message
  });
};

// 成功
const successMessage = (message: string): any => {
  return ElMessage({
    showClose: true,
    message,
    type: "success"
  });
};

// 警告
const warnMessage = (message: string): any => {
  return ElMessage({
    showClose: true,
    message,
    type: "warning"
  });
};

// 失败
const errorMessage = (message: string): any => {
  return ElMessage({
    showClose: true,
    message,
    type: "error"
  });
};

export { Message, successMessage, warnMessage, errorMessage };
```
#### src/style/public.scss
```
# 新增
.login{
  width: 100vw;
  height: 100vh;
  overflow-x: hidden;
  background: url("../assets/login.jpg") no-repeat center;
  background-size: cover;
}
```
#### 路由实例中增加滚动行为
```
// 创建路由实例
export const router: Router = createRouter({
    history: createWebHistory(),
    routes: filterTree(ascending(constantRoutes)).concat(...remainingRouter),
    scrollBehavior(to, from, savedPosition) {
      return new Promise(resolve => {
        if (savedPosition) {
          return savedPosition;
        } else {
          if (from.meta.saveSrollTop) {
            const top: number =
              document.documentElement.scrollTop || document.body.scrollTop;
            resolve({ left: 0, top });
          }
        }
      });
    }
});
```
#### 登录接口
```
# src/api/user.ts
import { http } from "../utils/http";

// 登录
export const getLogin = (data: object) => {
  return http.request("post", "/login", data);
};

```
此时再运行项目，登录页已经做了美化，点击免密登录，也可以正常进入首页，这里主要是免密登录时缓存了一个静态的`token`，这样在导航守卫中`token`验证通过，就可以正常跳转页面了

# 框架优化完善

## 侧边导航优化
完成了登录、导航守卫的逻辑后，接下来需要将已获取的路由转化为侧边导航进行展示

#### 导航动态化
```
# src/layout/components/vertical.vue
<script setup lang="ts">
import Logo from "./logo/index.vue"
import SidebarItem from "./sidebarItem/index.vue";
import { useStore } from 'vuex'
import { computed } from "vue";
import { useRoute } from "vue-router";
const route = useRoute();
const store = useStore()
const menuList = store.state.routes.wholeRoutes
const activeMenu = computed((): string => {
  const { meta, path } = route;
  if (meta.activeMenu) {
    // @ts-ignore
    return meta.activeMenu;
  }
  return path;
});

</script>
<template>
  <div class="sidebar-container">
    <Logo />
    <el-scrollbar wrap-class="scrollbar-wrapper">
      <el-menu
        :default-active="activeMenu"
        unique-opened
        router
        :collapse-transition="false"
        mode="vertical"
        class="outer-most"
      >
        <sidebar-item
          v-for="route in menuList"
          :key="route.path"
          :item="route"
          class="outer-most"
          :base-path="route.path"
        />
      </el-menu>
    </el-scrollbar>
  </div>
</template>

<style lang="scss" scoped>
</style>
```
修改`src/layout/components/sidebarItem/index.vue`文件：
```
<script setup lang="ts">
import path from 'path'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";

const props = defineProps({
  item: {
    type: Object as PropType<childrenType>
  },
  isNest: {
    type: Boolean,
    default: false
  },
  basePath: {
    type: String,
    default: ""
  }
});

const onlyOneChild: childrenType = ref(null);
// 存放菜单是否存在showTooltip属性标识
const hoverMenuMap = new WeakMap();
// 存储菜单文本dom元素
const menuTextRef = ref(null);

function hoverMenu(key) {
  // 如果当前菜单showTooltip属性已存在，退出计算
  if (hoverMenuMap.get(key)) return;

  nextTick(() => {
    // 如果文本内容的整体宽度大于其可视宽度，则文本溢出
    menuTextRef.value?.scrollWidth > menuTextRef.value?.clientWidth
      ? Object.assign(key, {
          showTooltip: true
        })
      : Object.assign(key, {
          showTooltip: false
        });
    hoverMenuMap.set(key, true);
  });
}

function hasOneShowingChild(
  children: childrenType[] = [],
  parent: childrenType
) {
  const showingChildren = children.filter((item: any) => {
    onlyOneChild.value = item;
    return true;
  });

  if (showingChildren.length === 1) {
    return true;
  }

  if (showingChildren.length === 0) {
    onlyOneChild.value = { ...parent, path: "", noShowingChildren: true };
    return true;
  }
  return false;
}

function resolvePath(routePath) {
  const httpReg = /^http(s?):\/\//;
  if (httpReg.test(routePath)) {
    return props.basePath + "/" + routePath;
  } else {
    return path.resolve(props.basePath, routePath);
  }
}
</script>

<template>
  <template v-if="hasOneShowingChild(props.item.children, props.item)&&(!onlyOneChild.children || onlyOneChild.noShowingChildren)">
    <el-menu-item
      :index="resolvePath(onlyOneChild.path)"
      :class="{ 'submenu-title-noDropdown': !isNest }"
      style="display: flex; align-items: center"
    >
      <template #title>
        <div
          :style="{
            width: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            overflow: 'hidden'
          }"
        >
          <el-tooltip
            placement="top"
            :offset="-10"
            :disabled="!onlyOneChild.showTooltip"
          >
            <template #content>
              {{ onlyOneChild.meta.title }}
            </template>
            <span
              ref="menuTextRef"
              :style="{
                width: '125px',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
              }"
              @mouseover="hoverMenu(onlyOneChild)"
            >
              {{ onlyOneChild.meta.title }}
            </span>
          </el-tooltip>
          <svg-icon
            v-if="props.item.meta.extraIcon"
            :icon-class="`${props.item.meta.extraIcon.name}`"
          />
        </div>
      </template>
    </el-menu-item>
  </template>

  <el-sub-menu v-else ref="subMenu" :index="resolvePath(props.item.path)" popper-append-to-body>
    <template #title>
      <el-tooltip
        placement="top"
        :offset="-10"
        :disabled="!props.item.showTooltip"
      >
        <template #content>
          {{ props.item.meta.title }}
        </template>
        <div
          ref="menuTextRef"
          :style="{
            display: 'inline-block',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }"
          @mouseover="hoverMenu(props.item)"
        >
          <span style="overflow: hidden; text-overflow: ellipsis">
            {{ props.item.meta.title }}
          </span>
        </div>
      </el-tooltip>
      <svg-icon
        v-if="props.item.meta.extraIcon"
        :icon-class="`${props.item.meta.extraIcon.name}`"
      />
    </template>
    <sidebar-item
      v-for="child in props.item.children"
      :key="child.path"
      :is-nest="true"
      :item="child"
      :base-path="resolvePath(child.path)"
      class="nest-menu"
    />
  </el-sub-menu>
</template>
```
创建`layout`模块的类型声明文件：
```
# src/layout/types.ts
export type childrenType = {
  path?: string;
  noShowingChildren?: boolean;
  children?: childrenType[];
  value: unknown;
  meta?: {
    icon?: string;
    title?: string;
    extraIcon?: {
      svg?: boolean;
      name?: string;
    };
  };
  showTooltip?: boolean;
};
```
如果此时运行项目，会有报错：
```
Module "path" has been externalized for browser compatibility and cannot be accessed in client code.
```
这里需要安装新的插件：
```
yarn add path-browserify
```
同时修改`src/layout/components/sidebarItem/index.vue`文件：
```
# 将
import path from 'path'
修改为：
import path from 'path-browserify'
```
此时再运行项目，就不会出现上面的报错了，不过此时控制台依然会有警告，且侧边导航展示的子导航并没有被渲染出来：
```
Failed to resolve component: sidebar-item
```
这里需要继续修改`src/layout/components/sidebarItem/index.vue`文件：
```
<script lang="ts">
export default {
  name: "sidebar-item"
};
</script>
<script setup lang="ts">
import path from 'path-browserify'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";
...
```
用一个不带`setup`语法糖的`script`标签，声明该组件的`name`，这样组件内部调用自身就不会再有警告，此时运行项目，侧边导航已经能够正常展示，子导航也都能正常渲染了

#### 导航图标优化
前文中已经集成了图标组件，这里需要先将各路由中的图标按图标组件的格式修改正确，并在`meta`中加一个字段，用来判断是第三方组件式图标，还是常规图标
```
# src/router/modules/demo.ts  使用svg文件形式的图标
import Layout from "@/layout/index.vue";

const router = {
  path: "/demo",
  name: "demoLayout",
  component: Layout,
  meta: {
    icon:'sgn-demo',
    title: "demo小样",
    isComponent:false,
    showLink: true,
    sort:2
  },
  children: [
    {
      path: "/demo",
      name: "demo",
      component: () => import("@/views/demo/index.vue"),
      meta: {
        title: "demo小样",
        showLink: true,
        sort:2,
        extraIcon:{
          svg:true,
          name:'sgn-new'
        }
      }
    }
  ]
};
export default router;

# src/router/modules/error.ts  使用element-plus按需引入的图标，为第三方组件式图标
import Layout from "@/layout/index.vue";

const errorRouter = {
  path: "/error",
  name: "error",
  component: Layout,
  redirect: "/error/401",
  meta: {
    icon: "Position",
    isComponent:true,
    title: "错误页面",
    showLink: true,
    sort: 7
  },
  children: [
    {
      path: "/error/401",
      name: "401",
      component: () => import("@/views/error/401/index.vue"),
      meta: {
        title: "401",
        showLink: true
      }
    },
    {
      path: "/error/404",
      name: "404",
      component: () => import("@/views/error/404/index.vue"),
      meta: {
        title: "404",
        showLink: true
      }
    }
  ]
};

export default errorRouter;

# src/router/modules/home.ts  使用font awesome的图标，为第三方组件式图标
import Layout from "@/layout/index.vue";

const router = {
  path: "/",
  name: "layout",
  component: Layout,
  meta: {
    icon:'fa-house-damage',
    isComponent:true,
    showLink: true,
    sort:1
  },
  children: [
    {
      path: "/",
      name: "home",
      component: () => import("@/views/home/index.vue"),
      meta: {
        title: "首页",
        showLink: true,
        sort:1
      }
    }
  ]
};

export default router;

# src/router/modules/nested.ts  使用iconfont的图标，为iconfont.js中引入的svg图标
import Layout from "@/layout/index.vue";

const router = {
  path: "/nested",
  name: "Nested",
  component: Layout,
  redirect: "/nested/menu1/menu1-1",
  meta:{
    icon:'icon-xitongshiti',
    isComponent:false,
    sort:3,
    showLink:true,
    title:"嵌套路由"
  },
  children:[
    {
      path: "/nested/menu1",
      component: () => import("@/views/nested/menu1/index.vue"),
      name: "Menu1",
      redirect: "/nested/menu1/menu1-1",
      meta:{
        sort:1,
        showLink:true,
        title:"嵌套路由1"
      },
      children: [
          {
              path: "/nested/menu1/menu1-1",
              component: () => import("@/views/nested/menu1/menu1-1/index.vue"),
              name: "Menu1-1",
              meta:{
                sort:1,
                showLink:true,
                title:"嵌套路由1-1"
              },
          },
          {
              path: "/nested/menu1/menu1-2",
              component: () => import("@/views/nested/menu1/menu1-2/index.vue"),
              name: "Menu1-2",
              redirect: "/nested/menu1/menu1-2/menu1-2-1",
              meta:{
                sort:2,
                showLink:true,
                title:"嵌套路由1-2"
              },
              children: [
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-1",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-1/index.vue"),
                      name: "Menu1-2-1",
                      meta:{
                        sort:1,
                        showLink:true,
                        title:"嵌套路由1-2-1"
                      },
                  },
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-2",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-2/index.vue"),
                      name: "Menu1-2-2",
                      meta:{
                        sort:2,
                        showLink:true,
                        title:"嵌套路由1-2-2"
                      },
                  }
              ]
          },
          {
              path: "/nested/menu1/menu1-3",
              component: () => import("@/views/nested/menu1/menu1-3/index.vue"),
              name: "Menu1-3",
              meta:{
                sort:3,
                showLink:true,
                title:"嵌套路由1-3"
              },
          }
      ]
    },
    {
        path: "/nested/menu2",
        name: "Menu2",
        component: () => import("@/views/nested/menu2/index.vue"),
        meta:{
          sort:2,
          showLink:true,
          title:"嵌套路由2"
        },
    }
  ]
};

export default router;

# mock/asyncRoutes.ts 为下载的svg文件图标
const systemRouter = {
  path: "/system",
  name: "system",
  redirect: "/system/user",
  meta: {
    icon: "sgn-menu-system",
    isComponent:false,
    title: "设置",
    showLink: true,
    sort: 10
  },
  children: [
    {
      path: "/system/user",
      name: "user",
      meta: {
        title: "个人中心",
        showLink: true,
        sort: 1
      }
    },
    {
      path: "/system/dict",
      name: "dict",
      meta: {
        title: "字典表",
        showLink: true,
        sort: 2
      }
    }
  ]
};
```
以上一级导航的图标都已修改，并增加了`isComponent`字段，来判断是否需要使用第三方组件的形式引入图标，`demo`文件的二级路由加了其他图标字段，用来加载一些特殊需求的图标，接下来修改`src/layout/components/sidebarItem/index.vue`文件：
```
<script lang="ts">
export default {
  name: "sidebar-item"
};
</script>
<script setup lang="ts">
import path from 'path-browserify'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";
import Icon from "@/components/Icon/src/Icon.vue";
import { findIconReg } from "@/components/Icon";

const props = defineProps({
  item: {
    type: Object as PropType<childrenType>
  },
  isNest: {
    type: Boolean,
    default: false
  },
  basePath: {
    type: String,
    default: ""
  }
});

const onlyOneChild: childrenType = ref(null);
// 存放菜单是否存在showTooltip属性标识
const hoverMenuMap = new WeakMap();
// 存储菜单文本dom元素
const menuTextRef = ref(null);

function hoverMenu(key) {
  // 如果当前菜单showTooltip属性已存在，退出计算
  if (hoverMenuMap.get(key)) return;

  nextTick(() => {
    // 如果文本内容的整体宽度大于其可视宽度，则文本溢出
    menuTextRef.value?.scrollWidth > menuTextRef.value?.clientWidth
      ? Object.assign(key, {
          showTooltip: true
        })
      : Object.assign(key, {
          showTooltip: false
        });
    hoverMenuMap.set(key, true);
  });
}

function hasOneShowingChild(children: childrenType[] = [],parent: childrenType) {
  const showingChildren = children.filter((item: any) => {
    onlyOneChild.value = item;
    return true;
  });

  if (showingChildren.length === 1) {
    return true;
  }

  if (showingChildren.length === 0) {
    onlyOneChild.value = { ...parent, path: "", noShowingChildren: true };
    return true;
  }
  return false;
}

function resolvePath(routePath) {
  const httpReg = /^http(s?):\/\//;
  if (httpReg.test(routePath)) {
    return props.basePath + "/" + routePath;
  } else {
    return path.resolve(props.basePath, routePath);
  }
}
</script>

<template>
  <template v-if="hasOneShowingChild(props.item.children, props.item)&&(!onlyOneChild.children || onlyOneChild.noShowingChildren)">
    <el-menu-item
      :index="resolvePath(onlyOneChild.path)"
      :class="{ 'submenu-title-noDropdown': !isNest }"
      style="display: flex; align-items: center"
    >
      <el-icon v-show="props.item.meta.icon">
        <component v-if="onlyOneChild.meta.isComponent||props.item.meta.isComponent" :is="findIconReg(onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon))"></component>
        <Icon v-else :svg="true" :content="`${onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon)}`" />
      </el-icon>
      <template #title>
        <div
          :style="{
            width: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            overflow: 'hidden'
          }"
        >
          <el-tooltip
            placement="top"
            :offset="-10"
            :disabled="!onlyOneChild.showTooltip"
          >
            <template #content>
              {{ onlyOneChild.meta.title }}
            </template>
            <span
              ref="menuTextRef"
              :style="{
                width: '125px',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
              }"
              @mouseover="hoverMenu(onlyOneChild)"
            >
              {{ onlyOneChild.meta.title }}
            </span>
          </el-tooltip>
          <Icon
            v-if="onlyOneChild.meta.extraIcon"
            :svg="onlyOneChild.meta.extraIcon.svg ? true : false"
            :content="`${onlyOneChild.meta.extraIcon.name}`"
          />
        </div>
      </template>
    </el-menu-item>
  </template>

  <el-sub-menu v-else ref="subMenu" :index="resolvePath(props.item.path)" popper-append-to-body>
    <template #title>
      <el-icon v-show="props.item.meta.icon">
        <component v-if="props.item.meta.isComponent" :is="findIconReg(props.item.meta && props.item.meta.icon)"></component>
        <Icon v-else :svg="true" :content="`${props.item.meta && props.item.meta.icon}`" />
      </el-icon>
      <el-tooltip
        placement="top"
        :offset="-10"
        :disabled="!props.item.showTooltip"
      >
        <template #content>
          {{ props.item.meta.title }}
        </template>
        <div
          ref="menuTextRef"
          :style="{
            display: 'inline-block',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }"
          @mouseover="hoverMenu(props.item)"
        >
          <span style="overflow: hidden; text-overflow: ellipsis">
            {{ props.item.meta.title }}
          </span>
        </div>
      </el-tooltip>
      <Icon
        v-if="props.item.meta.extraIcon"
        :svg="props.item.meta.extraIcon.svg ? true : false"
        :content="`${props.item.meta.extraIcon.name}`"
      />
    </template>
    <sidebar-item
      v-for="child in props.item.children"
      :key="child.path"
      :is-nest="true"
      :item="child"
      :base-path="resolvePath(child.path)"
      class="nest-menu"
    />
  </el-sub-menu>
</template>
```
此时运行项目，所有图标都能正常显示了，特殊需求图标也能正常显示，那么此时，侧边导航的功能就算完成了，再做一下样式优化，以及展开折叠功能即可

#### 导航样式优化
```
# src/style/-layout.scss
# .sidebar-container内新增：
.el-icon{
    display: inline-block;
    width: 18px;
    height: 18px;
    line-height:0;
    font-size:0;
    vertical-align: middle;
    margin-right: 5px;
    &.tag-icon{
      margin-right:-6px;
      width: 24px;
      height: 24px;
      svg{
        font-size: 24px!important;
      }
    }
    svg{
      width: 1em !important;
      height: 1em !important;
      font-size: 18px !important;
      text-align: center;
      vertical-align: middle;
      line-height: 0;
      display: inline-block;
    }
  }
```
`src/layout/components/sidebarItem/index.vue`文件修改：
```
<script lang="ts">
export default {
  name: "sidebar-item"
};
</script>
<script setup lang="ts">
import path from 'path-browserify'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";
import Icon from "@/components/Icon/src/Icon.vue";
import { findIconReg } from "@/components/Icon";

const props = defineProps({
  item: {
    type: Object as PropType<childrenType>
  },
  isNest: {
    type: Boolean,
    default: false
  },
  basePath: {
    type: String,
    default: ""
  }
});

const onlyOneChild: childrenType = ref(null);
// 存放菜单是否存在showTooltip属性标识
const hoverMenuMap = new WeakMap();
// 存储菜单文本dom元素
const menuTextRef = ref(null);

function hoverMenu(key) {
  // 如果当前菜单showTooltip属性已存在，退出计算
  if (hoverMenuMap.get(key)) return;

  nextTick(() => {
    // 如果文本内容的整体宽度大于其可视宽度，则文本溢出
    menuTextRef.value?.scrollWidth > menuTextRef.value?.clientWidth
      ? Object.assign(key, {
          showTooltip: true
        })
      : Object.assign(key, {
          showTooltip: false
        });
    hoverMenuMap.set(key, true);
  });
}

function hasOneShowingChild(children: childrenType[] = [],parent: childrenType) {
  const showingChildren = children.filter((item: any) => {
    onlyOneChild.value = item;
    return true;
  });

  if (showingChildren.length === 1) {
    return true;
  }

  if (showingChildren.length === 0) {
    onlyOneChild.value = { ...parent, path: "", noShowingChildren: true };
    return true;
  }
  return false;
}

function resolvePath(routePath) {
  const httpReg = /^http(s?):\/\//;
  if (httpReg.test(routePath)) {
    return props.basePath + "/" + routePath;
  } else {
    return path.resolve(props.basePath, routePath);
  }
}
</script>

<template>
  <template v-if="hasOneShowingChild(props.item.children, props.item)&&(!onlyOneChild.children || onlyOneChild.noShowingChildren)">
    <el-menu-item
      :index="resolvePath(onlyOneChild.path)"
      :class="{ 'submenu-title-noDropdown': !isNest }"
      style="display: flex; align-items: center"
    >
      <el-icon v-show="props.item.meta.icon">
        <component v-if="onlyOneChild.meta.isComponent||props.item.meta.isComponent" :is="findIconReg(onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon))"></component>
        <Icon v-else :svg="true" :content="`${onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon)}`" />
      </el-icon>
      <template #title>
        <div
          :style="{
            width: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            overflow: 'hidden'
          }"
        >
          <el-tooltip
            placement="top"
            :offset="-10"
            :disabled="!onlyOneChild.showTooltip"
          >
            <template #content>
              {{ onlyOneChild.meta.title }}
            </template>
            <span
              ref="menuTextRef"
              :style="{
                width: '125px',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
              }"
              @mouseover="hoverMenu(onlyOneChild)"
            >
              {{ onlyOneChild.meta.title }}
            </span>
          </el-tooltip>
        </div>
        <el-icon class="tag-icon" v-if="onlyOneChild.meta.extraIcon">
        <Icon
          :svg="onlyOneChild.meta.extraIcon.svg ? true : false"
          :content="`${onlyOneChild.meta.extraIcon.name}`"
        /></el-icon>
      </template>
    </el-menu-item>
  </template>

  <el-sub-menu v-else ref="subMenu" :index="resolvePath(props.item.path)" popper-append-to-body>
    <template #title>
      <el-icon v-show="props.item.meta.icon">
        <component v-if="props.item.meta.isComponent" :is="findIconReg(props.item.meta && props.item.meta.icon)"></component>
        <Icon v-else :svg="true" :content="`${props.item.meta && props.item.meta.icon}`" />
      </el-icon>
      <el-tooltip
        placement="top"
        :offset="-10"
        :disabled="!props.item.showTooltip"
      >
        <template #content>
          {{ props.item.meta.title }}
        </template>
        <div
          ref="menuTextRef"
          :style="{
            display: 'inline-block',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }"
          @mouseover="hoverMenu(props.item)"
        >
          <span style="overflow: hidden; text-overflow: ellipsis">
            {{ props.item.meta.title }}
          </span>
        </div>
      </el-tooltip>
      <el-icon class="tag-icon" v-if="props.item.meta.extraIcon"><Icon
        :svg="props.item.meta.extraIcon.svg ? true : false"
        :content="`${props.item.meta.extraIcon.name}`"
      /></el-icon>
    </template>
    <sidebar-item
      v-for="child in props.item.children"
      :key="child.path"
      :is-nest="true"
      :item="child"
      :base-path="resolvePath(child.path)"
      class="nest-menu"
    />
  </el-sub-menu>
</template>
```
此时样式优化已完成，不过这里需要注意的是，由于使用的`svg`图标有多种版式，所以，图标的大小上看上去会有明显的不同，在真正的项目开发中，应尽量统一图标版式，统一图标比例，那样会更美观一些，不过这就是UI的事儿了~

#### 侧边导航展开折叠功能