# 开发环境须知
本系列技术栈要求的开发环境(vscode作为编辑器)：
1. node 12.0以上，本人安装：14.18.1长期稳定维护版（需求win8以上系统）
2. vue3.x的语法插件：Vue language Features(volar)，vue2.x时使用的是`vetur`，这两者是有冲突的，使用`vue3.x`开发，就必须禁用`vetur`插件，使用`volar`
3. TypeScript Vue Plugin (Volar) 用于 `TypeScript` 服务器的 `Vue` 插件

# 安装
终端定位到项目需要放在的路径上执行以下命令：
```
yarn create vite
```
根据命令提示步骤完成项目基础信息配置：
1. 确定项目名（最好是英文名，项目名同时也是项目根目录文件夹名）
2. 选择框架语言（vue）
3. 选择框架语言版本（vue-ts）
以上步骤完成后，vscode打开项目，执行以下两步命令：
```
# 安装依赖
yarn
# 本地运行项目
yarn dev
```
能正常显示`vue`界面，则配置成功

# 配置alias别名
先把别名配置好，方便接下来的文件引用：
```
# vite.config.ts
import { resolve } from "path";
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// 路径查找
const pathResolve = (dir: string): string => {
  return resolve(__dirname, dir);
};

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
		alias: {
			'@': pathResolve('src'),
		}
	}
})
```
此时将`src/App.vue`文件中模块以及`logo`的引用路径修改一下，页面正常显示，则配置正确
```
import HelloWorld from './components/HelloWorld.vue'
# 修改为：
import HelloWorld from '@/components/HelloWorld.vue'

<img alt="Vue logo" src="./assets/logo.png" />
# 修改为：
<img alt="Vue logo" src="@/assets/logo.png" />
```

# 集成SCSS预处理器
这里需要说一点的是，如果你用习惯了`node-sass`，那么这里会发现，你安装`node-sass`，使用`node-sass`做预处理器会报错:
```
[vite] Internal server error: Preprocessor dependency "sass" not found. Did you install it?
```
暂不清楚是node14.x的原因、还是vue3.x的原因、抑或是vite的原因，总之在这个技术栈内，**人家直接用的是sass，安装node-sass是没用的~**，所以这里执行以下安装包命令：
```
yarn add sass sass-loader -D
```
安装完成运行项目，来测试一下scss是否能正常运行，在`src`文件夹下新建`style`文件夹，并在其内新建`index.scss`以及`-settings.scss`文件：
```
# src/style/-settings.scss
@charset "UTF-8";
$pink: #ff00ff;
$red: red;

# src/style/index.scss
@charset "UTF-8";
@import "./-settings.scss";
.demo{
  color: $red;
}
```
在`main.ts`文件中引入样式表文件
```
# src/main.ts
import { createApp } from 'vue'
import App from '@/App.vue'

import '@/style/index.scss';

createApp(App).mount('#app')
```
修改`App.vue`文件，在`template`内添加内容：
```
# src/App.vue template标签内
<h1 class="demo">红色标题</h1>
```
浏览器查看标题已变成红色，则引用正常

vite配置全局scss变量，官方给的方法如下：
```
# vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'


export default defineConfig({
  plugins: [
    vue(),
  ],
  css: {
    preprocessorOptions: {
      scss: {
        additionalData: `@import "@/style/-settings.scss";`,
      },
    },
  },
});
```
在页面中使用全局变量，修改`src/components/HelloWorld.vue`的页面内样式：
```
# src/components/HelloWorld.vue
<style  scoped lang="scss">
a {color:$pink}
...
</style>
```
此时运行项目，会发现报错了，研究报错会发现，报错所指向的是在`main.ts`中引入的`index.scss`文件，在网上搜了一圈并没有找到具体解决办法，报错中有一句`Plugin:vite:css`，猜测是配置全局后，其他地方的scss文件引入都会报错，将`main.ts`中引入的`index.scss`删除，再运行项目，发现全局变量已经起作用，但同时h1标题的样式已丢失，暂未找到具体原因，公共样式还是需要在`main.ts`中引入的，目前的做法是不在`vite`中配置全局变量，若要在某个页面使用变量，则在具体页面的`style`标签内`@import``scss`变量配置文件：
```
# src/components/HelloWorld.vue
<style  scoped lang="scss">
@import "@/style/-settings.scss";
a {color:$pink}
...
</style>
```
此时再运行项目，就不会再报错了~，且页面内和`main.ts`中引入的样式都能起作用

# 集成element-plus

```
yarn add element-plus
```
### 引入方式-整体引入
```
# main.ts
import { createApp } from 'vue'
import App from '@/App.vue'

// elementPlus完整引入
import ElementPlus from 'element-plus';
import 'element-plus/dist/index.css'

import "@/style/index.scss"

const app = createApp(App)

app.use(ElementPlus)
app.mount('#app')

# src/App.vue template标签内新增：
<el-button type="primary">Primary</el-button>
```
此时项目运行，按钮有样式能正常展示，则整体引入完成

### 引入方式-按需引入
安装按需加载依赖包，这个插件会自动加载组件与其对应的样式
```
yarn add unplugin-element-plus -D
```
在`src`文件夹下新建`plugins/element-plus/index.ts`文件结构，并在文件内加入以下内容：
```
import { App } from "vue";
import {
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElForm,
  ElFormItem,
  ElLoading,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
	ElInfiniteScroll,
  ElMessage,
  ElMessageBox,
  ElNotification,
} from "element-plus";

const components = [
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElForm,
  ElFormItem,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem
];

const plugins = [ElInfiniteScroll, ElLoading, ElMessage, ElMessageBox, ElNotification];

export function useElementPlus(app: App) {
    components.forEach((component: any) => {
        app.component(component.name, component);
    });
    plugins.forEach(plugin => {
        app.use(plugin);
    });
}

```
修改`vite.config.ts`文件：
```
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import ElementPlus from "unplugin-element-plus/vite";
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
		vue(),
		ElementPlus({}),
	],
  resolve: {
		alias: {
			'@': resolve('src'),
		}
	}
})
```
修改`main.ts`文件：
```
import { createApp } from 'vue'
import App from '@/App.vue'

import { useElementPlus } from "@/plugins/element-plus"; // element-plus

import "@/style/index.scss"

const app = createApp(App)

app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')
```
此时`TS`可能会提示这样的错误：
> 找不到模块“@/plugins/element-plus”或其相应的类型声明

修改`tsconfig.json`文件：
```
{
  "compilerOptions": {
    "target": "esnext",
    "useDefineForClassFields": true,
    "module": "esnext",
    "moduleResolution": "node",
    "strict": true,
    "jsx": "preserve",
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "lib": ["esnext", "dom"],
    // 新增
    "baseUrl": ".", 
    "paths":{
      "@/*": ["src/*"],
    },
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"]
}
```
此时运行项目，按钮依然可以正常显示，表示按需加载已配置完成。

修改`main.ts`中，全局配置的`size`值，页面内按钮大小也会相应做出改变

### element-plus 控制台无穷多的组件警告信息消除
使用`element-plus`的某些组件时，控制台会报很多警告信息，这是比较烦人的事情，比如在页面内引入日期选择插件：
```
# src/App.vue
# script标签内新增
import { ref } from 'vue'
const value1 = ref("")
# template标签内新增
<el-date-picker v-model="value1" type="date" placeholder="Pick a day"></el-date-picker>
</template>

```

**此时打开F12查看，会发现控制台有无穷多的警告信息，这个比较影响开发，其原因是element-plus的版本问题**

解决办法也简单，下载指定版本即可

```
yarn remove element-plus
yarn add element-plus@1.1.0-beta.24
```
此时再运行项目，控制台的那些烦人警告就都消失不见了~

# 集成vue-router

```
yarn add vue-router@next
```
在`src`文件夹下新建`router`文件夹，并在`router`文件夹下新建`index.ts`文件，写入一段测试路由信息
```
# src/router/index.ts
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
    {
        path: '/demo',
        component: () => import("../views/demo/index.vue")
    },
    {
        path: '/',
        component: () => import("../views/home/index.vue")
    },
]

const router = createRouter({
    history: createWebHistory(),
    routes
})

export default router
```
此时测试路由信息已完成导出，接着去`main.ts`文件中将导出的路由挂载到app中：
```
# main.ts
import { createApp } from 'vue'
import router from './router'
import App from './App.vue'
import { useElementPlus } from "@/plugins/element-plus"; // element-plus
import '@/style/index.scss';
const app = createApp(App)

app.use(router)
app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')

```
修改`App.vue`文件：
```
# App.vue
<template>
  <router-view />
</template>
```
此时基础的路由就以创建完成，接下来创建路由对应的页面组件,`src`文件夹下新建`views`文件来集中管理具体页面文件
```
// src/views/demo/index.vue
<template>
    <div>demo</div>
</template>

// src/views/home/index.vue
<script setup lang="ts">
// This starter template is using Vue 3 <script setup> SFCs
// Check out https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup
import HelloWorld from '@/components/HelloWorld.vue'
</script>

<template>
  <h1 class="demo">红色标题</h1>
  <img alt="Vue logo" src="@/assets/logo.png" />
  <HelloWorld msg="Hello Vue 3 + TypeScript + Vite" />
  <el-button type="primary">Primary</el-button>
</template>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```
此时启动项目，打开项目即可进入首页，访问`/demo`路径，即可进入`demo`页面


# 项目结构与框架样式完善
为方便接下来其他功能的接入，先做一些结构调整，以及框架样式的完善
```
src
├── api                                     # 存放api接口文件
├── assets                                  # 静态资源
│    └── icons                              # 图标资源
│          └── svg                          # svg图标资源
├── components                              # 通用组件
├── layout                                  # 框架UI层
│    ├── components                         # 框架组件
│    │    ├── breadCrumb                    # 面包屑
│    │    │    └── index.vue                
│    │    ├── hamBurger.vue                 # 折叠菜单按钮
│    │    │    └── index.vue             
│    │    ├── logo.vue                      # logo
│    │    │    └── index.vue             
│    │    ├── sidebarItem.vue               # 子菜单
│    │    │    └── index.vue             
│    │    ├── appMain.vue                   # 页面内容主体
│    │    ├── navbar.vue                    # header部分
│    │    ├── tags.vue                      # tag标签菜单
│    │    └── vertical.vue                  # 侧边菜单
│    └── index.vue                          # 框架主页面
├── plugins                                 # 项目插件
│    └── element-plus                       # 插件文件夹
│         └── index.ts                      # 插件内容
├── router                                  # 路由
│    ├── modules                            # 路由分模块
│    │    ├── demo.ts                      # 子模块路由
│    │    ├── home.ts                       # 子模块路由
│    │    └── nested.ts                     # 子模块路由
│    ├── index.ts                           # 路由主文件
│    └── remaining.ts                       # 其他路由
├── store                                   # 状态管理
│    ├── modules                            # 状态管理分模块
│    │    ├── app.ts                        # 子模块状态管理
│    │    └── permission.ts                 # 子模块状态管理
│    └── index.ts                           # 状态管理主文件
├── style                                   # 样式文件夹
│    ├── -layout.scss
│    ├── -public.scss
│    ├── -settings.scss
│    └── index.scss
├── utils                                   # 工具函数文件夹
├── views                                   # 视图页面文件夹
│    ├── demo
│    │    └── index.vue
│    ├── home
│    │    └── index.vue
│    └── nested
│         ├── menu1
│         │    ├── menu1-1           
│         │    │    └── index.vue  
│         │    ├── menu1-2 
│         │    │    ├── menu1-2-1  
│         │    │    │    └── index.vue  
│         │    │    ├── menu1-2-2  
│         │    │    │    └── index.vue  
│         │    │    └── index.vue     
│         │    ├── menu1-3   
│         │    │    └── index.vue           
│         │    └── index.vue             
│         ├── menu2
│         │    └── index.vue            
│         └── index.vue  
├── App.vue
├── env.d.ts
└── main.ts
```
以上是初步的项目文件结构，可以先将对应文件结构都先创建出来，新增的文件内容如下（未展示的这一步都还是空文件）：

#### src/layout/index.vue
```
# src/layout/index.vue
<script setup lang="ts">
import navbar from "./components/navbar.vue";
import appMain from "./components/appMain.vue";
import Vertical from "./components/vertical.vue";
import tags from "./components/tags.vue";
</script>

<template>
  <div class="app-wrapper">
    <!-- 侧边导航栏 -->
    <Vertical />
    <div class="main-container">
      <div class="fixed-header">
        <!-- 顶部导航栏 -->
        <navbar />
        <!-- 标签栏 -->
        <tags />
      </div>
      <!-- 主体内容 -->
      <app-main />
    </div>
  </div>
</template>

<style lang="scss" scoped>

</style>
```
#### src/layout/components/logo/index.vue
```
<script setup lang="ts">
const title = "viteDemo"
</script>

<template>
  <div class="sidebar-logo">
    <router-link :title="title" class="logo-link" to="/">
      <img class="logo-img" src="@/assets/logo.png" />
      <h1 class="logo-title">{{ title }}</h1>
    </router-link>
  </div>
</template>

<style lang="scss" scoped>
.sidebar-logo {
  position: relative;
  width: 100%;
  height: 48px;
  overflow: hidden;
  .logo-link {
    height: 100%;
    padding-left: 10px;
    text-align: left;
    .logo-img{
      width: 32px;
      height: 32px;
      display: inline-block;
      margin: 8px;
      vertical-align: top;
    }
    .logo-title {
      display: inline-block;
      margin: 0;
      color: #1890ff;
      font-weight: 600;
      font-size: 20px;
      line-height: 24px;
      margin-top: 12px;
      vertical-align: top;
    }
  }
}
</style>
```
#### src/layout/components/appMain.vue
```
<script setup lang="ts">

</script>

<template>
  <div class="app-main">
    <el-scrollbar>
      <router-view></router-view>
    </el-scrollbar>
  </div>
</template>

<style lang="scss" scoped>
.app-main {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow-x: hidden;
}
</style>
```
#### src/layout/components/navbar.vue
```
<script setup lang="ts">

</script>

<template>
  <div class="navbar"></div>
</template>

<style lang="scss" scoped>
.navbar {
  width: 100%;
  height: 48px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
}

</style>
```
#### src/layout/components/tags.vue
```
<script setup lang="ts">

</script>

<template>
  <div class="tags-view">
    <el-scrollbar wrap-class="scrollbar-wrapper" class="scroll-container"></el-scrollbar>
  </div>
</template>

<style lang="scss" scoped>
.tags-view {
  width: 100%;
  font-size: 14px;
  height: 38px;
  display: flex;
  box-shadow: 0 0 1px #888;
  .scroll-container {
    padding: 5px 0;
    white-space: nowrap;
    position: relative;
    width: 100%;
    background: #fff;
    .scrollbar-wrapper {
      position: absolute;
      height: 40px;
      overflow-x: hidden !important;
    }
  }
}
</style>
```
#### src/layout/components/vertical.vue
```
<script lang="ts">
import Logo from "./logo/index.vue"
import { defineComponent, ref } from 'vue'
import {
  Location,
  Document,
  Menu as IconMenu,
  Setting,
} from '@element-plus/icons'

export default defineComponent({
  components: {
    Location,
    Document,
    Setting,
    IconMenu,
    Logo,
  },
  setup() {
    const isCollapse = ref(false)
    const handleOpen = (key:any, keyPath:any) => {
      console.log(key, keyPath)
    }
    const handleClose = (key:any, keyPath:any) => {
      console.log(key, keyPath)
    }
    return {
      isCollapse,
      handleOpen,
      handleClose,
    }
  },
  methods:{
    routerLink(e:string){
      console.log(e);
      this.$router.push({path:e});
    }
  }
})
</script>

<template>
  <div class="sidebar-container">
    <Logo />
    <el-scrollbar wrap-class="scrollbar-wrapper">
      <el-menu
        default-active="1"
        class="el-menu-vertical-demo"
        :collapse="isCollapse"
        @open="handleOpen"
        @close="handleClose"
      >
        <el-menu-item class="submenu-title-noDropdown" index="1" v-on:click="routerLink('/')">
          <el-icon><icon-menu /></el-icon>
          <template #title>home</template>
        </el-menu-item>
        <el-sub-menu index="2">
          <template #title>
            <el-icon><location /></el-icon>
            <span>Navigator One</span>
          </template>
          <el-sub-menu index="2-1">
            <template #title>
              <span>Navigator two</span>
            </template>
            <el-menu-item index="2-1-1" v-on:click="routerLink('/nested/menu1/menu1-1')">item one</el-menu-item>
            <el-sub-menu index="2-1-2">
              <template #title>
                <span>Navigator three</span>
              </template>
              <el-menu-item index="2-1-2-1" v-on:click="routerLink('/nested/menu1/menu1-2/menu1-2-1')">item one</el-menu-item>
              <el-menu-item index="2-1-2-2" v-on:click="routerLink('/nested/menu1/menu1-2/menu1-2-2')">item two</el-menu-item>
            </el-sub-menu>
            <el-menu-item index="2-1-3" v-on:click="routerLink('/nested/menu1/menu1-3')">item three</el-menu-item>
          </el-sub-menu>
          <el-menu-item index="2-2" v-on:click="routerLink('/nested/menu2')">item four</el-menu-item>
        </el-sub-menu>
        <el-menu-item class="submenu-title-noDropdown" index="3" v-on:click="routerLink('/demo')">
          <el-icon><setting /></el-icon>
          <template #title>demo</template>
        </el-menu-item>
      </el-menu>
    </el-scrollbar>
  </div>
</template>
<style lang="scss" scoped>
</style>

```
#### src/router/index.ts
```
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

const routes: RouteRecordRaw[] = [
    {
        path: '/',
        component: () => import("@/layout/index.vue"),
        children:[
            {
                path: '/',
                component: () => import("@/views/home/index.vue")
            },
            {
                path: '/demo',
                component: () => import("@/views/demo/index.vue")
            },
            {
                path: "/nested",
                component: () => import("@/views/nested/index.vue"),
                redirect: "/nested/menu1/menu1-1",
                name: "Nested",
                children: [
                    {
                        path: "/nested/menu1",
                        component: () => import("@/views/nested/menu1/index.vue"),
                        name: "Menu1",
                        redirect: "/nested/menu1/menu1-1",
                        children: [
                            {
                                path: "/nested/menu1/menu1-1",
                                component: () => import("@/views/nested/menu1/menu1-1/index.vue"),
                                name: "Menu1-1",
                            },
                            {
                                path: "/nested/menu1/menu1-2",
                                component: () => import("@/views/nested/menu1/menu1-2/index.vue"),
                                name: "Menu1-2",
                                redirect: "/nested/menu1/menu1-2/menu1-2-1",
                                children: [
                                    {
                                        path: "/nested/menu1/menu1-2/menu1-2-1",
                                        component: () => import("@/views/nested/menu1/menu1-2/menu1-2-1/index.vue"),
                                        name: "Menu1-2-1",
                                    },
                                    {
                                        path: "/nested/menu1/menu1-2/menu1-2-2",
                                        component: () => import("@/views/nested/menu1/menu1-2/menu1-2-2/index.vue"),
                                        name: "Menu1-2-2",
                                    }
                                ]
                            },
                            {
                                path: "/nested/menu1/menu1-3",
                                component: () => import("@/views/nested/menu1/menu1-3/index.vue"),
                                name: "Menu1-3",
                            }
                        ]
                    },
                    {
                        path: "/nested/menu2",
                        name: "Menu2",
                        component: () => import("@/views/nested/menu2/index.vue"),
                    }
                ]
            }
        ]
    },
]

const router = createRouter({
    history: createWebHistory(),
    routes
})

export default router
```
#### src/style/-layout.scss
```
.app-wrapper{
  position: relative;
  width: 100%;
  height: 100%;
  @include clearfix;
}
$subMenuActiveText: #f4f4f5;
$menuBg: #1b2a47;
$menuHover: #2a395b;
$subMenuBg: #1f2d3d;
$subMenuHover: #001528;
$sideBarWidth: 210px;
$navTextColor: #fff;
$menuText: #7a80b4;
$menuActiveText: #7a80b4;

.main-container {
  min-height: 100%;
  padding-left:  $sideBarWidth;
  transition: padding-left .28s;
  position: relative;
}

.fixed-header {
  position: fixed;
  left: $sideBarWidth;
  top: 0;
  right: 0;
  z-index: 1000;
  transition: left 0.28s;
}

.el-popper.is-light {
  border: none !important;
}

.sidebar-container {
  transition: width 0.28s;
  width: $sideBarWidth;
  background-color: $menuBg;
  height: 100%;
  position: fixed;
  font-size: 0;
  top: 0;
  bottom: 0;
  left: 0;
  z-index: 1001;
  overflow: hidden;
  box-shadow: 0 0 1px #888;

  .scrollbar-wrapper {
    overflow-x: hidden !important;
  }

  .horizontal-collapse-transition {
    transition: 0s width ease-in-out, 0s padding-left ease-in-out,
      0s padding-right ease-in-out;
  }

  .el-scrollbar__bar.is-vertical {
    right: 0;
  }

  .el-scrollbar {
    height: 100%;
  }

  &.has-logo {
    .el-scrollbar {
      height: calc(100% - 50px);
    }
  }

  .is-horizontal {
    display: none;
  }

  a {
    display: inline-block;
    width: 100%;
    overflow: hidden;
  }

  .el-menu {
    border: none;
    height: 100%;
    background-color: transparent !important;
  }
  .el-sub-menu__icon-arrow{
    position: absolute !important;
  }
  .el-menu-item,
  .el-sub-menu__title {
    color: $menuText;
  }

  // menu hover
  .submenu-title-noDropdown,
  .el-sub-menu__title {
    // background: $menuBg;

    &:hover {
      background-color: $menuHover !important;
    }
  }

  .is-active > .el-sub-menu__title,
  .is-active.submenu-title-noDropdown {
    color: $subMenuActiveText !important;

    i {
      color: $subMenuActiveText !important;
    }
  }

  .is-active {
    transition: color 0.3s;
    color: $subMenuActiveText !important;
  }

  .el-menu .el-menu--inline .el-sub-menu__title,
  & .el-sub-menu .el-menu-item {
    font-size: 12px;
    min-width: $sideBarWidth !important;
    background-color: $subMenuBg !important;

    &:hover {
      background-color: $subMenuHover !important;
    }
  }
}
.el-scrollbar__wrap {
  overflow: auto;
  height: 100%;
}

.fixed-header + .app-main {
  padding-top: 86px;
}
```
#### src/style/-public.scss
```

body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  font-family: Helvetica Neue, Helvetica, PingFang SC, Hiragino Sans GB,
    Microsoft YaHei, Arial, sans-serif;
}

html {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

label {
  font-weight: 700;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

a:focus,
a:active {
  outline: none;
}

a,
a:focus,
a:hover {
  cursor: pointer;
  color: inherit;
  text-decoration: none;
}

div:focus {
  outline: none;
}

ul {
  margin: 0;
  padding: 0;
  list-style: none;
}

.clearfix {
  &::after {
    visibility: hidden;
    display: block;
    font-size: 0;
    content: " ";
    clear: both;
    height: 0;
  }
}
```
#### src/style/-settings.scss
```
@charset "UTF-8";
$pink: #ff00ff;
$red: red;

@mixin clearfix {
  &::after {
    content: "";
    display: table;
    clear: both;
  }
}
```
#### src/style/index.scss
```
@charset "UTF-8";
@import "./-settings.scss";
@import "./-public.scss";
@import "./-layout.scss";
.demo{
  color: $red;
}
```
#### src/views/demo/index.vue
```
<template>
    <div>demo</div>
</template>
```
#### src/views/home/index.vue
```
<script setup lang="ts">
// This starter template is using Vue 3 <script setup> SFCs
// Check out https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup
import HelloWorld from '@/components/HelloWorld.vue'
</script>

<template>
  <div class="home">
    <h1 class="demo">红色标题</h1>
    <img alt="Vue logo" src="@/assets/logo.png" />
    <HelloWorld msg="Hello Vue 3 + TypeScript + Vite" />
    <el-button type="primary">Primary</el-button>
  </div>
</template>

<style>
.home{
  text-align: center;
}
</style>
```
#### src/views/nested
```
# src/views/nested/index.vue、src/views/nested/menu1/index.vue、src/views/nested/menu1-2/index.vue,
<template>
  <router-view />
</template>

# src/views/nested/menu1/menu1-1/index.vue
<template>
    <div>menu1-1</div>
</template>

# src/views/nested/menu1/menu1-2-1/index.vue
<template>
    <div>menu1-2-1</div>
</template>

# src/views/nested/menu1/menu1-2-2/index.vue
<template>
    <div>menu1-2-2</div>
</template>

# src/views/nested/menu1/menu1-3/index.vue
<template>
    <div>menu1-3</div>
</template>

# src/views/nested/menu2/index.vue
<template>
    <div>menu2</div>
</template>
```
#### src/views/error
```
# src/views/error/401/index.vue
<script setup lang="ts">

</script>
<template>
  <h2>401</h2>
</template>

<style>
</style>

# src/views/error/404/index.vue
<script setup lang="ts">

</script>
<template>
  <h2>404</h2>
</template>

<style>
</style>
```
以上内容充实后，整个项目的框架就算初步出来了，接下来是功能完善、细节处理，运行项目，导航能正常链接到各个对应页面，则一切配置都已生效

# 集成vuex
```
yarn add vuex@next
```
先做一个简单的示例，累加功能，在`helloworld`组件中按钮点击自增，在`home`页面内展示

```
# src/store/index.ts
import { createStore } from 'vuex'

const store = createStore({
    state() {
        return {
            count: 0
        }
    },
    mutations: {
        // 累加功能
        increment(state) {
            state.count++
        }
    }
})
export default store
```
此时会发现`state`报类型错误，修改如下：
```
import { createStore } from 'vuex'

//定义一个state的接口
export interface State {
    count: number
}

const store = createStore<State>({
    state() {
        return {
            count: 0
        }
    },
    mutations: {
        // 累加功能
        increment(state) {
            state.count++
        }
    }
})
export default store
```

然后修改`main.ts`文件：
```
# src/main.ts

import { createApp } from 'vue'
import router from './router'
import store from './store'
import App from './App.vue'
import { useElementPlus } from "@/plugins/element-plus"; // element-plus
import '@/style/index.scss';
const app = createApp(App)

app.use(router)
app.use(store)
app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')
```

在`helloWorld.vue`文件中增加点击按钮，以及点击事件
```
# src/components/HelloWorld.vue

<script setup lang="ts">
import { ref } from 'vue'
defineProps<{ msg: string }>()
const count = ref(0);

import { useStore } from "vuex";
const store = useStore();
function handleClickIncrement() {
  store.commit("increment");
}
</script>


# template 内新增如下代码

<el-button type="primary" @click="handleClickIncrement">累加自增</el-button>
```
然后在`demo`页面内获取`vuex`中的内容
```
# src/views/demo/index.vue
<script setup lang="ts">
import { useStore } from 'vuex'
const store = useStore()
const count = store.state.count
</script>
<template>
  <h2>vuex中的count：{{count}}</h2>
</template>

<style>
</style>
```
此时先去demo页面，默认`count`是`0`，再去首页点击累加自增按钮，然后再回到`demo`页面，此时`demo`页面内的`count`就实现了累加功能，由`0`变为`1`，实现了`vuex`的数据共享

# 进阶版vue-router配置
接下来需要完善一下路由配置，此前只是简单的将路由写在`src/router/index.ts`文件内，但当项目越来越大，以及有动态路由、静态路由、路由权限、路由白名单问题时，这么写显然是不可能的了

## 静态路由模块化引入

动态路由这一块先不管，先把静态路由处理一下，这里把静态路由按根节点菜单进行模块化拆分：

#### src/router/modules/demo.ts
```
import Layout from "@/layout/index.vue";

const router = {
  path: "/demo",
  name: "demoLayout",
  component: Layout,
  meta: {
    title: "demo小样",
    showLink: true,
    sort:2
  },
  children: [
    {
      path: "/demo",
      name: "demo",
      component: () => import("@/views/demo/index.vue"),
      meta: {
        title: "demo小样",
        showLink: true,
        sort:1
      }
    }
  ]
};

export default router;
```
#### src/router/modules/error.ts
```
import Layout from "@/layout/index.vue";

const errorRouter = {
  path: "/error",
  name: "error",
  component: Layout,
  redirect: "/error/401",
  meta: {
    icon: "el-icon-position",
    title: "错误页面",
    showLink: true,
    sort: 7
  },
  children: [
    {
      path: "/error/401",
      name: "401",
      component: () => import("@/views/error/401/index.vue"),
      meta: {
        title: "401",
        showLink: true
      }
    },
    {
      path: "/error/404",
      name: "404",
      component: () => import("@/views/error/404/index.vue"),
      meta: {
        title: "404",
        showLink: true
      }
    }
  ]
};

export default errorRouter;
```
#### src/router/modules/home.ts
```
# src/router/modules/home.ts
import Layout from "@/layout/index.vue";

const router = {
  path: "/",
  name: "layout",
  component: Layout,
  meta: {
    showLink: true,
    sort:1
  },
  children: [
    {
      path: "/",
      name: "home",
      component: () => import("@/views/home/index.vue"),
      meta: {
        title: "首页",
        showLink: true,
        sort:1
      }
    }
  ]
};

export default router;
```
#### src/router/modules/nested.ts
```
import Layout from "@/layout/index.vue";

const router = {
  path: "/nested",
  name: "Nested",
  component: Layout,
  redirect: "/nested/menu1/menu1-1",
  meta:{
    sort:3,
    showLink:true,
    title:"嵌套路由"
  },
  children:[
    {
      path: "/nested/menu1",
      component: () => import("@/views/nested/menu1/index.vue"),
      name: "Menu1",
      redirect: "/nested/menu1/menu1-1",
      meta:{
        sort:1,
        showLink:true,
        title:"嵌套路由1"
      },
      children: [
          {
              path: "/nested/menu1/menu1-1",
              component: () => import("@/views/nested/menu1/menu1-1/index.vue"),
              name: "Menu1-1",
              meta:{
                sort:1,
                showLink:true,
                title:"嵌套路由1-1"
              },
          },
          {
              path: "/nested/menu1/menu1-2",
              component: () => import("@/views/nested/menu1/menu1-2/index.vue"),
              name: "Menu1-2",
              redirect: "/nested/menu1/menu1-2/menu1-2-1",
              meta:{
                sort:2,
                showLink:true,
                title:"嵌套路由1-2"
              },
              children: [
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-1",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-1/index.vue"),
                      name: "Menu1-2-1",
                      meta:{
                        sort:1,
                        showLink:true,
                        title:"嵌套路由1-2-1"
                      },
                  },
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-2",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-2/index.vue"),
                      name: "Menu1-2-2",
                      meta:{
                        sort:2,
                        showLink:true,
                        title:"嵌套路由1-2-2"
                      },
                  }
              ]
          },
          {
              path: "/nested/menu1/menu1-3",
              component: () => import("@/views/nested/menu1/menu1-3/index.vue"),
              name: "Menu1-3",
              meta:{
                sort:3,
                showLink:true,
                title:"嵌套路由1-3"
              },
          }
      ]
    },
    {
        path: "/nested/menu2",
        name: "Menu2",
        component: () => import("@/views/nested/menu2/index.vue"),
        meta:{
          sort:2,
          showLink:true,
          title:"嵌套路由2"
        },
    }
  ]
};

export default router;
```
####  src/router/index.ts
```
import { Router,RouteComponent,createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

// 静态非白名单路由
const modules = import.meta.glob("./modules/*.ts")
const constantRoutes:RouteRecordRaw[]=[]
for(const path in modules){
	const itemModule = await modules[path]()
	constantRoutes.push(itemModule.default)
}

// 按照路由中meta下的sort等级升序来排序路由
export const ascending = (arr:any) => {
    return arr.sort((a: any, b: any) => {
        return a?.meta?.sort - b?.meta?.sort;
    });
};
// 深拷贝
const objDeepCopy = function (source) {
  var sourceCopy = source instanceof Array ? [] : {};
  for (var item in source) {
      sourceCopy[item] = typeof source[item] === 'object' ? objDeepCopy(source[item]) : source[item];
  }
  return sourceCopy;
}
// 将所有静态路由导出
export const constantRoutesArr: Array<RouteComponent> = ascending(objDeepCopy(constantRoutes))

// 过滤meta中showLink为false的路由
export const filterTree = (data:any) => {
    const newTree = data.filter((v:any) => v.meta.showLink);
    newTree.forEach((v:any) => v.children && (v.children = filterTree(v.children)));
    return newTree;
};


// 创建路由实例
export const router: Router = createRouter({
    history: createWebHistory(),
    routes: filterTree(ascending(constantRoutes)),
});
  
export default router
```
这里将静态路由模块化引入后，需要注意的是，每个模块的第一个层级的`component`都是`layout`，有嵌套的模块第一层级与之前的写法有些小改动，在使用`layout`后，原本的`src/views/nested/index.vue`这个用来做承载的`router-view`就不需要了，该文件可以删除

此时的路由配置已实现静态路由的模块化引入，点击导航栏，各个路由页面能正常跳转，说明配置生效

***这里在导出静态路由处，做了深拷贝处理，是为了防止在后期对路由或者菜单进行处理时，路由数据与菜单数据相互影响，创建路由实例中拷贝了一份静态路由，而导出的静态路由是用来进行菜单展示的数据，两份数据各自进行修改时，不能影响对方，所以在都需要引用同一组数据时，需要进行深拷贝，这里时封装了深拷贝的函数，专门用来深拷贝数组对象类型的复杂数据，也可以直接使用JSON.parse(JSON.stringify(data))进行深拷贝，只是该种方法对于过于复杂的数据进行深拷贝时，可能会出现堆栈溢出，死循环***

## 其他路由引入
除了模块化的静态路由，动态路由外，类似于登录，注册，404，401等页面是不需要权限即可访问的页面，这些页面可以归类为其他路由，静态路由的权限这里暂时先不说，之后动态路由获取的时候一起再说
```
# src/router/remaining.ts
const remainingRouter = [
  {
    path: "/login",
    name: "login",
    component: () => import("@/views/login/index.vue"),
    meta: {
      title: "登录",
      showLink: false,
      sort: 101
    }
  },
];

export default remainingRouter;
```
这里先在路由中配置登录页面的路由，并创建对应的页面
```
# src/views/login/index.vue
<script setup lang="ts">

</script>
<template>
  <h2>登录</h2>
</template>

<style>
</style>
```

接着在`src/router/index.ts`中引入路由
```
import { Router,RouteComponent,createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'

// 静态白名单路由
import remainingRouter from "./remaining";
// 静态非白名单路由
const modules = import.meta.glob("./modules/*.ts")
const constantRoutes:RouteRecordRaw[]=[]
for(const path in modules){
	const itemModule = await modules[path]()
	constantRoutes.push(itemModule.default)
}

// 按照路由中meta下的sort等级升序来排序路由
export const ascending = (arr:any) => {
    return arr.sort((a: any, b: any) => {
        return a?.meta?.sort - b?.meta?.sort;
    });
};
// 深拷贝
const objDeepCopy = function (source) {
  var sourceCopy = source instanceof Array ? [] : {};
  for (var item in source) {
      sourceCopy[item] = typeof source[item] === 'object' ? objDeepCopy(source[item]) : source[item];
  }
  return sourceCopy;
}
// 将所有静态路由导出
export const constantRoutesArr: Array<RouteComponent> = ascending(objDeepCopy(constantRoutes)).concat(...remainingRouter);

// 过滤meta中showLink为false的路由
export const filterTree = (data:any) => {
    const newTree = data.filter((v:any) => v.meta.showLink);
    newTree.forEach((v:any) => v.children && (v.children = filterTree(v.children)));
    return newTree;
};


// 创建路由实例
export const router: Router = createRouter({
    history: createWebHistory(),
    routes: filterTree(ascending(constantRoutes)).concat(...remainingRouter),
});
  
export default router
```
此时运行项目链接访问`login`路径，都能正常访问对应页面，则配置生效



接下来需要引入动态路由，以及将左侧菜单动态的与路由关联起来，在这之前首先要做的是集成`axios`，`svg`等图标组件引入，以及`Mock`引入，`axios`用来之后项目的前后端请求使用，`svg`图标为项目丰富图标使用类型，`Mock`则是为了在无后端接口提供的情况下，能模拟请求后端接口，实现前端独立开发

# 实现 Icon 组件
这里需要注意的是，几乎所有现代框架都在把图标方案从`font`变为`svg`，从前文引入的`element-plus`导航中的图标，可以看到，在`plus`版本，图标已经变为了`svg`，这里把几种图标组件实现都列一下，可自行选择

### 自定义 svg 图标组件
这种适合全项目都只使用`svg`图标，且不使用`element-plus`图标的情况，只需要将下载的`svg`图标放在指定文件夹内即可全局使用，可以先在`src/assets/icons/svg/`文件夹内放一些已下载的`svg`图标，这里可以为所有下载`svg`图标加一个统一的前缀`sgn-`，前缀名可自定义，保证图标名中不会出现前缀名的情况就行

然后在`src/plugins`文件夹下新建`svgBuilder`文件夹，并在其内创建`index.ts`文件：
```
import { readFileSync, readdirSync } from 'fs'

let idPerfix = ''
const svgTitle = /<svg([^>+].*?)>/
const clearHeightWidth = /(width|height)="([^>+].*?)"/g

const hasViewBox = /(viewBox="[^>+].*?")/g

const clearReturn = /(\r)|(\n)/g

function findSvgFile(dir:any):any {
	const svgRes = []
	const dirents = readdirSync(dir, {
		withFileTypes: true
	})
	for (const dirent of dirents) {
		if (dirent.isDirectory()) {
			svgRes.push(...findSvgFile(dir + dirent.name + '/'))
		} else {
			const svg = readFileSync(dir + dirent.name)
				.toString()
				.replace(clearReturn, '')
				.replace(svgTitle, ($1, $2) => {
					// console.log(++i)
					// console.log(dirent.name)
					let width = 0
					let height = 0
					let content = $2.replace(clearHeightWidth, (s1:any, s2:any, s3:any) => {
						if (s2 === 'width') {
							width = s3
						} else if (s2 === 'height') {
							height = s3
						}
						return ''
					})
					if (!hasViewBox.test($2)) {
						content += `viewBox="0 0 ${width} ${height}"`
					}
					return `<symbol id="${idPerfix}-${dirent.name.replace('.svg', '')}" ${content}>`
				})
				.replace('</svg>', '</symbol>')
			svgRes.push(svg)
		}
	}
	return svgRes
}

export const svgBuilder = (path:any, perfix = 'icon') => {
	if (path === '') return
	idPerfix = perfix
	const res = findSvgFile(path)
	// console.log(res.length)
	// const res = []
	return {
		name: 'svg-transform',
		transformIndexHtml(html:any) {
			return html.replace(
				'<body>',
				`
          <body>
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="position: absolute; width: 0; height: 0">
              ${res.join('')}
            </svg>
        `
			)
		}
	}
}
```
修改`vite.config.ts`文件
```
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import ElementPlus from "unplugin-element-plus/vite";
import { svgBuilder } from './src/plugins/svgBuilder/index';
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
		vue(),
		[svgBuilder('./src/assets/icons/svg/')],
		ElementPlus({}),
	],
  resolve: {
		alias: {
			'@': resolve('src'),
		}
	}
})

```
然后在`src/components`文件夹创建`icon`组件:
```
# src/components/SvgIcon/index.vue
<script lang="ts">
import { defineComponent, computed } from 'vue'

interface Props {
	iconClass: string
	className: string
}

export default defineComponent({
	name: 'SvgIcon',
	props: {
		iconClass: {
			type: String,
			required: true
		},
		className: {
			type: String,
			default: () => ''
		}
	},
	setup(props: Props) {
		const iconName = computed((): string => `#icon-${props.iconClass}`)
		const svgClass = computed((): string => {
			if (props.className) {
				return 'svg-icon ' + props.className
			} else {
				return 'svg-icon'
			}
		})

		return {
			iconName,
			svgClass
		}
	}
})
</script>

<template>
	<svg :class="svgClass" aria-hidden="true" v-on="$attrs">
		<use :xlink:href="iconName" />
	</svg>
</template>

<style scoped>
.svg-icon {
	width: 1em;
	height: 1em;
	vertical-align: -0.15em;
	fill: currentColor;
	overflow: hidden;
}
</style>
```
在`src/main.ts`中全局注册该组件
```
import { createApp } from 'vue'
import router from './router'
import store from './store'
import App from './App.vue'
import { useElementPlus } from "@/plugins/element-plus"; // element-plus
import SvgIcon from './components/SvgIcon/index.vue'
import '@/style/index.scss';

const app = createApp(App)

app.component('svg-icon', SvgIcon); // 全局注册svg图标组件
app.use(router)
app.use(store)
app.use(useElementPlus)
// 全局配置
app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
app.mount('#app')
```
在`home`页面使用组件
```
<svg-icon icon-class="sgn-close"></svg-icon>
```
此时home页面预览出现关闭按钮，则代表`svg`图标插件已引入完成，此种方式的`icon`组件主要用于使已下载到项目中的`svg`文件，作为组件注册到全局使用


### 集成式图标组件
该种方式既可使用`svg`图标，也可以使用字体图标库的图标，还能使用下载的字体图标，同时还把`element-plus`的`svg`图标集成在了里面，这里首先需要安装一个插件：
```
yarn add vite-svg-loader -D
```
该插件主要可将`svg`文件作为`vue`组件进行加载，这样就解决了`element-plus`无法动态赋值问题，安装后修改`vite.config.ts`文件：
```
# 文件头部新增：
import svgLoader from "vite-svg-loader"
# plugins中新增：
svgLoader(),
```
#### 集成 font awesome 图标库
```
yarn add font-awesome @fortawesome/vue-fontawesome @fortawesome/free-solid-svg-icons @fortawesome/fontawesome-svg-core
```
修改`tsconfig.json`文件：
```
# compilerOptions 内新增:
"allowJs": false,
"incremental": true,
```
在`src/plugins`中新建`font-awesome`文件夹，并在其内新建`index.ts`文件：
```
/** 兼容fontawesome4和5版本
 * 4版本: www.fontawesome.com.cn/faicons/
 * 5版本：https://fontawesome.com/v5.15/icons?d=gallery&p=2&m=free
 * https://github.com/FortAwesome/vue-fontawesome
 */
 import { App } from "vue";
 import "font-awesome/css/font-awesome.css";
 import { library } from "@fortawesome/fontawesome-svg-core";
 import { fas } from "@fortawesome/free-solid-svg-icons";
 import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";
 
 export function useFontAwesome(app: App) {
   library.add(fas);
   app.component("font-awesome-icon", FontAwesomeIcon);
 }
```
在`src/main.ts`中引入：
```
# 头部引入
import { useFontAwesome } from "@/plugins/font-awesome";
# 全局配置注释行之上进行调用
app.use(useFontAwesome);
```
#### 集成 element-plus 图标
这里需要先下载`element-plus`的图标插件
```
yarn add @element-plus/icons
```
修改`src/plugins/element-plus/index.ts`文件：
```
import { App, Component } from "vue";
import {
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElDatePicker,
  ElForm,
  ElFormItem,
  ElLoading,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
  ElBacktop,
  ElSwitch
} from "element-plus";

import {
  Check,
  Menu,
  HomeFilled,
  SetUp,
  Edit,
  Setting,
  Lollipop,
  Link,
  Position,
  Histogram,
  RefreshRight,
  ArrowDown,
  Close,
  CloseBold
} from "@element-plus/icons";

const components:any[] = [
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElDatePicker,
  ElForm,
  ElFormItem,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
  ElBacktop,
  ElSwitch
];
// icon
export const iconComponents = [
  Check,
  Menu,
  HomeFilled,
  SetUp,
  Edit,
  Setting,
  Lollipop,
  Link,
  Position,
  Histogram,
  RefreshRight,
  ArrowDown,
  Close,
  CloseBold
];
const plugins = [ElLoading];

export function useElementPlus(app: App) {
    components.push(...iconComponents);
    components.forEach((component: Component) => {
        app.component(component.name, component);
    });
    plugins.forEach(plugin => {
        app.use(plugin);
    });
}
```
#### 集成 iconfont 图标
可以先在阿里图标库选一套心仪的图标下载到本地，将下载的文件存放到`src/assets/icons/iconfont`文件夹下，然后在`src/main.ts`文件中直接引入：
```
// 导入字体图标
import "@/assets/icons/iconfont/iconfont.js";
import "@/assets/icons/iconfont/iconfont.css";
```

#### 实现适配组件
以上的`font-awesome`图标、`element-plus`图标、`iconfont`图标、以及之前的`src/assets/icons/svg`下的`svg`图标，现在需要一个组件来满足能使用各种图标的需求，在`src/components`文件夹下新建`Icon`文件夹，其内新建`index.ts`文件、`src`文件夹，`src`文件夹下新建`Icon.vue`文件：
```
# src/components/Icon/index.ts
import { App, defineComponent } from "vue";
import icon from "./src/Icon.vue";
import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";
import { iconComponents } from "@/plugins/element-plus";

export const Icon = Object.assign(icon, {
  install(app: App) {
    app.component(icon.name, icon);
  }
});

export default {
  Icon
};
/**
 * find icon component
 * @param icon icon图标
 * @returns component
 */
export function findIconReg(icon: string) {
  const faReg = /^fa-/;
  if (faReg.test(icon)) {
    return findIcon(icon.split(faReg)[1]);
  } else {
    return findIcon(icon, false);
  }
}
export function findIcon(icon: String, isFa: Boolean = true) {
  if (isFa) {
    return defineComponent({
      name: "FaIcon",
      data() {
        return { icon: icon };
      },
      components: { FontAwesomeIcon },
      template: `<font-awesome-icon :icon="icon" />`
    });
  } else {
    const components = iconComponents.filter(
      component => component.name === icon
    );
    if (components.length > 0) {
      return components[0];
    } else {
      return null;
    }
  }
}
```
`src/components/Icon/src/Icon.vue`:
```
<script lang="ts">
export default {
  name: "Icon"
};
</script>

<script setup lang="ts">
import { ref, computed } from "vue";

const props = defineProps({
  content: {
    type: String,
    default: ""
  },
  size: {
    type: Number,
    default: 18
  },
  width: {
    type: Number,
    default: 20
  },
  height: {
    type: Number,
    default: 20
  },
  color: {
    type: String,
    default: ""
  },
  svg: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits<{
  (e: "click"): void;
}>();

let text = ref("");

let className = computed(() => {
  if (props.content.indexOf("fa-") > -1) {
    return props.content.indexOf("fa ") === 0
      ? props.content
      : ["fa", props.content];
  } else if (props.content.indexOf("el-icon-") > -1) {
    return props.content;
  } else if (props.content.indexOf("iconfont-") > -1) {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    return ["iconfont", "icon-"+props.content.split('iconfont-')[1]];
  } else {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    text.value = props.content;
    return "";
  }
});

let iconStyle = computed(() => {
  return (
    "font-size: " +
    props.size +
    "px; color: " +
    props.color +
    "; width: " +
    props.width +
    "px; height: " +
    props.height +
    "px; font-style: normal;"
  );
});

const clickHandle = () => {
  emit("click");
};
</script>

<template>
  <i
    v-if="!props.svg"
    :class="className"
    :style="iconStyle"
    v-html="text"
    @click="clickHandle"
  ></i>
  <svg
    class="icon-svg"
    v-if="props.svg"
    aria-hidden="true"
    :style="iconStyle"
    @click="clickHandle"
  >
    <use :xlink:href="`#${props.content}`" />
  </svg>
</template>
```
组件创建完成，对每种图标情况都做一下测试
##### 使用 font awesome 的 svg 图标
```
# src/app.vue script标签内
import { findIconReg } from "@/components/Icon";
# template标签内
<el-icon><component :is="findIconReg('fa-address-book')"></component></el-icon>
```
此时运行项目会发现图标并没有显示出来，控制台报了一套警告：
```
[Vue warn]: Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js"
```
这时需要修改`vite.config.ts`文件，在别名配置中加上`vue`的别名配置
```
resolve: {
  alias: {
    '@': resolve('src'),
    'vue':'vue/dist/vue.esm-bundler.js'
  }
},
```
此时再运行项目，图标就能正常显示了
##### 使用 font awesome 的字体图标
```
# src/app.vue script标签内
import Icon from "@/components/Icon/src/Icon.vue";
# template标签内
<Icon :content="'fa-address-book'"/>
```
运行项目，可以看到图标能正常显示，以上是两种引用方式，`font awesome`的`svg`图标因为是属于第三方组件，所以这里需要使用`component`去渲染第三方组件

##### 使用 iconfont 的 `svg` 图标
`iconfont`的识别前缀可在`src/assets/icons/iconfont/iconfont.json`文件中查看，`css_prefix_text`为图标的识别前缀，想使用哪个图标，找到该图标的`font_class`即可
```
# src/app.vue
# template标签内
<Icon :svg="true" :content="'icon-star'"/>
```
运行项目可发现图标已正常显示，查看源码可发现已经使用的是`svg`图标，在`src/asstes/icons/iconfont/iconfont.js`中保存有所有图标的`svg`代码，而该文件在`src/main.ts`文件中已引入

##### 使用 iconfont 的字体图标
看`src/components/Icon/src/Icon.vue`文件中代码，`className`的定义中，如果`content`中存在`iconfont-`，即判断为`iconfont`图标，并返回`iconfont icon-`具体图标，两个类名，使其符合`iconfont`字体图标的引用方式，所以这里要引用`iconfont`的字体图标如下：
```
# src/app.vue
# template标签内
<Icon :content="'iconfont-star'"/>
```
此时运行项目，就可以看到该图标已正常显示，源码中查看，可看到为字体图标的引入方式

##### 使用 element-plus 的 svg 图标
这里`element-plus`的`svg`图标已经独立出`element-plus`项目，上面配置时，已下载`@element-plus/icons`，且在`src/plugins/element-plus/index.ts`文件中，已按需加载了一些常用图标，加载时已将图标名作为组件名进行了注册，所以这里`element-plus`的`svg`图标的引入方式与`font awesome`的`svg`图标引入方式相同：
```
# src/app.vue
# template标签内
<el-icon><component :is="findIconReg('HomeFilled')"></component></el-icon>
```
此时运行项目，图标能正常显示
##### 使用 element-plus 的字体图标
此时项目依然可以使用`element-plus`的字体图标
```
# src/app.vue
# template标签内
<Icon :content="'el-icon-user'"/>
```
运行项目，图标也依然能正常显示，此时基本就涵盖了所有的图标引用方式
***第一种方式全局注册组件使用svg文件作为图标的方式，在有了集成式图标组件后，可不再使用，在iconfont.js文件已经有了svg图标的使用，两者都有较高的定制性***

不过这里也可以将该全局组件也集成到图标组件内
```
# src/components/Icon/src/Icon.vue
<script lang="ts">
export default {
  name: "Icon"
};
</script>

<script setup lang="ts">
import { ref, computed } from "vue";

const props = defineProps({
  content: {
    type: String,
    default: ""
  },
  size: {
    type: Number,
    default: 18
  },
  width: {
    type: Number,
    default: 20
  },
  height: {
    type: Number,
    default: 20
  },
  color: {
    type: String,
    default: ""
  },
  svg: {
    type: Boolean,
    default: false
  }
});

const emit = defineEmits<{
  (e: "click"): void;
}>();

let text = ref("");

let className = computed(() => {
  if (props.content.indexOf("fa-") > -1) {
    return props.content.indexOf("fa ") === 0
      ? props.content
      : ["fa", props.content];
  } else if (props.content.indexOf("el-icon-") > -1) {
    return props.content;
  } else if (props.content.indexOf("iconfont-") > -1) {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    return ["iconfont", "icon-"+props.content.split('iconfont-')[1]];
  }else {
    // eslint-disable-next-line vue/no-side-effects-in-computed-properties
    text.value = props.content;
    return "";
  }
});

let iconStyle = computed(() => {
  return (
    "font-size: " +
    props.size +
    "px; color: " +
    props.color +
    "; width: " +
    props.width +
    "px; height: " +
    props.height +
    "px; font-style: normal;"
  );
});

const clickHandle = () => {
  emit("click");
};
</script>

<template>
  <i
    v-if="!props.svg&&props.content.indexOf('sgn-')===-1"
    :class="className"
    :style="iconStyle"
    v-html="text"
    @click="clickHandle"
  ></i>
  <svg
    class="icon-svg"
    v-if="props.svg&&props.content.indexOf('sgn-')===-1"
    aria-hidden="true"
    :style="iconStyle"
    @click="clickHandle"
  >
    <use :xlink:href="`#${props.content}`" />
  </svg>
  <svg-icon v-if="props.svg&&props.content.indexOf('sgn-')>-1" :icon-class="props.content"></svg-icon>
</template>
```
如此的话，我们只需使用`Icon`组件，就能实现所有形式的图标引入
```
# src/app.vue
# template标签内
<Icon :svg="true" :content="'sgn-close'"/>
```
这里给这种调用`svg`文件一个特定识别标志`sgn-`，在下载`svg`文件命名时，都统一加上该前缀，这样在后期动态引入时该使用组件中的哪种形式就有了判断的标准

到此图标组件就算彻底完工了，总结一下：字体图标的引入使用的是`Icon`组件，且不传`svg`这个参数（因`svg`这个参数默认是`false`）,`svg`图标的引入有两种形式，`Icon`组件的形式多用于有具体的`svg`文件代码，如`iconfont.js`里的`svg`代码，以及下载本地`svg`文件的形式，而`component`形式则用于`svg`图标本身已经是第三方组件，需要使用组件调用的形式，如`font awesome`和`element-plus icon`

那么在动态引入时依据什么去判断使用哪种？字体图标这里只是为了兼容加上的，因为有字体图标的存在，那肯定也有对应的`svg`图标存在，所以这里只说下`svg`图标动态引入时，如何进行判断，根据动态获取到的图标字段中的前缀去判断，如果有`sng-`前缀以及`icon-`前缀，则使用`Icon`组件，且必传`svg`参数，值为`true`，其他情况使用`component`的`is`绑定形式


# 集成 axios
```
yarn add axios
# 请求调用进度条
yarn add nprogress
yarn add @types/nprogress -D
```
这里使用别人封装好的`axios`，以及`nprogress`
```
# src/utils/http/config.ts
import { AxiosRequestConfig } from "axios";
import { excludeProps } from "./utils";
/**
 * 默认配置
 */
export const defaultConfig: AxiosRequestConfig = {
  baseURL: "",
  //10秒超时
  timeout: 10000,
  headers: {
    Accept: "application/json, text/plain, */*",
    "Content-Type": "application/json",
    "X-Requested-With": "XMLHttpRequest"
  }
};

export function genConfig(config?: AxiosRequestConfig): AxiosRequestConfig {
  if (!config) {
    return defaultConfig;
  }

  const { headers } = config;
  if (headers && typeof headers === "object") {
    defaultConfig.headers = {
      ...defaultConfig.headers,
      ...headers
    };
  }
  return { ...excludeProps(config!, "headers"), ...defaultConfig };
}

export const METHODS = ["post", "get", "put", "delete", "option", "patch"];

```
此文件内的默认配置部分，需根据个人前后端项目需求进行配置，`baseURL`配置为个人后端接口

```
# src/utils/http/core.ts
import Axios, {
  AxiosRequestConfig,
  CancelTokenStatic,
  AxiosInstance
} from "axios";

import NProgress from "../progress";

import { genConfig } from "./config";

import { transformConfigByMethod } from "./utils";

import {
  cancelTokenType,
  RequestMethods,
  EnclosureHttpRequestConfig,
  EnclosureHttpResoponse,
  EnclosureHttpError
} from "./types.d";

class EnclosureHttp {
  constructor() {
    this.httpInterceptorsRequest();
    this.httpInterceptorsResponse();
  }
  // 初始化配置对象
  private static initConfig: EnclosureHttpRequestConfig = {};

  // 保存当前Axios实例对象
  private static axiosInstance: AxiosInstance = Axios.create(genConfig());

  // 保存 EnclosureHttp实例
  private static EnclosureHttpInstance: EnclosureHttp;

  // axios取消对象
  private CancelToken: CancelTokenStatic = Axios.CancelToken;

  // 取消的凭证数组
  private sourceTokenList: Array<cancelTokenType> = [];

  // 记录当前这一次cancelToken的key
  private currentCancelTokenKey = "";

  private beforeRequestCallback: EnclosureHttpRequestConfig["beforeRequestCallback"] =
    undefined;

  private beforeResponseCallback: EnclosureHttpRequestConfig["beforeResponseCallback"] =
    undefined;

  public get cancelTokenList(): Array<cancelTokenType> {
    return this.sourceTokenList;
  }

  // eslint-disable-next-line class-methods-use-this
  public set cancelTokenList(value) {
    throw new Error("cancelTokenList不允许赋值");
  }

  /**
   * @description 私有构造不允许实例化
   * @returns void 0
   */
  // constructor() {}

  /**
   * @description 生成唯一取消key
   * @param config axios配置
   * @returns string
   */
  // eslint-disable-next-line class-methods-use-this
  private static genUniqueKey(config: EnclosureHttpRequestConfig): string {
    return `${config.url}--${JSON.stringify(config.data)}`;
  }

  /**
   * @description 取消重复请求
   * @returns void 0
   */
  private cancelRepeatRequest(): void {
    const temp: { [key: string]: boolean } = {};

    this.sourceTokenList = this.sourceTokenList.reduce<Array<cancelTokenType>>(
      (res: Array<cancelTokenType>, cancelToken: cancelTokenType) => {
        const { cancelKey, cancelExecutor } = cancelToken;
        if (!temp[cancelKey]) {
          temp[cancelKey] = true;
          res.push(cancelToken);
        } else {
          cancelExecutor();
        }
        return res;
      },
      []
    );
  }

  /**
   * @description 删除指定的CancelToken
   * @returns void 0
   */
  private deleteCancelTokenByCancelKey(cancelKey: string): void {
    this.sourceTokenList =
      this.sourceTokenList.length < 1
        ? this.sourceTokenList.filter(
            cancelToken => cancelToken.cancelKey !== cancelKey
          )
        : [];
  }

  /**
   * @description 拦截请求
   * @returns void 0
   */

  private httpInterceptorsRequest(): void {
    EnclosureHttp.axiosInstance.interceptors.request.use(
      (config: EnclosureHttpRequestConfig) => {
        const $config = config;
        NProgress.start(); // 每次切换页面时，调用进度条
        const cancelKey = EnclosureHttp.genUniqueKey($config);
        $config.cancelToken = new this.CancelToken(
          (cancelExecutor: (cancel: any) => void) => {
            this.sourceTokenList.push({ cancelKey, cancelExecutor });
          }
        );
        this.cancelRepeatRequest();
        this.currentCancelTokenKey = cancelKey;
        // 优先判断post/get等方法是否传入回掉，否则执行初始化设置等回掉
        if (typeof this.beforeRequestCallback === "function") {
          this.beforeRequestCallback($config);
          this.beforeRequestCallback = undefined;
          return $config;
        }
        if (EnclosureHttp.initConfig.beforeRequestCallback) {
          EnclosureHttp.initConfig.beforeRequestCallback($config);
          return $config;
        }
        return $config;
      },
      error => {
        return Promise.reject(error);
      }
    );
  }

  /**
   * @description 清空当前cancelTokenList
   * @returns void 0
   */
  public clearCancelTokenList(): void {
    this.sourceTokenList.length = 0;
  }

  /**
   * @description 拦截响应
   * @returns void 0
   */
  private httpInterceptorsResponse(): void {
    const instance = EnclosureHttp.axiosInstance;
    instance.interceptors.response.use(
      (response: EnclosureHttpResoponse) => {
        // 请求每次成功一次就删除当前canceltoken标记
        const cancelKey = EnclosureHttp.genUniqueKey(response.config);
        this.deleteCancelTokenByCancelKey(cancelKey);
        // 优先判断post/get等方法是否传入回掉，否则执行初始化设置等回掉
        if (typeof this.beforeResponseCallback === "function") {
          this.beforeResponseCallback(response);
          this.beforeResponseCallback = undefined;
          return response.data;
        }
        if (EnclosureHttp.initConfig.beforeResponseCallback) {
          EnclosureHttp.initConfig.beforeResponseCallback(response);
          return response.data;
        }
        NProgress.done();
        return response.data;
      },
      (error: EnclosureHttpError) => {
        const $error = error;
        // 判断当前的请求中是否在 取消token数组理存在，如果存在则移除（单次请求流程）
        if (this.currentCancelTokenKey) {
          const haskey = this.sourceTokenList.filter(
            cancelToken => cancelToken.cancelKey === this.currentCancelTokenKey
          ).length;
          if (haskey) {
            this.sourceTokenList = this.sourceTokenList.filter(
              cancelToken =>
                cancelToken.cancelKey !== this.currentCancelTokenKey
            );
            this.currentCancelTokenKey = "";
          }
        }
        $error.isCancelRequest = Axios.isCancel($error);
        NProgress.done();
        // 所有的响应异常 区分来源为取消请求/非取消请求
        return Promise.reject($error);
      }
    );
  }

  public request<T>(
    method: RequestMethods,
    url: string,
    param?: AxiosRequestConfig,
    axiosConfig?: EnclosureHttpRequestConfig
  ): Promise<T> {
    const config = transformConfigByMethod(param, {
      method,
      url,
      ...axiosConfig
    } as EnclosureHttpRequestConfig);
    // 单独处理自定义请求/响应回掉
    if (axiosConfig?.beforeRequestCallback) {
      this.beforeRequestCallback = axiosConfig.beforeRequestCallback;
    }
    if (axiosConfig?.beforeResponseCallback) {
      this.beforeResponseCallback = axiosConfig.beforeResponseCallback;
    }
    return new Promise((resolve, reject) => {
      EnclosureHttp.axiosInstance
        .request(config)
        .then((response: any) => {
          resolve(response);
        })
        .catch((error: any) => {
          reject(error);
        });
    });
  }
  public post<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T> {
    return this.request<T>("post", url, params, config);
  }

  public get<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T> {
    return this.request<T>("get", url, params, config);
  }
}
export default EnclosureHttp;
```
此文件内拦截请求，以及拦截响应内的逻辑可根据自己项目的后端逻辑进行相应的修改

其余文件基本无需有改动
```
# src/utils/http/index.ts
import EnclosureHttp from "./core";
export const http = new EnclosureHttp();

# src/utils/http/types.d.ts
import Axios, {
  AxiosRequestConfig,
  Canceler,
  AxiosResponse,
  Method,
  AxiosError
} from "axios";

import { METHODS } from "./config";

export type cancelTokenType = { cancelKey: string; cancelExecutor: Canceler };

export type RequestMethods = Extract<
  Method,
  "get" | "post" | "put" | "delete" | "patch" | "option" | "head"
>;

export interface EnclosureHttpRequestConfig extends AxiosRequestConfig {
  beforeRequestCallback?: (request: EnclosureHttpRequestConfig) => void; // 请求发送之前
  beforeResponseCallback?: (response: EnclosureHttpResoponse) => void; // 相应返回之前
}

export interface EnclosureHttpResoponse extends AxiosResponse {
  config: EnclosureHttpRequestConfig;
}

export interface EnclosureHttpError extends AxiosError {
  isCancelRequest?: boolean;
}

export default class EnclosureHttp {
  cancelTokenList: Array<cancelTokenType>;
  clearCancelTokenList(): void;
  request<T>(
    method: RequestMethods,
    url: string,
    param?: AxiosRequestConfig,
    axiosConfig?: EnclosureHttpRequestConfig
  ): Promise<T>;
  post<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T>;
  get<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T>;
}

# src/utils/http/utils.ts
import { EnclosureHttpRequestConfig } from "./types.d";

export function excludeProps<T extends { [key: string]: any }>(
  origin: T,
  prop: string
): { [key: string]: T } {
  return Object.keys(origin)
    .filter(key => !prop.includes(key))
    .reduce((res, key) => {
      res[key] = origin[key];
      return res;
    }, {} as { [key: string]: T });
}

export function transformConfigByMethod(
  params: any,
  config: EnclosureHttpRequestConfig
): EnclosureHttpRequestConfig {
  const { method } = config;
  const props = ["delete", "get", "head", "options"].includes(
    method!.toLocaleLowerCase()
  )
    ? "params"
    : "data";
  return {
    ...config,
    [props]: params
  };
}

# src/utils/progress/index.ts
import NProgress from "nprogress";
import "nprogress/nprogress.css";

NProgress.configure({
  // 动画方式
  easing: "ease",
  // 递增进度条的速度
  speed: 500,
  // 是否显示加载ico
  showSpinner: true,
  // 自动递增间隔
  trickleSpeed: 200,
  // 初始化时的最小百分比
  minimum: 0.3
});

export default NProgress;

```
到此项目集成`axios`已经算基本完成，具体使用后面再做介绍

# 集成 Mock
```
yarn add mockjs vite-plugin-mock -D
```

修改`vite.config.ts`文件：
```
import { UserConfigExport, ConfigEnv, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import ElementPlus from "unplugin-element-plus/vite";
import { svgBuilder } from './src/plugins/svgBuilder/index';
import { viteMockServe } from "vite-plugin-mock";
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default ({ command, mode }: ConfigEnv): UserConfigExport => {
	const prodMock = true;
	return {
		plugins: [
			vue(),
			[svgBuilder('./src/assets/icons/svg/')],
			ElementPlus({}),
			viteMockServe({
				mockPath: "./mock", // 模拟接口api文件存放的文件夹
				watchFiles: true, // 将监视文件夹中的文件更改。 并实时同步到请求结果
				localEnabled: command === "serve", // 设置是否启用本地 xxx.ts 文件，不要在生产环境中打开它.设置为 false 将禁用 mock 功能
				prodEnabled: command !== "serve" && prodMock, // 设置生产环境是否启用 mock 功能
				injectCode: `
					import { setupProdMockServer } from './mockProdServer';
					setupProdMockServer();
				`, // 如果生产环境开启了mock功能，该代码会注入到injectFile对应的文件的底部，默认为main.{ts,js}
				injectFile:path.resolve(process.cwd(),'src/main.{ts,js}'),
				logger: true
			})
		],
		resolve: {
			alias: {
				'@': resolve('src'),
			}
		}
	}
}
```
根目录添加`mock`文件夹，并在其内创建`asyncRoutes.ts`文件，用来存放模拟后端请求的动态路由数据及接口
```
import { MockMethod } from "vite-plugin-mock";

// http://mockjs.com/examples.html#Object
const systemRouter = {
  path: "/system",
  name: "system",
  redirect: "/system/user",
  meta: {
    icon: "menu-system",
    title: "设置",
    showLink: true,
    sort: 10
  },
  children: [
    {
      path: "/system/user",
      name: "user",
      meta: {
        title: "个人中心",
        showLink: true,
        sort: 1
      }
    },
    {
      path: "/system/dict",
      name: "dict",
      meta: {
        title: "字典表",
        showLink: true,
        sort: 2
      }
    }
  ]
};


export default [
  {
    url: "/getAsyncRoutes",
    method: "post",
    response: () => {
      return {
        code: 200,
        data: [systemRouter]
      };
    }
  }
] as MockMethod[];
```

在`src`文件夹下创建`mockProdServer.ts`文件（该文件用来生产环境获取mock数据使用）:
```
import { createProdMockServer } from "vite-plugin-mock/es/createProdMockServer";
import asyncRoutesMock from "../mock/asyncRoutes";

export const mockModules = [...asyncRoutesMock];

export function setupProdMockServer() {
  createProdMockServer(mockModules);
}
```
此时`mock`功能就算已经接入成功了，接下来是配合`axios`请求`mock`中的接口，以获取`mock`中存放的数据

这里配合完善`vue-router`以及`vuex`的状态管理，来走通`axios`请求，以及获取`mock`数据

# 串联 vue-router vuex axios mock

在这之前已经写了`mock`数据，`mock/asyncRoutes.ts`文件中暴露出了一个接口，并返回了给定的数据，这一步就相当于后端程序写好了接口，并在接口中返回了前端需要的数据，前端这边需要做的是调用接口，新建`src/api/routes.ts`文件：
```
import { http } from "../utils/http";

export const getAsyncRoutes = (data?: object) => {
  return http.request("post", "/getAsyncRoutes", data);
};
```
这里调用之前已经封装好的`axios`去请求`mock`中写好的接口，然后在需要用到的地方引入这里暴露出来的方法，我们需要在路由中将动态路由，静态路由合并，组装出符合要求的路由结构数据，这个过程需要通过`vuex`去做状态管理

## 获取动态路由

```
# src/router/index.ts  新增
import Layout from "@/layout/index.vue";
const modulesRoutes = import.meta.glob("/src/views/*/*/*.vue");
// 动态路由
import { getAsyncRoutes } from "@/api/routes";


// 过滤后端传来的动态路由 重新生成规范路由
export const addAsyncRoutes = (arrRoutes: Array<RouteComponent>,isRootRedirect:Boolean) => {
    if (!arrRoutes || !arrRoutes.length) return;
    arrRoutes.forEach((v: any) => {
      if (v.redirect&&isRootRedirect) {
        v.component = Layout;
      } else {
        v.component = modulesRoutes[`/src/views${v.path}/index.vue`];
      }
      if (v.children) {
        addAsyncRoutes(v.children,false);
      }
    });
    return arrRoutes;
};

// 初始化路由
export const initRouter = () => {
  return new Promise(resolve => {
    getAsyncRoutes().then((data:any) => {
      console.log(data,"动态路由");
      if (data.length === 0) {
      } else {
        addAsyncRoutes(data,true)?.map((v: any) => {
          // 防止重复添加路由
          if (router.options.routes.findIndex(value => value.path === v.path) !== -1) {
            return;
          } else {
            // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            router.options.routes.push(v);
            // 最终路由进行升序
            ascending(router.options.routes);
            router.addRoute(v.name, v);
          }
          resolve(router);
        });
      }
      router.addRoute({path: "/:pathMatch(.*)",redirect: "/error/404"});
    });
  });
};
```
这里引入`api/routers.ts`暴露的方法，并在初始化路由时使用该方法请求数据，这里可以看到中间有个过滤后端传递过来的动态路由，生成规范路由，这一步判断`component`是否使用`layout`，我这里是通过是否有重定向以及是根节点，这两个条件，这里可根据项目需求自行修改，还需要注意的一点是，这里假定后端返回的动态路由已经是树形结构，`mock`中的数据已经是树形结构，且是符合路由规范的，但正常情况下，后端返回的路由一般为一维数组，且并不符合规范路由写法，这些都要根据后端返回的数据格式在初始化路由，获取到动态数据后，自行处理。

到了这时，动态路由获取的方法已经写好，但还并未调用，以及和静态组合的工作也还未做，此时需要通过`vuex`来管理所有路由，在导航守卫中监控`vuex`中路由存不存在，如不存在则需要在这里调用初始化路由，获取动态路由，并在初始化路由中使用`vuex`的特性，将动态路由与静态路由合并，保存在`vuex`中

## vuex进阶配置
为什么说这里要使用`vuex`来保存所有路由，`vuex`的作用是什么。我们能在`vuex`中集中管理共享的数据，能够高效的实现组件之间的数据共享，存储在`vuex`中的数据都是响应式的，能够实时保持数据与页面的同步，这里的路由数据，不仅需要在导航守卫中用到，还需要在侧边导航栏中调用数据，生成菜单栏，所以需要一个能够更方便在任何地方都可以非常快捷的获取到数据的方法，而`vuex`就能做到这一点

在这之前已经简单的将`vuex`集成到项目中了，现在需要优化一下，像路由一样，数据在`vuex`中管理，也需要分一下模块，新建`src/store/modules/routes.ts`文件：
```
import { Module } from 'vuex'
import { constantRoutesArr, ascending, filterTree } from "@/router";

const routesModule: Module = {
  namespaced: true,
  state: {
    // 静态路由
    constantRoutes: [],
    // 所有路由
    wholeRoutes: [],
  },
  mutations:{},
  actions: {
    // 获取所有路由（静态+动态获取部分）
    asyncActionRoutes({state},routes) {
      if(state.wholeRoutes.length > 0){
        return;
      }
      state.wholeRoutes = filterTree(
        ascending(ascending(constantRoutesArr).concat(routes))
      );
    },
  }
};
export default routesModule
```
这么写之后，会发现页面报`TS`类型错误，这里需要先声明类型，在根目录新建`types`文件夹，并新建`store.d.ts`文件，这个文件将是之后状态管理里的所有类型声明的集合文件
```
import { ComponentCustomProperties } from 'vue'
import { Store } from 'vuex'
import { RouteComponent } from 'vue-router'

declare interface Routes {
  constantRoutes:RouteComponent
  wholeRoutes:Array
}

declare interface State {
  routes: Routes
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $store: Store<State>
  }
}
```
然后修改`tsconfig.json`文件：
```
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "node",
    "strict": false,
    "jsx": "preserve",
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "lib": ["esnext", "dom"],
    // 新增
    "baseUrl": ".", 
    "paths":{
      "@/*": ["src/*"],
      "#/*": ["types/*"]
    },
    "types": ["node", "vite/client", "element-plus/global"],
    "typeRoots": ["./node_modules/@types/", "./types"],
    "importHelpers": true,
    "experimentalDecorators": true,
    "strictFunctionTypes": false,
    "skipLibCheck": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
  },
  "include": [
    "src/**/*.ts", 
    "src/**/*.tsx", 
    "src/**/*.vue",
    "types/*.d.ts",
    "vite.config.ts"
  ],
  "exclude": ["node_modules", "dist", "**/*.js"]
}
```
在`vite.config.ts`文件中增加文件夹别名配置：
```
resolve: {
  alias: {
    '@': resolve('src'),
    '#': resolve('types'),
  }
}
```
修改`src/store/modules/routes.ts`文件：
```
import { Module } from 'vuex'
import { Routes } from "#/store";
import { constantRoutesArr, ascending, filterTree } from "@/router";

const routesModule: Module<Routes,any> = {
  namespaced: true,
  state: {
    // 静态路由
    constantRoutes: [],
    // 所有路由
    wholeRoutes: [],
  },
  mutations:{},
  actions: {
    // 获取所有路由（静态+动态获取部分）
    asyncActionRoutes({state},routes) {
      if(state.wholeRoutes.length > 0){
        return;
      }
      state.wholeRoutes = filterTree(
        ascending(ascending(constantRoutesArr).concat(routes))
      );
    },
  }
};
export default routesModule
```
此时顺带将`src`文件夹下的`env.d.ts`文件删除，并在`types`文件夹下新建`shims-vue.d.ts`文件：
```
declare module "*.vue" {
  import { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}

declare module "*.scss" {
  const scss: Record<string, string>;
  export default scss;
}
```
根目录新增`.eslintignore`文件：
```
public
dist
*.d.ts
package.json
```
此时文件内的`TS`报错应该都已经不存在了，路由数据的状态管理模块已经创建好，接下来需要改一下`src/store/index.ts`文件，让模块化的`vuex`可以自动挂载到项目中
```
import { createStore } from 'vuex';
import { State } from '#/store';

// Vite supports importing multiple modules from the file system using the special import.meta.glob function
// see https://cn.vitejs.dev/guide/features.html#glob-import
const modulesFiles = import.meta.globEager('./modules/*.ts');
const pathList: string[] = [];

for (const path in modulesFiles) {
  pathList.push(path);
}

const modules = pathList.reduce((modules: any, modulePath: string) => {
  const moduleName = modulePath.replace(/^\.\/modules\/(.*)\.\w+$/, '$1');
  const value = modulesFiles[modulePath];
  modules[moduleName] = value.default;
  return modules;
}, {});

const store = createStore<State>({
  modules
});

export default store
```
到此，`vuex`的配置就算完成了，后期只需在此基础上新增状态管理，以及对应的在`types/store.d.ts`文件内新增类型声明即可

接下来就是通过导航守卫功能，将整条链路打通

## 导航守卫

做导航守卫之前，先引入一个别人封装好的缓存工具：
```
# src/utils/storage/index.ts
interface ProxyStorage {
  getItem(key: string): any;
  setItem(Key: string, value: string): void;
  removeItem(key: string): void;
  clear(): void;
}

//sessionStorage operate
class sessionStorageProxy implements ProxyStorage {
  protected storage: ProxyStorage;

  constructor(storageModel: ProxyStorage) {
    this.storage = storageModel;
  }

  // 存
  public setItem(key: string, value: any): void {
    this.storage.setItem(key, JSON.stringify(value));
  }

  // 取
  public getItem(key: string): any {
    return JSON.parse(this.storage.getItem(key)) || null;
  }

  // 删
  public removeItem(key: string): void {
    this.storage.removeItem(key);
  }

  // 清空
  public clear(): void {
    this.storage.clear();
  }
}

//localStorage operate
class localStorageProxy extends sessionStorageProxy implements ProxyStorage {
  constructor(localStorage: ProxyStorage) {
    super(localStorage);
  }
}
export const storageSession = new sessionStorageProxy(sessionStorage);

export const storageLocal = new localStorageProxy(localStorage);
```
以及打开超链接的一个工具函数：
```
# src/utils/link.ts
export const openLink = (link: string) => {
  const $a: HTMLElement = document.createElement("a");
  $a.setAttribute("href", link);
  $a.setAttribute("target", "_blank");
  $a.setAttribute("rel", "noreferrer noopener");
  $a.setAttribute("id", "external");
  document.getElementById("external") &&
    document.body.removeChild(document.getElementById("external"));
  document.body.appendChild($a);
  $a.click();
  $a.remove();
};
```
然后修改`src/router/index.ts`文件：
```
# 页面内新增
import NProgress from "@/utils/progress";
import store from "@/store";
import { storageSession, storageLocal } from "@/utils/storage";
import { openLink } from "@/utils/link";
import { split, uniqBy } from "lodash-es";


// 路由白名单
const whiteList = ["/login"];

router.beforeEach((to, _from, next) => {
  const userInfo = storageSession.getItem("userInfo");
  NProgress.start();
  const externalLink = to?.redirectedFrom?.fullPath;
  // @ts-ignore
  if (!externalLink) to.meta.title ? (document.title = to.meta.title) : "";
  if (userInfo&&userInfo?.accessToken) {
    if (_from?.name) {
      // 如果路由包含http 则是超链接 反之是普通路由
      if (externalLink && externalLink.includes("http")) {
        openLink(`http${split(externalLink, "http")[1]}`);
        NProgress.done();
      } else {
        next();
      }
    } else {
      // 刷新
      if (store.state.routes.wholeRoutes.length === 0){
        initRouter().then((router: Router) => {
          router.push(to.path);
        });
      }
      next();
    }
  } else {
    if (to.path !== "/login") {
      if (whiteList.indexOf(to.path) !== -1) {
        next();
      } else {
        next({ path: "/login" });
      }
    } else {
      next();
    }
  }
});

router.afterEach(() => {
  NProgress.done();
});
```
这里引入了一个新的插件，需要先进行安装：
```
yarn add lodash-es
```
此时整条链路就算完全打通了，运行项目，可以发现路由已经自动跳转到登录页，说明导航守卫已经起作用了，这里是假设我们通过`token`的方式验证登录状态，先从缓存中获取登录时我们存储在缓存中的`token`，如果`token`存在，说明已经登录，否则需要跳转登录页，或者其他在白名单内的页面（如果你浏览器打开的页面是白名单内的页面的话）

`token`存在的情况下，如果`from.name`存在，需判断路由是普通路由，还是超链接，超链接需要直接跳转，而不用走路由流程，用的是超链接跳转的工具函数；而如果`form.name`不存在，并且路由数据状态管理中的`wholeRoutes`数组为空，说明是首次或是刷新操作进入，此时需要先加载所有路由，这里开始就连上了之前已经写好的初始化路由方法，方法中先是调用了引入的用`axios`封装的请求方法，而请求方法的接口是通过`mock`数据添加的，动态数据获取后需要和静态路由整合，而动态路由和静态路由的整合，我们是写在`vuex`的模块`routes`里的，所以这里需要对初始化路由方法进行修改：

```
// 初始化路由
export const initRouter = () => {
  return new Promise(resolve => {
    getAsyncRoutes().then((data:any) => {
      console.log(data,"动态路由");
      if (data.length === 0) {
        store.dispatch('routes/asyncActionRoutes',data);
      } else {
        addAsyncRoutes(data,true)?.map((v: any) => {
          // 防止重复添加路由
          if (router.options.routes.findIndex(value => value.path === v.path) !== -1) {
            return;
          } else {
            // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            router.options.routes.push(v);
            // 最终路由进行升序
            ascending(router.options.routes);
            router.addRoute(v.name, v);
            store.dispatch('routes/asyncActionRoutes',data);
          }
          resolve(router);
        });
      }
      router.addRoute({path: "/:pathMatch(.*)",redirect: "/error/404"});
    });
  });
};
```
这一步完成，关于`vue-router`,`vuex`,`axios`,`mock`整体就已经串联起来了，运行项目，能正常展示登录页，说明暂时无太大的问题，接下来，需要修改一个登录页，方便接下来框架的搭建

## 登录逻辑优化

#### src/views/login/index.vue
```
<script setup lang="ts">
import { infoType } from "./type";
import { useRouter } from "vue-router";
import { reactive } from "vue";
import { getLogin } from "@/api/user";
import { storageSession } from "@/utils/storage";
import { warnMessage, successMessage } from "@/utils/message";
import info, { ContextProps } from "./components/default/index.vue";

const router = useRouter();
const contextInfo: ContextProps = reactive({
  userName: "",
  passWord: "",
});
const toPage = (info: Object): void => {
  storageSession.setItem("userInfo", info);
  router.push("/");
};
// 登录
const onLogin = async () => {
  let { userName, passWord } = contextInfo;
  let { code, info,data, accessToken }: infoType = await getLogin({
    username: userName,
    password: passWord,
  });
  const userInfo:any = data;
  userInfo.accessToken = accessToken
  code === 0
    ? successMessage(info) &&
      toPage(userInfo)
    : warnMessage(info);
};

</script>

<template>
  <div class="login">
    <info
      :ruleForm="contextInfo"
      @on-behavior="onLogin"
    />
  </div>
</template>
```
#### src/views/login/components/default/index.vue
```
<script setup lang="ts">
import { ref, PropType, getCurrentInstance, toRef } from "vue";
import { useRouter } from "vue-router";
import { initRouter } from "@/router";
import { storageSession } from "@/utils/storage";

export interface ContextProps {
  userName: string;
  passWord: string;
}

const props = defineProps({
  ruleForm: {
    type: Object as PropType<ContextProps>
  }
});

const emit = defineEmits<{
  (e: "onBehavior", evt: Object): void;
}>();

const instance = getCurrentInstance();

const model = toRef(props, "ruleForm");

const router = useRouter();

const rules = ref<any>({
  userName: [{ required: true, message: "请输入用户名", trigger: "blur" }],
  passWord: [
    { required: true, message: "请输入密码", trigger: "blur" },
    { min: 6, message: "密码长度必须不小于6位", trigger: "blur" }
  ],
});

// 点击登录
const onBehavior = (evt: Object): void => {
  // @ts-expect-error
  instance.refs.ruleForm.validate((valid: boolean) => {
    if (valid) {
      emit("onBehavior", evt);
    } else {
      return false;
    }
  });
};

// 表单重置
const resetForm = (): void => {
  // @ts-expect-error
  instance.refs.ruleForm.resetFields();
};

const noSecret = (): void => {
  storageSession.setItem("userInfo", {
    accessToken: "eyJhbGciOiJIUzUxMiJ9"
  });
  initRouter().then(() => {});
  router.push("/");
};
</script>

<template>
  <div class="info">
    <el-form :model="model" :rules="rules" ref="ruleForm" class="rule-form">
      <el-form-item prop="userName">
        <el-input
          clearable
          v-model="model.userName"
          placeholder="请输入用户名"
          prefix-icon="el-icon-user"
        ></el-input>
      </el-form-item>
      <el-form-item prop="passWord">
        <el-input
          clearable
          type="password"
          show-password
          v-model="model.passWord"
          placeholder="请输入密码"
          prefix-icon="el-icon-lock"
        ></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click.prevent="onBehavior">登录</el-button>
        <el-button @click="resetForm">重置</el-button>
      </el-form-item>
      <span title="测试用户 直接登录" class="secret" @click="noSecret">免密登录</span>
    </el-form>
  </div>
</template>

<style lang="scss" scoped>
.info {
  width: 30vw;
  height: 48vh;
  background: url("@/assets/login.png") no-repeat center;
  background-size: cover;
  position: absolute;
  border-radius: 20px;
  right: 100px;
  top: 30vh;
  display: flex;
  justify-content: center;
  align-items: center;
  @media screen and (max-width: 750px) {
    width: 88vw;
    right: 25px;
    top: 22vh;
  }

  .rule-form {
    width: 80%;

    .verify {
      position: absolute;
      margin: -10px 0 0 -120px;

      &:hover {
        cursor: pointer;
      }
    }

    .tips {
      color: #409eff;
      float: right;

      &:hover {
        cursor: pointer;
      }
    }
  }

  .secret {
    color: #409eff;

    &:hover {
      cursor: pointer;
    }
  }
}
</style>
```
#### src/views/login/type.ts
```
export type infoType = {
  code?: number;
  info?: string;
  data?: object;
  accessToken?: string;
};
```
#### 封装消息提示框工具函数
```
# src/utils/message/index.ts
import { ElMessage } from "element-plus";

// 消息
const Message = (message: string): any => {
  return ElMessage({
    showClose: true,
    message
  });
};

// 成功
const successMessage = (message: string): any => {
  return ElMessage({
    showClose: true,
    message,
    type: "success"
  });
};

// 警告
const warnMessage = (message: string): any => {
  return ElMessage({
    showClose: true,
    message,
    type: "warning"
  });
};

// 失败
const errorMessage = (message: string): any => {
  return ElMessage({
    showClose: true,
    message,
    type: "error"
  });
};

export { Message, successMessage, warnMessage, errorMessage };
```
#### src/style/public.scss
```
# 新增
.login{
  width: 100vw;
  height: 100vh;
  overflow-x: hidden;
  background: url("../assets/login.jpg") no-repeat center;
  background-size: cover;
}
```
#### 路由实例中增加滚动行为
```
// 创建路由实例
export const router: Router = createRouter({
    history: createWebHistory(),
    routes: filterTree(ascending(constantRoutes)).concat(...remainingRouter),
    scrollBehavior(to, from, savedPosition) {
      return new Promise(resolve => {
        if (savedPosition) {
          return savedPosition;
        } else {
          if (from.meta.saveSrollTop) {
            const top: number =
              document.documentElement.scrollTop || document.body.scrollTop;
            resolve({ left: 0, top });
          }
        }
      });
    }
});
```
#### 登录接口
```
# src/api/user.ts
import { http } from "../utils/http";

// 登录
export const getLogin = (data: object) => {
  return http.request("post", "/login", data);
};

```
此时再运行项目，登录页已经做了美化，点击免密登录，也可以正常进入首页，这里主要是免密登录时缓存了一个静态的`token`，这样在导航守卫中`token`验证通过，就可以正常跳转页面了



# 侧边导航优化
完成了登录、导航守卫的逻辑后，接下来需要将已获取的路由转化为侧边导航进行展示

#### 导航动态化
```
# src/layout/components/vertical.vue
<script setup lang="ts">
import Logo from "./logo/index.vue"
import SidebarItem from "./sidebarItem/index.vue";
import { useStore } from 'vuex'
import { computed } from "vue";
import { useRoute } from "vue-router";
const route = useRoute();
const store = useStore()
const menuList = store.state.routes.wholeRoutes
const activeMenu = computed((): string => {
  const { meta, path } = route;
  if (meta.activeMenu) {
    // @ts-ignore
    return meta.activeMenu;
  }
  return path;
});

</script>
<template>
  <div class="sidebar-container">
    <Logo />
    <el-scrollbar wrap-class="scrollbar-wrapper">
      <el-menu
        :default-active="activeMenu"
        unique-opened
        router
        :collapse-transition="false"
        mode="vertical"
        class="outer-most"
      >
        <sidebar-item
          v-for="route in menuList"
          :key="route.path"
          :item="route"
          class="outer-most"
          :base-path="route.path"
        />
      </el-menu>
    </el-scrollbar>
  </div>
</template>

<style lang="scss" scoped>
</style>
```
修改`src/layout/components/sidebarItem/index.vue`文件：
```
<script setup lang="ts">
import path from 'path'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";

const props = defineProps({
  item: {
    type: Object as PropType<childrenType>
  },
  isNest: {
    type: Boolean,
    default: false
  },
  basePath: {
    type: String,
    default: ""
  }
});

const onlyOneChild: childrenType = ref(null);
// 存放菜单是否存在showTooltip属性标识
const hoverMenuMap = new WeakMap();
// 存储菜单文本dom元素
const menuTextRef = ref(null);

function hoverMenu(key) {
  // 如果当前菜单showTooltip属性已存在，退出计算
  if (hoverMenuMap.get(key)) return;

  nextTick(() => {
    // 如果文本内容的整体宽度大于其可视宽度，则文本溢出
    menuTextRef.value?.scrollWidth > menuTextRef.value?.clientWidth
      ? Object.assign(key, {
          showTooltip: true
        })
      : Object.assign(key, {
          showTooltip: false
        });
    hoverMenuMap.set(key, true);
  });
}

function hasOneShowingChild(
  children: childrenType[] = [],
  parent: childrenType
) {
  const showingChildren = children.filter((item: any) => {
    onlyOneChild.value = item;
    return true;
  });

  if (showingChildren.length === 1) {
    return true;
  }

  if (showingChildren.length === 0) {
    onlyOneChild.value = { ...parent, path: "", noShowingChildren: true };
    return true;
  }
  return false;
}

function resolvePath(routePath) {
  const httpReg = /^http(s?):\/\//;
  if (httpReg.test(routePath)) {
    return props.basePath + "/" + routePath;
  } else {
    return path.resolve(props.basePath, routePath);
  }
}
</script>

<template>
  <template v-if="hasOneShowingChild(props.item.children, props.item)&&(!onlyOneChild.children || onlyOneChild.noShowingChildren)">
    <el-menu-item
      :index="resolvePath(onlyOneChild.path)"
      :class="{ 'submenu-title-noDropdown': !isNest }"
      style="display: flex; align-items: center"
    >
      <template #title>
        <div
          :style="{
            width: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            overflow: 'hidden'
          }"
        >
          <el-tooltip
            placement="top"
            :offset="-10"
            :disabled="!onlyOneChild.showTooltip"
          >
            <template #content>
              {{ onlyOneChild.meta.title }}
            </template>
            <span
              ref="menuTextRef"
              :style="{
                width: '125px',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
              }"
              @mouseover="hoverMenu(onlyOneChild)"
            >
              {{ onlyOneChild.meta.title }}
            </span>
          </el-tooltip>
          <svg-icon
            v-if="props.item.meta.extraIcon"
            :icon-class="`${props.item.meta.extraIcon.name}`"
          />
        </div>
      </template>
    </el-menu-item>
  </template>

  <el-sub-menu v-else ref="subMenu" :index="resolvePath(props.item.path)" popper-append-to-body>
    <template #title>
      <el-tooltip
        placement="top"
        :offset="-10"
        :disabled="!props.item.showTooltip"
      >
        <template #content>
          {{ props.item.meta.title }}
        </template>
        <div
          ref="menuTextRef"
          :style="{
            display: 'inline-block',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }"
          @mouseover="hoverMenu(props.item)"
        >
          <span style="overflow: hidden; text-overflow: ellipsis">
            {{ props.item.meta.title }}
          </span>
        </div>
      </el-tooltip>
      <svg-icon
        v-if="props.item.meta.extraIcon"
        :icon-class="`${props.item.meta.extraIcon.name}`"
      />
    </template>
    <sidebar-item
      v-for="child in props.item.children"
      :key="child.path"
      :is-nest="true"
      :item="child"
      :base-path="resolvePath(child.path)"
      class="nest-menu"
    />
  </el-sub-menu>
</template>
```
创建`layout`模块的类型声明文件：
```
# src/layout/types.ts
export type childrenType = {
  path?: string;
  noShowingChildren?: boolean;
  children?: childrenType[];
  value: unknown;
  meta?: {
    icon?: string;
    title?: string;
    extraIcon?: {
      svg?: boolean;
      name?: string;
    };
  };
  showTooltip?: boolean;
};
```
如果此时运行项目，会有报错：
```
Module "path" has been externalized for browser compatibility and cannot be accessed in client code.
```
这里需要安装新的插件：
```
yarn add path-browserify
```
同时修改`src/layout/components/sidebarItem/index.vue`文件：
```
# 将
import path from 'path'
修改为：
import path from 'path-browserify'
```
此时再运行项目，就不会出现上面的报错了，不过此时控制台依然会有警告，且侧边导航展示的子导航并没有被渲染出来：
```
Failed to resolve component: sidebar-item
```
这里需要继续修改`src/layout/components/sidebarItem/index.vue`文件：
```
<script lang="ts">
export default {
  name: "sidebar-item"
};
</script>
<script setup lang="ts">
import path from 'path-browserify'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";
...
```
用一个不带`setup`语法糖的`script`标签，声明该组件的`name`，这样组件内部调用自身就不会再有警告，此时运行项目，侧边导航已经能够正常展示，子导航也都能正常渲染了

#### 导航图标优化
前文中已经集成了图标组件，这里需要先将各路由中的图标按图标组件的格式修改正确，并在`meta`中加一个字段，用来判断是第三方组件式图标，还是常规图标
```
# src/router/modules/demo.ts  使用svg文件形式的图标
import Layout from "@/layout/index.vue";

const router = {
  path: "/demo",
  name: "demoLayout",
  component: Layout,
  meta: {
    icon:'sgn-demo',
    title: "demo小样",
    isComponent:false,
    showLink: true,
    sort:2
  },
  children: [
    {
      path: "/demo",
      name: "demo",
      component: () => import("@/views/demo/index.vue"),
      meta: {
        title: "demo小样",
        showLink: true,
        sort:2,
        extraIcon:{
          svg:true,
          name:'sgn-new'
        }
      }
    }
  ]
};
export default router;

# src/router/modules/error.ts  使用element-plus按需引入的图标，为第三方组件式图标
import Layout from "@/layout/index.vue";

const errorRouter = {
  path: "/error",
  name: "error",
  component: Layout,
  redirect: "/error/401",
  meta: {
    icon: "Position",
    isComponent:true,
    title: "错误页面",
    showLink: true,
    sort: 7
  },
  children: [
    {
      path: "/error/401",
      name: "401",
      component: () => import("@/views/error/401/index.vue"),
      meta: {
        title: "401",
        showLink: true
      }
    },
    {
      path: "/error/404",
      name: "404",
      component: () => import("@/views/error/404/index.vue"),
      meta: {
        title: "404",
        showLink: true
      }
    }
  ]
};

export default errorRouter;

# src/router/modules/home.ts  使用font awesome的图标，为第三方组件式图标
import Layout from "@/layout/index.vue";

const router = {
  path: "/",
  name: "layout",
  component: Layout,
  meta: {
    icon:'fa-house-damage',
    isComponent:true,
    showLink: true,
    sort:1
  },
  children: [
    {
      path: "/",
      name: "home",
      component: () => import("@/views/home/index.vue"),
      meta: {
        title: "首页",
        showLink: true,
        sort:1
      }
    }
  ]
};

export default router;

# src/router/modules/nested.ts  使用iconfont的图标，为iconfont.js中引入的svg图标
import Layout from "@/layout/index.vue";

const router = {
  path: "/nested",
  name: "Nested",
  component: Layout,
  redirect: "/nested/menu1/menu1-1",
  meta:{
    icon:'icon-xitongshiti',
    isComponent:false,
    sort:3,
    showLink:true,
    title:"嵌套路由"
  },
  children:[
    {
      path: "/nested/menu1",
      component: () => import("@/views/nested/menu1/index.vue"),
      name: "Menu1",
      redirect: "/nested/menu1/menu1-1",
      meta:{
        sort:1,
        showLink:true,
        title:"嵌套路由1"
      },
      children: [
          {
              path: "/nested/menu1/menu1-1",
              component: () => import("@/views/nested/menu1/menu1-1/index.vue"),
              name: "Menu1-1",
              meta:{
                sort:1,
                showLink:true,
                title:"嵌套路由1-1"
              },
          },
          {
              path: "/nested/menu1/menu1-2",
              component: () => import("@/views/nested/menu1/menu1-2/index.vue"),
              name: "Menu1-2",
              redirect: "/nested/menu1/menu1-2/menu1-2-1",
              meta:{
                sort:2,
                showLink:true,
                title:"嵌套路由1-2"
              },
              children: [
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-1",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-1/index.vue"),
                      name: "Menu1-2-1",
                      meta:{
                        sort:1,
                        showLink:true,
                        title:"嵌套路由1-2-1"
                      },
                  },
                  {
                      path: "/nested/menu1/menu1-2/menu1-2-2",
                      component: () => import("@/views/nested/menu1/menu1-2/menu1-2-2/index.vue"),
                      name: "Menu1-2-2",
                      meta:{
                        sort:2,
                        showLink:true,
                        title:"嵌套路由1-2-2"
                      },
                  }
              ]
          },
          {
              path: "/nested/menu1/menu1-3",
              component: () => import("@/views/nested/menu1/menu1-3/index.vue"),
              name: "Menu1-3",
              meta:{
                sort:3,
                showLink:true,
                title:"嵌套路由1-3"
              },
          }
      ]
    },
    {
        path: "/nested/menu2",
        name: "Menu2",
        component: () => import("@/views/nested/menu2/index.vue"),
        meta:{
          sort:2,
          showLink:true,
          title:"嵌套路由2"
        },
    }
  ]
};

export default router;

# mock/asyncRoutes.ts 为下载的svg文件图标
const systemRouter = {
  path: "/system",
  name: "system",
  redirect: "/system/user",
  meta: {
    icon: "sgn-menu-system",
    isComponent:false,
    title: "设置",
    showLink: true,
    sort: 10
  },
  children: [
    {
      path: "/system/user",
      name: "user",
      meta: {
        title: "个人中心",
        showLink: true,
        sort: 1
      }
    },
    {
      path: "/system/dict",
      name: "dict",
      meta: {
        title: "字典表",
        showLink: true,
        sort: 2
      }
    }
  ]
};
```
以上一级导航的图标都已修改，并增加了`isComponent`字段，来判断是否需要使用第三方组件的形式引入图标，`demo`文件的二级路由加了其他图标字段，用来加载一些特殊需求的图标，接下来修改`src/layout/components/sidebarItem/index.vue`文件：
```
<script lang="ts">
export default {
  name: "sidebar-item"
};
</script>
<script setup lang="ts">
import path from 'path-browserify'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";
import Icon from "@/components/Icon/src/Icon.vue";
import { findIconReg } from "@/components/Icon";

const props = defineProps({
  item: {
    type: Object as PropType<childrenType>
  },
  isNest: {
    type: Boolean,
    default: false
  },
  basePath: {
    type: String,
    default: ""
  }
});

const onlyOneChild: childrenType = ref(null);
// 存放菜单是否存在showTooltip属性标识
const hoverMenuMap = new WeakMap();
// 存储菜单文本dom元素
const menuTextRef = ref(null);

function hoverMenu(key) {
  // 如果当前菜单showTooltip属性已存在，退出计算
  if (hoverMenuMap.get(key)) return;

  nextTick(() => {
    // 如果文本内容的整体宽度大于其可视宽度，则文本溢出
    menuTextRef.value?.scrollWidth > menuTextRef.value?.clientWidth
      ? Object.assign(key, {
          showTooltip: true
        })
      : Object.assign(key, {
          showTooltip: false
        });
    hoverMenuMap.set(key, true);
  });
}

function hasOneShowingChild(children: childrenType[] = [],parent: childrenType) {
  const showingChildren = children.filter((item: any) => {
    onlyOneChild.value = item;
    return true;
  });

  if (showingChildren.length === 1) {
    return true;
  }

  if (showingChildren.length === 0) {
    onlyOneChild.value = { ...parent, path: "", noShowingChildren: true };
    return true;
  }
  return false;
}

function resolvePath(routePath) {
  const httpReg = /^http(s?):\/\//;
  if (httpReg.test(routePath)) {
    return props.basePath + "/" + routePath;
  } else {
    return path.resolve(props.basePath, routePath);
  }
}
</script>

<template>
  <template v-if="hasOneShowingChild(props.item.children, props.item)&&(!onlyOneChild.children || onlyOneChild.noShowingChildren)">
    <el-menu-item
      :index="resolvePath(onlyOneChild.path)"
      :class="{ 'submenu-title-noDropdown': !isNest }"
      style="display: flex; align-items: center"
    >
      <el-icon v-show="props.item.meta.icon">
        <component v-if="onlyOneChild.meta.isComponent||props.item.meta.isComponent" :is="findIconReg(onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon))"></component>
        <Icon v-else :svg="true" :content="`${onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon)}`" />
      </el-icon>
      <template #title>
        <div
          :style="{
            width: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            overflow: 'hidden'
          }"
        >
          <el-tooltip
            placement="top"
            :offset="-10"
            :disabled="!onlyOneChild.showTooltip"
          >
            <template #content>
              {{ onlyOneChild.meta.title }}
            </template>
            <span
              ref="menuTextRef"
              :style="{
                width: '125px',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
              }"
              @mouseover="hoverMenu(onlyOneChild)"
            >
              {{ onlyOneChild.meta.title }}
            </span>
          </el-tooltip>
          <Icon
            v-if="onlyOneChild.meta.extraIcon"
            :svg="onlyOneChild.meta.extraIcon.svg ? true : false"
            :content="`${onlyOneChild.meta.extraIcon.name}`"
          />
        </div>
      </template>
    </el-menu-item>
  </template>

  <el-sub-menu v-else ref="subMenu" :index="resolvePath(props.item.path)" popper-append-to-body>
    <template #title>
      <el-icon v-show="props.item.meta.icon">
        <component v-if="props.item.meta.isComponent" :is="findIconReg(props.item.meta && props.item.meta.icon)"></component>
        <Icon v-else :svg="true" :content="`${props.item.meta && props.item.meta.icon}`" />
      </el-icon>
      <el-tooltip
        placement="top"
        :offset="-10"
        :disabled="!props.item.showTooltip"
      >
        <template #content>
          {{ props.item.meta.title }}
        </template>
        <div
          ref="menuTextRef"
          :style="{
            display: 'inline-block',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }"
          @mouseover="hoverMenu(props.item)"
        >
          <span style="overflow: hidden; text-overflow: ellipsis">
            {{ props.item.meta.title }}
          </span>
        </div>
      </el-tooltip>
      <Icon
        v-if="props.item.meta.extraIcon"
        :svg="props.item.meta.extraIcon.svg ? true : false"
        :content="`${props.item.meta.extraIcon.name}`"
      />
    </template>
    <sidebar-item
      v-for="child in props.item.children"
      :key="child.path"
      :is-nest="true"
      :item="child"
      :base-path="resolvePath(child.path)"
      class="nest-menu"
    />
  </el-sub-menu>
</template>
```
此时运行项目，所有图标都能正常显示了，特殊需求图标也能正常显示，那么此时，侧边导航的功能就算完成了，再做一下样式优化，以及展开折叠功能即可

#### 导航样式优化
```
# src/style/-layout.scss
# .sidebar-container内新增：
.el-icon{
    display: inline-block;
    width: 18px;
    height: 18px;
    line-height:0;
    font-size:0;
    vertical-align: middle;
    margin-right: 5px;
    &.tag-icon{
      margin-right:-6px;
      width: 24px;
      height: 24px;
      svg{
        font-size: 24px!important;
      }
    }
    svg{
      width: 1em !important;
      height: 1em !important;
      font-size: 18px !important;
      text-align: center;
      vertical-align: middle;
      line-height: 0;
      display: inline-block;
    }
  }
```
`src/layout/components/sidebarItem/index.vue`文件修改：
```
<script lang="ts">
export default {
  name: "sidebar-item"
};
</script>
<script setup lang="ts">
import path from 'path-browserify'
import { PropType, ref, nextTick } from "vue";
import { childrenType } from "../../types";
import Icon from "@/components/Icon/src/Icon.vue";
import { findIconReg } from "@/components/Icon";

const props = defineProps({
  item: {
    type: Object as PropType<childrenType>
  },
  isNest: {
    type: Boolean,
    default: false
  },
  basePath: {
    type: String,
    default: ""
  }
});

const onlyOneChild: childrenType = ref(null);
// 存放菜单是否存在showTooltip属性标识
const hoverMenuMap = new WeakMap();
// 存储菜单文本dom元素
const menuTextRef = ref(null);

function hoverMenu(key) {
  // 如果当前菜单showTooltip属性已存在，退出计算
  if (hoverMenuMap.get(key)) return;

  nextTick(() => {
    // 如果文本内容的整体宽度大于其可视宽度，则文本溢出
    menuTextRef.value?.scrollWidth > menuTextRef.value?.clientWidth
      ? Object.assign(key, {
          showTooltip: true
        })
      : Object.assign(key, {
          showTooltip: false
        });
    hoverMenuMap.set(key, true);
  });
}

function hasOneShowingChild(children: childrenType[] = [],parent: childrenType) {
  const showingChildren = children.filter((item: any) => {
    onlyOneChild.value = item;
    return true;
  });

  if (showingChildren.length === 1) {
    return true;
  }

  if (showingChildren.length === 0) {
    onlyOneChild.value = { ...parent, path: "", noShowingChildren: true };
    return true;
  }
  return false;
}

function resolvePath(routePath) {
  const httpReg = /^http(s?):\/\//;
  if (httpReg.test(routePath)) {
    return props.basePath + "/" + routePath;
  } else {
    return path.resolve(props.basePath, routePath);
  }
}
</script>

<template>
  <template v-if="hasOneShowingChild(props.item.children, props.item)&&(!onlyOneChild.children || onlyOneChild.noShowingChildren)">
    <el-menu-item
      :index="resolvePath(onlyOneChild.path)"
      :class="{ 'submenu-title-noDropdown': !isNest }"
      style="display: flex; align-items: center"
    >
      <el-icon v-show="props.item.meta.icon">
        <component v-if="onlyOneChild.meta.isComponent||props.item.meta.isComponent" :is="findIconReg(onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon))"></component>
        <Icon v-else :svg="true" :content="`${onlyOneChild.meta.icon ||(props.item.meta && props.item.meta.icon)}`" />
      </el-icon>
      <template #title>
        <div
          :style="{
            width: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            overflow: 'hidden'
          }"
        >
          <el-tooltip
            placement="top"
            :offset="-10"
            :disabled="!onlyOneChild.showTooltip"
          >
            <template #content>
              {{ onlyOneChild.meta.title }}
            </template>
            <span
              ref="menuTextRef"
              :style="{
                width: '125px',
                overflow: 'hidden',
                textOverflow: 'ellipsis'
              }"
              @mouseover="hoverMenu(onlyOneChild)"
            >
              {{ onlyOneChild.meta.title }}
            </span>
          </el-tooltip>
        </div>
        <el-icon class="tag-icon" v-if="onlyOneChild.meta.extraIcon">
        <Icon
          :svg="onlyOneChild.meta.extraIcon.svg ? true : false"
          :content="`${onlyOneChild.meta.extraIcon.name}`"
        /></el-icon>
      </template>
    </el-menu-item>
  </template>

  <el-sub-menu v-else ref="subMenu" :index="resolvePath(props.item.path)" popper-append-to-body>
    <template #title>
      <el-icon v-show="props.item.meta.icon">
        <component v-if="props.item.meta.isComponent" :is="findIconReg(props.item.meta && props.item.meta.icon)"></component>
        <Icon v-else :svg="true" :content="`${props.item.meta && props.item.meta.icon}`" />
      </el-icon>
      <el-tooltip
        placement="top"
        :offset="-10"
        :disabled="!props.item.showTooltip"
      >
        <template #content>
          {{ props.item.meta.title }}
        </template>
        <div
          ref="menuTextRef"
          :style="{
            display: 'inline-block',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }"
          @mouseover="hoverMenu(props.item)"
        >
          <span style="overflow: hidden; text-overflow: ellipsis">
            {{ props.item.meta.title }}
          </span>
        </div>
      </el-tooltip>
      <el-icon class="tag-icon" v-if="props.item.meta.extraIcon"><Icon
        :svg="props.item.meta.extraIcon.svg ? true : false"
        :content="`${props.item.meta.extraIcon.name}`"
      /></el-icon>
    </template>
    <sidebar-item
      v-for="child in props.item.children"
      :key="child.path"
      :is-nest="true"
      :item="child"
      :base-path="resolvePath(child.path)"
      class="nest-menu"
    />
  </el-sub-menu>
</template>
```
此时样式优化已完成，不过这里需要注意的是，由于使用的`svg`图标有多种版式，所以，图标的大小上看上去会有明显的不同，在真正的项目开发中，应尽量统一图标版式，统一图标比例，那样会更美观一些，不过这就是UI的事儿了~

#### 侧边导航展开折叠功能
先讲折叠功能按钮组件代码写好：
```
# src/layout/components/hamBurger/index.vue
<script setup lang="ts">
export interface Props {
  isActive: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  isActive: false
});

const emit = defineEmits<{
  (e: "toggleClick"): void;
}>();

const toggleClick = () => {
  emit("toggleClick");
};
</script>

<template>
  <div
    :class="classes.container"
    :title="props.isActive ? '点击折叠' : '点击展开'"
    @click="toggleClick"
  >
    <svg
      :class="['hamburger', props.isActive ? 'is-active' : '']"
      viewBox="0 0 1024 1024"
      xmlns="http://www.w3.org/2000/svg"
      width="64"
      height="64"
    >
      <path
        d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM142.4 642.1L298.7 519a8.84 8.84 0 0 0 0-13.9L142.4 381.9c-5.8-4.6-14.4-.5-14.4 6.9v246.3a8.9 8.9 0 0 0 14.4 7z"
      />
    </svg>
  </div>
</template>

<style module="classes" scoped>
.container {
  padding: 0 15px;
}
</style>

<style scoped>
.hamburger {
  display: inline-block;
  vertical-align: middle;
  width: 20px;
  height: 20px;
}

.is-active {
  transform: rotate(180deg);
}
</style>
```
在`src/layout/components/navbar.vue`文件中引入组件：
```
<script setup lang="ts">
import Hamburger from "./hamBurger/index.vue";
import { useStore } from 'vuex'
const store = useStore()
const sidebar = store.state.app.sidebar
function toggleSideBar() {
  store.dispatch("app/toggleSideBar")
}
</script>

<template>
  <div class="navbar">
      <Hamburger :is-active="sidebar.opened" class="hamburger-container" @toggleClick="toggleSideBar" />
  </div>
</template>

<style lang="scss" scoped>
.navbar {
  width: 100%;
  height: 48px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
}

</style>
```
新建`src/store/modules/app.ts`文件：
```
import { storageLocal } from "@/utils/storage";
import { Module } from 'vuex'

interface AppState {
    sidebar: {
      opened: boolean;
      withoutAnimation: boolean;
    };
}

const appModule: Module<AppState,any> = {
    namespaced: true,
    state: {
        sidebar:{
            opened:storageLocal.getItem("sidebarStatus")
            ? !!+storageLocal.getItem("sidebarStatus")
            : true,
            withoutAnimation:false
        }
    },
    mutations:{
        TOGGLE_SIDEBAR:(state)=> {
            state.sidebar.opened = !state.sidebar.opened;
            state.sidebar.withoutAnimation = false;
            if (state.sidebar.opened) {
              storageLocal.setItem("sidebarStatus", 1);
            } else {
              storageLocal.setItem("sidebarStatus", 0);
            }
        },
        CLOSE_SIDEBAR:(state,withoutAnimation: boolean)=> {
            storageLocal.setItem("sidebarStatus", 0);
            state.sidebar.opened = false;
            state.sidebar.withoutAnimation = withoutAnimation;
        },
    },
    actions: {
        toggleSideBar({commit}) {
            commit('TOGGLE_SIDEBAR');
        },
        closeSideBar({commit},{withoutAnimation}) {
            commit('CLOSE_SIDEBAR', withoutAnimation);
        },
    }
  };
  export default appModule
```
修改`src/layout/components/vertical.vue`文件：
```
<script setup lang="ts">
import Logo from "./logo/index.vue"
import SidebarItem from "./sidebarItem/index.vue";
import { useStore } from 'vuex'
import { computed } from "vue";
import { useRoute } from "vue-router";
const route = useRoute();
const store = useStore()
const menuList = store.state.routes.wholeRoutes
const isCollapse = computed(() => {
  return !store.state.app.sidebar.opened;
});
const activeMenu = computed((): string => {
  const { meta, path } = route;
  if (meta.activeMenu) {
    // @ts-ignore
    return meta.activeMenu;
  }
  return path;
});

</script>
<template>
  <div class="sidebar-container">
    <Logo />
    <el-scrollbar wrap-class="scrollbar-wrapper">
      <el-menu
        :default-active="activeMenu"
        :collapse="isCollapse"
        unique-opened
        router
        :collapse-transition="false"
        mode="vertical"
        class="outer-most"
      >
        <sidebar-item
          v-for="route in menuList"
          :key="route.path"
          :item="route"
          class="outer-most"
          :base-path="route.path"
        />
      </el-menu>
    </el-scrollbar>
  </div>
</template>

<style lang="scss" scoped>
</style>
```
此时折叠功能就算完成了，剩下的是通过样式控制折叠与展开的宽度，需要修改`src/layout/index.vue`文件：
```
<script setup lang="ts">
import navbar from "./components/navbar.vue";
import appMain from "./components/appMain.vue";
import Vertical from "./components/vertical.vue";
import tags from "./components/tags.vue";
import { useStore } from 'vuex'
const store = useStore()
import { computed } from "vue";
const sidebar = computed(() => {
  return store.state.app.sidebar;
});
</script>

<template>
  <div :class="['app-wrapper',sidebar.opened?'':'hideSidebar',sidebar.withoutAnimation?'withoutAnimation':'']">
    <!-- 侧边导航栏 -->
    <Vertical />
    <div class="main-container">
      <div class="fixed-header">
        <!-- 顶部导航栏 -->
        <navbar />
        <!-- 标签栏 -->
        <tags />
      </div>
      <!-- 主体内容 -->
      <app-main />
    </div>
  </div>
</template>


<style lang="scss" scoped>

</style>
```
并增加折叠状态的样式代码，`src/style/-layout.scss`文件中新增如下样式：
```
.hideSidebar {
    .fixed-header {
        left: 54px;
        transition: width 0.28s;
    }

    .sidebar-container {
        width: 54px !important;
    }

    .main-container {
        padding-left: 54px;
    }

    .submenu-title-noDropdown {
        padding: 0 !important;
        position: relative;

        .el-tooltip {
        padding: 0 !important;
        }
    }

    .el-sub-menu {
        overflow: hidden;

        & > .el-sub-menu__title {
        .el-sub-menu__icon-arrow {
            display: none;
        }
        }
    }

    // 菜单折叠
    .el-menu--collapse {
        margin-left: -5px;

        .el-sub-menu {
        & > .el-sub-menu__title {
            & > span {
            height: 0;
            width: 0;
            overflow: hidden;
            visibility: hidden;
            display: inline-block;
            }
        }
        }

        .submenu-title-noDropdown {
        background: transparent !important;
        }
    }
}
```
此时运行项目，折叠展开侧边导航的功能就完成了，样式的细节问题后期再做处理

# 面包屑功能添加
先增加组件代码：
```
# src/layout/components/breadCrumb/index.vue
<script setup lang="ts">
import { ref, watch } from "vue";
import { useRoute, useRouter, RouteLocationMatched } from "vue-router";

const levelList = ref([]);
const route = useRoute();
const router = useRouter();
// 判断当前路由是否是默认页
const isInitPage = (route: RouteLocationMatched): boolean | string => {
  const name = route && (route.name as string);
  if (!name) {
    return false;
  }
  return name.trim().toLocaleLowerCase() === "home".toLocaleLowerCase();
};
// 组装面包屑导航
const getBreadcrumb = (): void => {
  // 过滤当前导航的层级，只有meta存在，且title也存在，才会在面包屑中展示该层导航
  let matched = route.matched.filter(item => item.meta && item.meta.title);
  const first = matched[0];
  // 如果第一级不是默认页，则需要将默认页加在第一级
  if (!isInitPage(first)) {
    matched = [
      {
        path: "/",
        parentPath: "/",
        meta: { title: "首页" }
      } as unknown as RouteLocationMatched
    ].concat(matched);
  }
  // 组装后的面包屑导航进行过滤，meta存在、且title存在，且breadcrumb字段为真，才能展示在面包屑导航中
  levelList.value = matched.filter(
    item => item.meta && item.meta.title && item.meta.breadcrumb !== false
  );
};
// 执行组装面包屑导航方法
getBreadcrumb();
// vue3写法，监听路由变化，并获取当前面包屑导航
watch(
  () => route.path,
  () => getBreadcrumb()
);
// 面包屑导航路由跳转事件
const handleLink = (item: RouteLocationMatched): any => {
  const { redirect, path } = item;
  if (redirect) {
    router.push(redirect.toString());
    return;
  }
  router.push(path);
};
</script>

<template>
  <el-breadcrumb class="app-breadcrumb" separator="/">
    <transition-group appear name="breadcrumb">
      <el-breadcrumb-item v-for="(item, index) in levelList" :key="item.path">
        <span v-if="item.redirect === 'noRedirect' || index == levelList.length - 1" class="no-redirect">{{ item.meta.title }}</span>
        <a v-else @click.prevent="handleLink(item)"> {{ item.meta.title }}</a>
      </el-breadcrumb-item>
    </transition-group>
  </el-breadcrumb>
</template>

<style lang="scss" scoped>
.app-breadcrumb.el-breadcrumb {
  display: inline-block;
  font-size: 14px;
  line-height: 50px;

  .no-redirect {
    color: #97a8be;
    cursor: text;
  }
}
</style>
```
修改`src/layout/components/navbar.vue`文件：
```
<script setup lang="ts">
import Hamburger from "./hamBurger/index.vue";
import Breadcrumb from "./breadCrumb/index.vue";
import { useStore } from 'vuex'
const store = useStore()
const sidebar = store.state.app.sidebar
function toggleSideBar() {
  store.dispatch("app/toggleSideBar")
}
</script>

<template>
  <div class="navbar">
    <Hamburger :is-active="sidebar.opened" class="hamburger-container" @toggleClick="toggleSideBar" />
    <Breadcrumb class="breadcrumb-container" />
  </div>
</template>

<style lang="scss" scoped>
.navbar {
  width: 100%;
  height: 48px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
}
.hamburger-container {
    line-height: 48px;
    height: 100%;
    float: left;
    cursor: pointer;
    transition: background 0.3s;
    -webkit-tap-highlight-color: transparent;

    &:hover {
      background: rgba(0, 0, 0, 0.025);
    }
  }
</style>
```
此时，面包屑导航就已经添加成功了，点击侧边导航，面包屑也会相应的做出改变，不过这里还是有些问题，在`demo小样`这个路由时，面包屑导航上出现了重复的两层`demo小样`，这里将其去重，也很简单，我们在上面的面包屑导航获取的代码中，有过滤当前路由的操作，条件是`meta`存在，且`title`存在，且`breadcrumb`为真时，才会显示在面包屑导航上，所以，我们可以给不想显示的层级加`breadcrumb`字段，并设置值为`false`即可，或者直接将`title`字段删除也行。
```
# src/router/modules/demo.ts
import Layout from "@/layout/index.vue";

const router = {
  path: "/demo",
  name: "demoLayout",
  component: Layout,
  meta: {
    icon:'sgn-demo',
    title: "demo小样",
    isComponent:false,
    showLink: true,
    sort:2,
    breadcrumb:false,
  },
  children: [
    {
      path: "/demo",
      name: "demo",
      component: () => import("@/views/demo/index.vue"),
      meta: {
        title: "demo小样",
        showLink: true,
        sort:2,
        extraIcon:{
          svg:true,
          name:'sgn-new'
        }
      }
    }
  ]
};
export default router;
```
此时在点击`demo小样`导航，其路由就是正常的了，在面包屑导航的代码中，我们加了`transiton`组件，用来添加面包屑导航改变时的过渡效果，这里还需要加一些样式进行控制：
```
# src/style/-transiton.scss

/* fade */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.28s;
}

.fade-enter,
.fade-leave-active {
  opacity: 0;
}

/* fade-transform */
.fade-transform-leave-active,
.fade-transform-enter-active {
  transition: all 0.5s;
}

.fade-transform-enter-from {
  opacity: 0;
  transform: translateX(-30px);
}

.fade-transform-leave-to {
  opacity: 0;
  transform: translateX(30px);
}

/* breadcrumb transition */
.breadcrumb-enter-active,
.breadcrumb-leave-active {
  transition: all 0.5s;
}

.breadcrumb-enter-from,
.breadcrumb-leave-active {
  opacity: 0;
  transform: translateX(20px);
}

.breadcrumb-leave-active {
  position: absolute;
} 

```
```
# src/style/index.scc
@charset "UTF-8";
@import "./-settings.scss";
@import "./-public.scss";
@import "./-layout.scss";
@import "./-transition.scss";
.demo{
  color: $red;
}
```
运行项目，切换路由时，面包屑的改变就有了过渡动画，到此，面包屑导航功能就已经添加完毕

面包屑导航的默认页判断，这里是默认了首页，通过`home`去做的判断，如果项目中，根据权限，不同权限可能有不同的默认页，这就需要具体项目再在此基础上加逻辑进行判断了

# 用户信息展示、登录、退出登录功能完善
这里需要先将登录逻辑完善一下，登录后将获取到的用户信息以及`token`缓存到本地，登录成功跳转到默认页后，获取缓存中保存的用户信息，用来展示

修改`src/views/login/index.vue`文件，给用户名和密码一个默认值，以及登录事件的逻辑做一些修改：
```
const contextInfo: ContextProps = reactive({
  userName: "admin",
  passWord: "123456",
});
const toPage = (info: Object): void => {
  storageSession.setItem("userInfo", info);
  router.push("/");
};
// 登录
const onLogin = async () => {
  let { userName, passWord } = contextInfo;
  let { code, info,data, accessToken }: infoType = await getLogin({
    username: userName,
    password: passWord,
  });
  if(code==200){
    const userInfo:any = data;
    userInfo.accessToken = accessToken;
    successMessage(info)
    toPage(userInfo)
  }else{
    warnMessage(info);
  }
};
```
`infoType`是后端传给我们的字段的类型判断，在`src/views/login/type.ts`中进行了定义，这个可以根据后端返回的类型进行修改

这里调用了`getLogin`这个`api`，而`getLogin`这个`api`，目前走的是`mock`数据，我们需要在`/mock`文件夹下，新增`/login`接口：
```
# /mock/user.ts
import { MockMethod } from "vite-plugin-mock";

export default [
  {
    url: "/login",
    method: "post",
    response: () => {
      return {
        code: 200,
        info:"登录成功！",
        accessToken:"eyJhbGciOiJIUzUxMiJ9",
        data: {
          username:"admin",
          password:"123456"
        }
      };
    }
  }
] as MockMethod[];
```
这个时候，我们可以将`src/views/login/components/default/index.vue`文件中免密登录相关代码删除，这个之后就用不到了

再在`src/layout/components/navbar.vue`文件中加入用户信息展示、及退出登录功能，头像这里可以随便在百度找一张图片进行展示，真正和后端对接后，可直接使用后端返回的图片链接、用户信息：
```
<script setup lang="ts">
import avatars from "@/assets/avatars.jpg";
import { storageSession } from "@/utils/storage";
import Hamburger from "./hamBurger/index.vue";
import Breadcrumb from "./breadCrumb/index.vue";
import { useStore } from 'vuex'
import { useRouter } from "vue-router";
const store = useStore()
const router = useRouter();
const sidebar = store.state.app.sidebar
let userName = storageSession.getItem("userInfo")?.username;
function toggleSideBar() {
  store.dispatch("app/toggleSideBar")
}
// 退出登录
const logout = (): void => {
  storageSession.removeItem("userInfo");
  router.push("/login");
};
</script>

<template>
  <div class="navbar">
    <Hamburger :is-active="sidebar.opened" class="hamburger-container" @toggleClick="toggleSideBar" />
    <Breadcrumb class="breadcrumb-container" />
    <div class="vertical-header-right">
      <!-- 退出登陆 -->
      <el-dropdown trigger="click">
        <span class="el-dropdown-link">
          <img :src="avatars" />
          <p>{{ userName }}</p>
        </span>
        <template #dropdown>
          <el-dropdown-menu class="logout">
            <el-dropdown-item @click="logout"><i class="ri-logout-circle-r-line"></i>退出登录</el-dropdown-item>
          </el-dropdown-menu>
        </template>
      </el-dropdown>
    </div>
  </div>
</template>

<style lang="scss" scoped>
.navbar {
  width: 100%;
  height: 48px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
  .hamburger-container {
    line-height: 48px;
    height: 100%;
    float: left;
    cursor: pointer;
    transition: background 0.3s;
    -webkit-tap-highlight-color: transparent;
    &:hover {
      background: rgba(0, 0, 0, 0.025);
    }
  }
  .breadcrumb-container {
    float: left;
  }
  .vertical-header-right {
    display: flex;
    min-width: 280px;
    height: 48px;
    align-items: center;
    color: #000000d9;
    justify-content: flex-end;
    :deep(.dropdown-badge) {
      &:hover {
        background: #f6f6f6;
      }
    }
    .el-dropdown-link {
      width: 100px;
      height: 48px;
      padding: 10px;
      display: flex;
      align-items: center;
      justify-content: space-around;
      cursor: pointer;
      color: #000000d9;

      &:hover {
        background: #f6f6f6;
      }

      p {
        font-size: 14px;
      }

      img {
        width: 22px;
        height: 22px;
        border-radius: 50%;
      }
    }
  }
}
</style>
```
这里新增了`remixicon`图标库，需要进行安装：
```
yarn add remixicon
```
在`src/plugins/font-awesome/index.ts`文件中引入：
```
 import "remixicon/fonts/remixicon.css";
```
此时运行项目，通过用户名密码登录，已经能成功跳转，退出登录也能正常退出，只是此时还有路由问题存在，登录后路由并未加载，或者登录成功后，需要刷新一下，侧边导航才能正常显示，这里需要将导航守卫的逻辑修改一下：
```
# src/router/index.ts

router.beforeEach((to, _from, next) => {
  console.log(_from,"路由");
  const userInfo = storageSession.getItem("userInfo");
  NProgress.start();
  const externalLink = to?.redirectedFrom?.fullPath;
  // @ts-ignore
  if (!externalLink) to.meta.title ? (document.title = to.meta.title) : "";
  if (userInfo&&userInfo?.accessToken) {
    // 如果是从登录页面跳转的，或者name不存在（说明是浏览器刷新事件），则需要请求路由数据，再执行下一步
    if(_from?.path=="/login"||!_from?.name){
      if (store.state.routes.wholeRoutes.length === 0){
        initRouter().then((router: Router) => {
          router.push(to.path);
        });
      }
      next();
    }else{
      // 如果是其他页面跳转的，且其他页面的name存在，则直接进行下一步
      if (_from?.name) {
        // 如果路由包含http 则是超链接 反之是普通路由
        if (externalLink && externalLink.includes("http")) {
          openLink(`http${split(externalLink, "http")[1]}`);
          NProgress.done();
        } else {
          next();
        }
      }
    }
  } else {
    if (to.path !== "/login") {
      if (whiteList.indexOf(to.path) !== -1) {
        next();
      } else {
        next({ path: "/login" });
      }
    } else {
      next();
    }
  }
});
```
这里是判断，走导航守卫时，`_from`是`login`页面，或者当`_form.name`不存在的时候，都需要走初始化路由的逻辑，这样在登录后，页面跳转，就会先获取路由数据

此时运行项目，重新登录，侧边导航数据就能正常展示了

# 全屏功能组件
要使用全屏功能，需要先安装对应的插件:
```
yarn add @vueuse/core
```
然后新建全屏功能组件：
```
# src/layout/components/screenfull/index.vue
<script setup lang="ts">
import { useFullscreen } from "@vueuse/core";
import Icon from "@/components/Icon/src/Icon.vue";
const { isFullscreen, toggle } = useFullscreen();
</script>

<template>
  <div class="screen-full" @click="toggle" :title="isFullscreen? '退出全屏': '全屏'">
    <Icon :content="isFullscreen?'iconfont-quanpingsuoxiao':'iconfont-quanpingxianshi'" />
  </div>
</template>

<style lang="scss" scoped>
.screen-full {
  width: 36px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: space-around;
}
</style>
```
再在`src/layout/components/navbar.vue`文件中引入组件：
```
# js
import screenfull from "./screenfull/index.vue";

# template
<screenfull />

# style
.screen-full {
  cursor: pointer;
  &:hover {
    background: #f6f6f6;
  }
}
```
此时全屏功能组件就算完成了，运行项目，全屏功能已经可以正常使用

# 开发环境、生产环境配置
由于接下来需要增加国际化功能、项目配置功能（主题风格、主题色、标签栏、界面显示属性），这些需要用到静态数据的存储与调用，在开发环境与生产环境会有所区别，所以在接下来会先将开发环境、生产环境的配置做进一步的完善

## 新建环境配置文件
这里可以创建3个配置文件，开发环境、测试环境、生产环境配置文件，根目录下创建能被`node`读取的`.env.`开头的三个文件：
```
# .env.development 开发环境

# 项目本地运行端口号
VITE_PORT = 8848

# 开发环境读取配置文件路径
VITE_PUBLIC_PATH = /

# 开发环境代理
VITE_PROXY_DOMAIN = /api

# 开发环境后端地址
VITE_PROXY_DOMAIN_REAL = "http://127.0.0.1:3000"


# .env.staging 测试环境

# 测试环境项目打包路径
VITE_PUBLIC_PATH = /

# 测试环境后端地址
VITE_PROXY_DOMAIN_REAL = ""


# .env.production 生产环境

# 生产环境项目打包路径
VITE_PUBLIC_PATH = /

# 生产环境后端地址
VITE_PROXY_DOMAIN_REAL = ""
```
## 修改命令
配置完成后，再安装两个接下来需要用到的开发依赖插件：
```
yarn add cross-env rimraf -D
```
然后修改`package.json`文件中的命令：
```
"scripts": {
  "start": "cross-env vite --mode development",
  "stage": "rimraf stage && cross-env vite build --mode staging",
  "build": "rimraf dist && cross-env vite build --mode production",
  "serve": "vite preview"
},
```
此时执行`yarn start`命令，开发环境依然能正常运行，页面能正常显示

## 处理环境变量
三个环境变量配置文件的取值如何取，需要封装方法进行调用，以便在`vite.config.ts`中可以通过`mode`的具体值，调用不同的环境变量参数，在根目录创建`build`文件夹，并在其内新建`index.ts`文件：
```
// 处理环境变量
const warpperEnv = (envConf: Recordable): ViteEnv => {
  // 此处为默认值，无需修改
  const ret: ViteEnv = {
    VITE_PORT: 8848,
    VITE_OUTDIR: "",
    VITE_PUBLIC_PATH: "",
    VITE_PROXY_DOMAIN: "",
    VITE_PROXY_DOMAIN_REAL: ""
  };

  for (const envName of Object.keys(envConf)) {
    let realName = envConf[envName].replace(/\\n/g, "\n");
    realName =
      realName === "true" ? true : realName === "false" ? false : realName;

    if (envName === "VITE_PORT") {
      realName = Number(realName);
    }
    ret[envName] = realName;
    if (typeof realName === "string") {
      process.env[envName] = realName;
    } else if (typeof realName === "object") {
      process.env[envName] = JSON.stringify(realName);
    }
  }
  return ret;
};

// 跨域代理重写
const regExps = (value: string, reg: string): string => {
  return value.replace(new RegExp(reg, "g"), "");
};

// 环境变量
const loadEnv = (): ViteEnv => {
  return import.meta.env;
};

export { warpperEnv, regExps, loadEnv };
```
## 配置全局数据类型声明文件
在`types`文件夹下新建`global.d.ts`文件，用来定义全局的数据类型：
```
declare type Recordable<T = any> = Record<string, T>;
declare interface ImportMetaEnv extends ViteEnv {
  __: unknown;
}
declare interface ViteEnv {
  VITE_PORT: number;
  VITE_OUTDIR: string;
  VITE_PUBLIC_PATH: string;
  VITE_PROXY_DOMAIN: string;
  VITE_PROXY_DOMAIN_REAL: string;
}
```
然后在`tsconfig.json`文件中，将`build`文件加的文件加入到`include`参数中，在`paths`中加入路径修饰符：
```

"paths":{
  "@/*": ["src/*"],
  "^/*": ["build/*"],
  "#/*": ["types/*"]
},

"include": [
  "src/**/*.ts", 
  "build/*.ts", 
  "src/**/*.tsx", 
  "src/**/*.vue",
  "types/*.d.ts",
  "vite.config.ts"
],
```
此时`build/index.ts`文件中的数据类型报错都已经消失了

## 完善配置文件
这里用到一个新的开发依赖插件，用来获取本机IP：
```
yarn add ip -D
```
然后修改`vite.config.ts`文件：
```
import { UserConfigExport, ConfigEnv, loadEnv } from 'vite'
import vue from '@vitejs/plugin-vue'
import path from 'path'
import ip from 'ip';
import { warpperEnv, regExps } from "./build";
import ElementPlus from "unplugin-element-plus/vite";
import { svgBuilder } from './src/plugins/svgBuilder/index';
import { viteMockServe } from "vite-plugin-mock";
import svgLoader from "vite-svg-loader";

const ipStr = ip.address();
// 当前执行node命令时文件夹的地址（工作目录）
const root: string = process.cwd();
const resolve = (dir: string) => path.join(__dirname, dir)
// https://vitejs.dev/config/
export default ({ command, mode }: ConfigEnv): UserConfigExport => {
	const {
    VITE_PORT,
    VITE_OUTDIR,
    VITE_PUBLIC_PATH,
    VITE_PROXY_DOMAIN,
    VITE_PROXY_DOMAIN_REAL
  } = warpperEnv(loadEnv(mode, root));
	const prodMock = true;
	return {
		base:VITE_PUBLIC_PATH,
		root,
		// 开发服务
		server:{
			https:false,
			port:VITE_PORT,
			host:ipStr,
			// 本地跨域代理
			proxy:VITE_PROXY_DOMAIN_REAL.length>0?{
				[VITE_PROXY_DOMAIN]:{
					target:VITE_PROXY_DOMAIN_REAL,
					changeOrigin:true,
					rewrite:(path:string)=>regExps(path,VITE_PROXY_DOMAIN)
				}
			}:null,
			open:`http://${ipStr}:${VITE_PORT}`
		},
		build:{
			outDir:VITE_OUTDIR,
			sourcemap:false,
			brotliSize:false,
			// 消除打包大小超过500kb警告
			chunkSizeWarningLimit:2000,
		},
		plugins: [
			vue(),
			[svgBuilder('./src/assets/icons/svg/')],
			ElementPlus({}),
      svgLoader(),
			viteMockServe({
				mockPath: "./mock", // 模拟接口api文件存放的文件夹
				watchFiles: true, // 将监视文件夹中的文件更改。 并实时同步到请求结果
				localEnabled: command === "serve", // 设置是否启用本地 xxx.ts 文件，不要在生产环境中打开它.设置为 false 将禁用 mock 功能
				prodEnabled: command !== "serve" && prodMock, // 设置生产环境是否启用 mock 功能
				injectCode: `
					import { setupProdMockServer } from './mockProdServer';
					setupProdMockServer();
				`, // 如果生产环境开启了mock功能，该代码会注入到injectFile对应的文件的底部，默认为main.{ts,js}
				injectFile:path.resolve(process.cwd(),'src/main.{ts,js}'),
				logger: true
			})
		],
		resolve: {
			alias: {
				'@': resolve('src'),
        '#': resolve('types'),
        '^': resolve('build'),
				'vue':'vue/dist/vue.esm-bundler.js',
			}
		}
	}
}
```
此时配置文件的基础配置就算完成了

# 全局配置功能

#### 全局配置存储文件
要实现项目的主题风格、主题色、界面显示属性等项目配置功能，需要本地有一份全局配置文件，先在`public`文件夹下新建`serverConfig.json`文件：
```
{
  "Version": "1.0.0",
  "Title": "脚手架",
}
```
#### 全局配置文件的数据类型声明
在`types/global.d.ts`文件内，新增全局数据类型声明：
```
declare interface ServerConfigs {
  Version?: string;
  Title?: string;
}
```
#### 封装调用全局配置文件的方法
在`src`文件夹下新建`config`文件夹，并在其内新建`index.ts`文件：
```
import { App } from "vue";
import axios from "axios";
import { loadEnv } from "^/index";

let config: object = {};
const { VITE_PUBLIC_PATH } = loadEnv();

const setConfig = (cfg?: unknown) => {
  config = Object.assign(config, cfg);
};

const getConfig = (key?: string): ServerConfigs => {
  if (typeof key === "string") {
    const arr = key.split(".");
    if (arr && arr.length) {
      let data = config;
      arr.forEach(v => {
        if (data && typeof data[v] !== "undefined") {
          data = data[v];
        } else {
          data = null;
        }
      });
      return data;
    }
  }
  return config;
};

// 获取项目全局配置
export const getServerConfig = async (app: App): Promise<undefined> => {
  app.config.globalProperties.$config = getConfig();
  return axios({
    baseURL: "",
    method: "get",
    url: `${VITE_PUBLIC_PATH}serverConfig.json`
  })
    .then(({ data: config }) => {
      let $config = app.config.globalProperties.$config;
      // 自动注入项目配置
      if (app && $config && typeof config === "object") {
        $config = Object.assign($config, config);
        app.config.globalProperties.$config = $config;
        // 设置全局配置
        setConfig($config);
      }
      // 设置全局baseURL
      app.config.globalProperties.$baseUrl = $config.baseURL;
      return $config;
    })
    .catch(() => {
      throw "请在public文件夹下添加serverConfig.json配置文件";
    });
};
export { getConfig, setConfig };
```
#### 获取配置文件中的参数
配置文件的参数是为项目全局使用的，所以在获取时，可以在项目运行时就提前将配置文件中的参数获取出来，修改`src/main.ts`文件：
```
import { getServerConfig } from "./config";

getServerConfig(app).then(async config => {
  console.log(config,"全局配置")
  app.component('svg-icon', SvgIcon); // 全局注册svg图标组件
  app.use(router)
  app.use(store)
  app.use(useElementPlus)
  app.use(useFontAwesome);
  // 全局配置
  app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
  await router.isReady();
  app.mount('#app')
});
```
这里调用`getServerConfig`方法，将配置文件中的数据取出，并在该方法中，通过`setConfig`方法，将数据存储在`config`变量中，接下来就需要用`getConfig`方法获取具体参数
#### 局部调用全局配置
现在想在页面标题上除页面名称外，加上项目名称的后缀，这里首先需要将根目录下的`index.html`文件中的`title`改为项目名称，这个是项目运行时，还未加载具体页面时，要显示的内容，只能在文件内修改
```
# index.html
<title>脚手架</title>
```
接下来，具体页面加项目名称后缀，则可以在路由守卫中添加，修改`src/router/index.ts`文件：
```
import { getConfig } from "@/config";
# 路由守卫中修改以下代码，修改前：
if (!externalLink) to.meta.title ? (document.title = to.meta.title:"";
# 修改后：
if (!externalLink) to.meta.title ? (document.title = to.meta.title + " - " + getConfig().Title) : getConfig().Title;
```
此时运行项目，切换页面，页面的标题都已添加上了项目名称后缀，到这里全局配置功能框架就搭建完成了，接下来需要什么全局配置功能，在这个基础上进行修改即可


# 国际化功能
国际化功能默认中英文双语，国际化针对的是该系统本身的一些静态的数据，我们可以通过一些设置，将其国际化，而动态获取的数据，并非我们能考虑的，或者获取动态数据时，就提供相对应的国际化语种数据，而像我们项目中使用的`element-plus`等其他插件中的国际化，插件本身如果自带的有国际化功能，则也可以实现
#### 安装依赖插件
这里需要先下载相关的依赖插件：
```
yarn add vue-i18n
```
安装完成后，我们需要实现多组件库的国际化和本地项目国际化的集成，并在这里使用基于`vue3`的响应式本地存储，这就需要安装另一个依赖插件：
```
yarn add responsive-storage
```
#### 配置全局参数
修改`public/serverConfig.json`文件：
```
{
  "Version": "1.0.0",
  "Title": "脚手架",
  "Locale": "zh"
}
```
#### 配置全局数据类型声明文件
修改`types`文件夹下新建`types/global.d.ts`文件：
```
declare interface ServerConfigs {
  Version?: string;
  Title?: string;
  Locale?: string;
}
```
#### 响应式调用全局配置参数
在`src/utils/storage`文件夹下，新建`responsive.ts`文件：
```
// 响应式storage
import { App } from "vue";
import Storage from "responsive-storage";

export const injectResponsiveStorage = (app: App, config: ServerConfigs) => {
  const configObj = Object.assign(
    {
      // 国际化 默认中文zh
      locale: {
        type: Object,
        default: Storage.getData(undefined, "locale") ?? {
          locale: config.Locale ?? "zh"
        }
      },
    },
    {}
  );
  app.use(Storage, configObj);
};
```
#### 国际化集成插件
接下来需要先将本地项目国际化与多组件库的国际化集成到一块，在`src/plugins`文件夹下新建`i18n`文件夹，并在其内新建`config.ts`文件，以及`index.ts`文件：

`src/plugins/i18n/config.ts`文件内容：
```
// 菜单国际化配置

// element-plus国际化
import enLocale from "element-plus/lib/locale/lang/en";
import zhLocale from "element-plus/lib/locale/lang/zh-cn";

// 导航菜单配置
export const menusConfig = {
  zh: {
    message: {
      hshome: "首页",
      hsdemo: "测试页面",
      hserror: "错误页面",
      hsfourZeroFour: "404",
      hsfourZeroOne: "401",
      hsmenus: "多级菜单",
      hsmenu1: "菜单1",
      "hsmenu1-1": "菜单1-1",
      "hsmenu1-2": "菜单1-2",
      "hsmenu1-2-1": "菜单1-2-1",
      "hsmenu1-2-2": "菜单1-2-2",
      "hsmenu1-3": "菜单1-3",
      hsmenu2: "菜单2",
    }
  },
  en: {
    message: {
      hshome: "Home",
      hsdemo: "Demo Page",
      hserror: "Error Page",
      hsfourZeroFour: "404",
      hsfourZeroOne: "401",
      hsmenus: "MultiLevel Menu",
      hsmenu1: "Menu1",
      "hsmenu1-1": "Menu1-1",
      "hsmenu1-2": "Menu1-2",
      "hsmenu1-2-1": "Menu1-2-1",
      "hsmenu1-2-2": "Menu1-2-2",
      "hsmenu1-3": "Menu1-3",
      hsmenu2: "Menu2",
    }
  }
};

// 按钮配置
export const buttonConfig = {
  zh: {
    message: {
      hsLoginOut: "退出系统",
      hsfullscreen: "全屏",
      hsexitfullscreen: "退出全屏",
      hslogin: "登陆",
      hsunfold: "点击展开",
      hsfold: "点击折叠",
    }
  },
  en: {
    message: {
      hsLoginOut: "loginOut",
      hsfullscreen: "fullScreen",
      hsexitfullscreen: "exitFullscreen",
      hslogin: "login",
      hsunfold: "unfold",
      hsfold: "fold",
    }
  }
};

// 全局配置
export const settingsConfig = {
  zh: {
    message: {
      hsTitle:"脚手架"
    },
  },
  en: {
    message: {
      hsTitle:"scaffold"
    },
  },
};

const localesList = [menusConfig, buttonConfig, settingsConfig];

export const localesConfigs = {
  zh: {
    message: Object.assign({}, ...localesList.map(v => v.zh.message)),
    ...zhLocale
  },
  en: {
    message: Object.assign({}, ...localesList.map(v => v.en.message)),
    ...enLocale
  }
};
```
`src/plugins/i18n/index.ts`文件内容：
```
// 多组件库的国际化和本地项目国际化兼容
import { App } from "vue";
import { createI18n } from "vue-i18n";
import { localesConfigs } from "./config";
import { storageLocal } from "@/utils/storage";

export const i18n = createI18n({
  locale: storageLocal.getItem("responsive-locale")?.locale ?? "zh",
  fallbackLocale: "en",
  messages: localesConfigs
});

export function usI18n(app: App) {
  app.use(i18n);
}

/**
 * 国际化转换工具函数
 * @param message message
 * @param isI18n  如果true,获取对应的消息,否则返回本身
 * @returns message
 */
export function transformI18n(message: string | object = "", isI18n = false) {
  if (!message) {
    return "";
  }

  // 处理存储动态路由的title,格式 {zh:"",en:""}
  if (typeof message === "object") {
    return message[i18n.global?.locale];
  }

  if (isI18n) {
    //@ts-ignore
    return i18n.global.tc.call(i18n.global, message);
  } else {
    return message;
  }
}
```
#### 实例挂载国际化插件

修改`src/main.ts`文件：
```
import { createApp } from 'vue'
import router from './router'
import store from './store'
import App from './App.vue'
import { useElementPlus } from "@/plugins/element-plus"; // element-plus
import { useFontAwesome } from "@/plugins/font-awesome";
import SvgIcon from './components/SvgIcon/index.vue'
import { getServerConfig } from "./config";
import { usI18n } from "../src/plugins/i18n";
import { injectResponsiveStorage } from "@/utils/storage/responsive";

import '@/style/index.scss';
// 导入字体图标
import "@/assets/icons/iconfont/iconfont.js";
import "@/assets/icons/iconfont/iconfont.css";

const app = createApp(App)

getServerConfig(app).then(async config => {
  console.log(config,"全局配置")
  injectResponsiveStorage(app, config);
  app.component('svg-icon', SvgIcon); // 全局注册svg图标组件
  app.use(router)
  app.use(store)
  app.use(usI18n)
  app.use(useElementPlus)
  app.use(useFontAwesome);
  // 全局配置
  app.config.globalProperties.$ELEMENT = { size: 'small', zIndex: 3000 }
  await router.isReady();
  app.mount('#app')
});
```
修改`vite.config.ts`文件，在`plugins`同级添加如下代码：
```
plugins:[
  ...
],
# 新增代码
optimizeDeps: {
  include: [
    "element-plus/lib/locale/lang/zh-cn",
    "element-plus/lib/locale/lang/en",
  ],
},
```
#### 静态路由菜单国际化
将所有静态路由模块中的`title`字段的值修改为`src/plugins/i18n/config.ts`文件`menusConfig`变量中的每个对象的`key`

修改`src/layout/components/sidebarItem/index.vue`文件：
```
# setup语法糖script标签内增加如下代码
import { transformI18n } from "@/plugins/i18n";

# 找到template模板代码中的onlyOneChild.meta.title，以及props.item.meta.title

将onlyOneChild.meta.title 替换为 transformI18n(onlyOneChild.meta.title, onlyOneChild.meta.i18n)

将props.item.meta.title 替换为 transformI18n(props.item.meta.title, props.item.meta.i18n)
```

静态路由的`meta`中新增了`i18n`这个参数，所以需要在数据类型声明文件中，加入对应的数据声明，修改`src/layout/types.ts`文件：
```
export type childrenType = {
  path?: string;
  noShowingChildren?: boolean;
  children?: childrenType[];
  value: unknown;
  meta?: {
    icon?: string;
    isComponent?:boolean;
    i18n?:boolean,
    title?: string;
    extraIcon?: {
      svg?: boolean;
      name?: string;
    };
  };
  showTooltip?: boolean;
};
```
此时再运行项目，侧边导航菜单的显示就正常了，但是页面标题和面包屑还不正常

修改`src/layout/components/breadCrumb/index.vue`文件：
```
import { transformI18n } from "@/plugins/i18n";

// 组装面包屑导航
const getBreadcrumb = (): void => {
  // 过滤当前导航的层级，只有meta存在，且title也存在，才会在面包屑中展示该层导航
  let matched = route.matched.filter(item => item.meta && item.meta.title);
  const first = matched[0];
  // 如果第一级不是默认页，则需要将默认页加在第一级
  if (!isInitPage(first)) {
    matched = [
      {
        path: "/",
        parentPath: "/",
        meta: { title: "message.hshome", i18n: true }
      } as unknown as RouteLocationMatched
    ].concat(matched);
  }
  // 组装后的面包屑导航进行过滤，meta存在、且title存在，且breadcrumb字段为真，才能展示在面包屑导航中
  levelList.value = matched.filter(
    item => item.meta && item.meta.title && item.meta.breadcrumb !== false
  );
};

将 item.meta.title 替换为 transformI18n(item.meta.title, item.meta.i18n)
```
修改`src/router/index.ts`文件中的导航守卫：
```
import { transformI18n } from "@/plugins/i18n";

# 导航守卫中代码修改
if (!externalLink){
  if(to.meta.title){
    document.title = transformI18n(to.meta.title as string,to.meta.i18n as boolean) + " - " + transformI18n(getConfig().Title as string,true)
  }else{
    document.title = transformI18n(getConfig().Title as string,true)
  }
};
```
修改`public/serverConfig.json`文件：
```
"Title": "脚手架",

替换为

"Title": "message.hsTitle",
```
此时再次运行项目，菜单相关的国际化就全部完成了

#### 按钮国际化
以上已实现目前项目的菜单和全局配置的国际化，按钮的国际化也是同样套路，暂时可以先将折叠功能按钮，以及全屏功能按钮、登录按钮、退出登录按钮的提示文案进行国际化

修改`src/layout/components/hamBurger/index.vue`文件：
```
:title="props.isActive ? '点击折叠' : '点击展开'"

替换为

:title="props.isActive ? $t('message.hsfold') : $t('message.hsunfold')"
```

修改`src/layout/components/screenfull/index.vue`文件：
```
:title="isFullscreen? '退出全屏': '全屏'"

替换为

:title="isFullscreen? $t('message.hsexitfullscreen') : $t('message.hsfullscreen')"
```

修改`src/layout/components/navbar.vue`文件：
```
<el-dropdown-item @click="logout"><i class="ri-logout-circle-r-line"></i>退出登录</el-dropdown-item>

替换为

<el-dropdown-item @click="logout"><i class="ri-logout-circle-r-line"></i>{{$t("message.hsLoginOut")}}</el-dropdown-item>
```
登录页面的国际化，需要包括`placeholder`以及用户名、密码验证文案，所以这里需要在`src/plugins/i18n/config.ts`文件中加入登录验证相关的国际化文案：
```

// 登录验证配置
export const loginConfig = {
  zh: {
    message: {
      hsUsernamePlaceholder: "请输入用户名",
      hsPasswordPlaceholder: "请输入密码",
      hsPasswordRequired: "密码长度必须不小于6位",
    }
  },
  en: {
    message: {
      hsUsernamePlaceholder: "Please enter user name",
      hsPasswordPlaceholder: "Please enter the password",
      hsPasswordRequired: "Password length must not be less than 6 digits",
    }
  }
};

const localesList = [menusConfig, buttonConfig, settingsConfig,loginConfig];
```
修改`src/views/login/components/default/index.vue`文件：
```
<script setup lang="ts">
import { ref, PropType, getCurrentInstance, toRef } from "vue";
import { useRouter } from "vue-router";
import { transformI18n } from "@/plugins/i18n";

export interface ContextProps {
  userName: string;
  passWord: string;
}

const props = defineProps({
  ruleForm: {
    type: Object as PropType<ContextProps>
  }
});

const emit = defineEmits<{
  (e: "onBehavior", evt: Object): void;
}>();

const instance = getCurrentInstance();

const model = toRef(props, "ruleForm");

const router = useRouter();

const rules = ref<any>({
  userName: [{ required: true, message: transformI18n('message.hsUsernamePlaceholder', true), trigger: "blur" }],
  passWord: [
    { required: true, message: transformI18n('message.hsPasswordPlaceholder', true), trigger: "blur" },
    { min: 6, message: transformI18n('message.hsPasswordRequired', true), trigger: "blur" }
  ],
});

// 点击登录
const onBehavior = (evt: Object): void => {
  // @ts-expect-error
  instance.refs.ruleForm.validate((valid: boolean) => {
    if (valid) {
      emit("onBehavior", evt);
    } else {
      return false;
    }
  });
};
</script>

<template>
  <div class="info">
    <el-form :model="model" :rules="rules" ref="ruleForm" class="rule-form">
      <el-form-item prop="userName">
        <el-input
          clearable
          v-model="model.userName"
          :placeholder="$t('message.hsUsernamePlaceholder')"
          prefix-icon="el-icon-user"
        ></el-input>
      </el-form-item>
      <el-form-item prop="passWord">
        <el-input
          clearable
          type="password"
          show-password
          v-model="model.passWord"
          :placeholder="$t('message.hsPasswordPlaceholder')"
          prefix-icon="el-icon-lock"
        ></el-input>
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click.prevent="onBehavior">{{$t("message.hslogin")}}</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<style lang="scss" scoped>
.info {
  width: 30vw;
  height: 48vh;
  background: url("@/assets/login.png") no-repeat center;
  background-size: cover;
  position: absolute;
  border-radius: 20px;
  right: 100px;
  top: 30vh;
  display: flex;
  justify-content: center;
  align-items: center;
  @media screen and (max-width: 750px) {
    width: 88vw;
    right: 25px;
    top: 22vh;
  }

  .rule-form {
    width: 80%;

    .verify {
      position: absolute;
      margin: -10px 0 0 -120px;

      &:hover {
        cursor: pointer;
      }
    }

    .tips {
      color: #409eff;
      float: right;

      &:hover {
        cursor: pointer;
      }
    }
  }

  .secret {
    color: #409eff;

    &:hover {
      cursor: pointer;
    }
  }
}
</style>
```
运行项目，所有国际化的地方，依然能正常显示，则说明国际化加入已完成，以上代码中有些地方的国际化使用的`$t()`是`vue-i18n`中暴露的一个方法，可直接使用

接下来需要添加国际化切换功能组件

#### 国际化切换功能组件添加
修改`src/layout/components/navbar.vue`文件：
```
<script setup lang="ts">
import { useI18n } from "vue-i18n";
import avatars from "@/assets/avatars.jpg";
import { storageSession } from "@/utils/storage";
import Hamburger from "./hamBurger/index.vue";
import Breadcrumb from "./breadCrumb/index.vue";
import screenfull from "./screenfull/index.vue";
import Icon from "@/components/Icon/src/Icon.vue";
import { unref, watch, getCurrentInstance } from "vue";
import { transformI18n } from "@/plugins/i18n";
import { getConfig } from "@/config";
import { useStore } from 'vuex'
import { useRouter, useRoute } from "vue-router";
const { locale } = useI18n();
const instance = getCurrentInstance().appContext.config.globalProperties.$storage;
const store = useStore()
const router = useRouter();
const route = useRoute();
const sidebar = store.state.app.sidebar
let userName = storageSession.getItem("userInfo")?.username;
function toggleSideBar() {
  store.dispatch("app/toggleSideBar")
}
// 退出登录
const logout = (): void => {
  storageSession.removeItem("userInfo");
  router.push("/login");
};

watch(
  () => locale.value,
  () => {
    //@ts-ignore
    document.title = transformI18n(unref(route.meta.title),unref(route.meta.i18n)) + " - " + transformI18n(getConfig().Title as string,true); // 动态title
  }
);

// 简体中文
function translationCh() {
  instance.locale = { locale: "zh" };
  locale.value = "zh";
}

// English
function translationEn() {
  instance.locale = { locale: "en" };
  locale.value = "en";
}
</script>

<template>
  <div class="navbar">
    <Hamburger :is-active="sidebar.opened" class="hamburger-container" @toggleClick="toggleSideBar" />
    <Breadcrumb class="breadcrumb-container" />
    <div class="vertical-header-right">
      <!-- 全屏 -->
      <screenfull />
      <!-- 国际化 -->
      <el-dropdown trigger="click">
        <el-icon class="globalization"><Icon :svg="true" :content="'sgn-translate'"/></el-icon>
        <template #dropdown>
          <el-dropdown-menu class="translation">
            <el-dropdown-item :style="{background: locale === 'zh' ? '#1b2a47' : '',color: locale === 'zh' ? '#f4f4f5' : '#000'}" @click="translationCh">
              <el-icon class="check-zh" v-show="locale === 'zh'"><check /></el-icon>简体中文
            </el-dropdown-item>
            <el-dropdown-item :style="{ background: locale === 'en' ? '#1b2a47' : '', color: locale === 'en' ? '#f4f4f5' : '#000' }" @click="translationEn">
              <el-icon class="check-en" v-show="locale === 'en'"><check /></el-icon>English
            </el-dropdown-item>
          </el-dropdown-menu>
        </template>
      </el-dropdown>
      <!-- 退出登陆 -->
      <el-dropdown trigger="click">
        <span class="el-dropdown-link">
          <img :src="avatars" />
          <p>{{ userName }}</p>
        </span>
        <template #dropdown>
          <el-dropdown-menu class="logout">
            <el-dropdown-item @click="logout"><i class="ri-logout-circle-r-line"></i>{{$t("message.hsLoginOut")}}</el-dropdown-item>
          </el-dropdown-menu>
        </template>
      </el-dropdown>
    </div>
  </div>
</template>

<style lang="scss" scoped>
.navbar {
  width: 100%;
  height: 48px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 1px 4px rgba(0, 21, 41, 0.08);
  .hamburger-container {
    line-height: 48px;
    height: 100%;
    float: left;
    cursor: pointer;
    transition: background 0.3s;
    -webkit-tap-highlight-color: transparent;
    &:hover {
      background: rgba(0, 0, 0, 0.025);
    }
  }
  .breadcrumb-container {
    float: left;
  }
  .vertical-header-right {
    display: flex;
    min-width: 280px;
    height: 48px;
    align-items: center;
    color: #000000d9;
    justify-content: flex-end;
    :deep(.dropdown-badge) {
      &:hover {
        background: #f6f6f6;
      }
    }
    .screen-full {
      cursor: pointer;
      &:hover {
        background: #f6f6f6;
      }
    }
    .globalization {
      height: 48px;
      width: 40px;
      padding: 11px;
      cursor: pointer;

      &:hover {
        background: #f6f6f6;
      }
    }
    .el-dropdown-link {
      width: 100px;
      height: 48px;
      padding: 10px;
      display: flex;
      align-items: center;
      justify-content: space-around;
      cursor: pointer;
      color: #000000d9;

      &:hover {
        background: #f6f6f6;
      }

      p {
        font-size: 14px;
      }

      img {
        width: 22px;
        height: 22px;
        border-radius: 50%;
      }
    }
  }
}
</style>
```
此时运行项目，点击国际化切换组件，所有已添加国际化功能的地方均已能正常切换，这里需要说明一点的是，菜单导航中，设置这个动态获取的菜单，并未做国际化转化，这是因为，动态获取的数据，是后端数据库中存储的数据，如果项目本身的数据都不支持国际化，那么国际化功能不加也无所谓，数据库中的数据如果有国际化数据，则只需要在数据展示的地方做一个判断即可，当前是哪种语言就显示哪种语言的后端返回的数据字段即可

图片如果需要做国际化，那需要针对语言分别做图片，并根据缓存获取到的当前语言，显示对应图片即可

此时项目本身的国际化功能已完成，插件`element-plus`的国际化还未正常显示，首页在之前添加的日期插件，切换国际化，并未发生变化，`element-plus`默认是英语语种，而`element-plus`的国际化需要做一些额外的修改

#### element-plus国际化

修改`App.vue`文件：
```
<script lang="ts">
import { ElConfigProvider } from "element-plus";
import zhCn from "element-plus/lib/locale/lang/zh-cn";
import en from "element-plus/lib/locale/lang/en";
export default {
  name: "app",
  components: {
    [ElConfigProvider.name]: ElConfigProvider
  },
  computed: {
    currentLocale() {
      return this.$storage.locale?.locale === "zh" ? zhCn : en;
    }
  }
};
</script>

<template>
  <el-config-provider :locale="currentLocale">
    <router-view />
  </el-config-provider>
</template>
```
此时再运行项目，看选择日期的年月日，已可以做到国际化切换，`placeholder`的文案，需要在`src/plugins/i18n/config.ts`文件中添加：
```
// 表单占位文案配置
export const placeholderConfig = {
  zh: {
    message: {
      hsDatePlaceholder: "选择日期",
    }
  },
  en: {
    message: {
      hsDatePlaceholder: "Pick a day",
    }
  }
};

const localesList = [menusConfig, buttonConfig, settingsConfig,loginConfig,placeholderConfig];
```
修改`src/views/home/index.vue`文件中日期插件的`placeholder`：
```
<el-date-picker v-model="value1" type="date" :placeholder="$t('message.hsDatePlaceholder')"></el-date-picker>
```
再次运行项目，国际化切换已经可以让`element-plus`也同时进行转换了，到此，项目的国际化功能就算完善了
#### index.html文件中的title国际化
最后剩下`index.html`在初次运行，以及刷新加载时，标题显示为默认`title`，这个如果要控制，需要修改`index.html`文件：
```
<title></title>
<script>
  var lang = JSON.parse(localStorage.getItem("responsive-locale"));
  if(lang.locale=="en"){
    document.title = "scaffold";
  }else{
    document.title = "脚手架";
  }
</script>
```
此时再运行项目，国际化功能就算完整的考虑到所有场景了

# 项目配置功能组件
这里用到了一个新的插件-总线事务`mitt`插件：
```
yarn add mitt
```
然后封装一个自定义总线事物文件：`src/utils/mitt.ts`:
```
import type { Emitter } from "mitt";
import mitt from "mitt";

type Events = {};

export const emitter: Emitter<Events> = mitt<Events>();
```
`Events`中存储接下来会用到的一些总线事务的数据类型
#### 项目配置按钮
先添加一个控制项目配置弹层的控制按钮，修改`src/layout/components/navbar.vue`文件：
```
<el-icon class="settings" :title="$t('message.hssystemSet')" @click="onPanel">
  <Icon :svg="true" :content="'icon-xitong'"/>
</el-icon>

.settings {
  height: 48px;
  width: 38px;
  padding: 12px;
  display: flex;
  cursor: pointer;
  align-items: center;

  &:hover {
    background: #f6f6f6;
  }
}
```
修改`src/plugins/i18n/config.ts`文件，在按钮配置中，添加该按钮的国际化文案：
```
# zh.message
hssystemSet: "打开项目配置",

# en.message
hssystemSet: "Open ProjectConfig",
```
添加点击事件`onPanel`:
```
function onPanel() {
  emitter.emit("openPanel");
}
```
这里调用了事务插件，并声明了一个`openPanel`事务，需要引入封装好的事物插件：
```
import { emitter } from "@/utils/mitt";
```
在事务插件中加入`openPanel`的事务数据类型声明，修改`src/utils/mitt.ts`文件：
```
type Events = {
  openPanel:string;
};
```
#### 项目配置弹层
在`src/layout/components`文件夹下，新建`settings`项目配置弹层组件文件夹，在其内新建`panel.vue`和`index.vue`文件：

`panel.vue`文件内容：
```
<script setup lang="ts">
import { ref } from "vue";
import { onClickOutside } from "@vueuse/core";
import { emitter } from "@/utils/mitt";

let show = ref<Boolean>(false);
const target = ref(null);
onClickOutside(target, event => {
  if (event.clientX > target.value.offsetLeft) return;
  show.value = false;
});

emitter.on("openPanel", () => {
  show.value = true;
});
</script>

<template>
  <div :class="{ show: show }" class="right-panel-container">
    <div class="right-panel-background" />
    <div ref="target" class="right-panel">
      <div class="right-panel-items">
        <div class="project-configuration">
          <h3>{{$t("message.hsSettingPanelTitle")}}</h3>
          <el-icon :title="$t('message.hsCloseSettingPanel')" class="icon-close" @click="show = !show">
            <Close />
          </el-icon>
        </div>
        <div style="border-bottom: 1px solid #dcdfe6"></div>
        <slot />
      </div>
    </div>
  </div>
</template>

<style>
.showright-panel {
  overflow: hidden;
  position: relative;
  width: calc(100% - 15px);
}
</style>

<style lang="scss" scoped>
.right-panel-background {
  position: fixed;
  top: 0;
  left: 0;
  opacity: 0;
  transition: opacity 0.3s cubic-bezier(0.7, 0.3, 0.1, 1);
  background: rgba(0, 0, 0, 0.2);
  z-index: -1;
}

.right-panel {
  width: 100%;
  max-width: 300px;
  height: 100vh;
  position: fixed;
  top: 0;
  right: 0;
  box-shadow: 0 0 15px 0 rgba(0, 0, 0, 0.05);
  transition: all 0.25s cubic-bezier(0.7, 0.3, 0.1, 1);
  transform: translate(100%);
  background: #fff;
  z-index: 40000;
}

.show {
  transition: all 0.3s cubic-bezier(0.7, 0.3, 0.1, 1);

  .right-panel-background {
    z-index: 20000;
    opacity: 1;
    width: 100%;
    height: 100%;
  }

  .right-panel {
    transform: translate(0);
  }
}

.handle-button {
  width: 48px;
  height: 48px;
  position: absolute;
  left: -48px;
  text-align: center;
  font-size: 24px;
  border-radius: 6px 0 0 6px !important;
  z-index: 0;
  pointer-events: auto;
  cursor: pointer;
  color: #fff;
  line-height: 48px;
  top: 45%;
  background: rgb(24, 144, 255);

  i {
    font-size: 24px;
    line-height: 48px;
  }
}

.right-panel-items {
  margin-top: 60px;
  height: 100vh;
  overflow: auto;
}

.project-configuration {
  display: flex;
  width: 100%;
  height: 30px;
  position: fixed;
  justify-content: space-between;
  align-items: center;
  top: 15px;
  margin-left: 10px;

  i {
    font-size: 20px;
    margin-right: 20px;

    &:hover {
      cursor: pointer;
      color: red;
    }
  }
}

:deep(.el-divider--horizontal) {
  width: 90%;
  margin: 20px auto 0 auto;
}
</style>
```
`index.vue`文件内容：
```
<script setup lang="ts">
import { useRouter } from "vue-router";
import { storageLocal, storageSession } from "@/utils/storage";
const router = useRouter();
import panel from "./panel.vue";
// 清空缓存并返回登录页
function onReset() {
  storageLocal.clear();
  storageSession.clear();
  router.push("/login");
}
</script>

<template>
  <panel>
    <el-divider />
    <el-button type="danger" style="width: 90%; margin: 24px 15px" @click="onReset"><i class="fa fa-sign-out"></i>{{$t("message.hsClearCookieBackLogin")}}</el-button>
  </panel>
</template>

<style lang="scss" scoped>
:deep(.el-divider__text) {
  font-size: 16px;
  font-weight: 700;
}
</style>
```
修改`src/plugins/i18n/config.ts`文件中的全局配置部分：
```
// 全局配置
export const settingsConfig = {
  zh: {
    message: {
      hsTitle:"脚手架",
      hsSettingPanelTitle:"项目配置",
      hsCloseSettingPanel:"关闭配置",
      hsClearCookieBackLogin:"清空缓存并返回登录页",
    },
  },
  en: {
    message: {
      hsTitle:"Scaffold",
      hsSettingPanelTitle:"Project config",
      hsCloseSettingPanel:"Close",
      hsClearCookieBackLogin:"Clear cache and return to login",
    },
  },
};
```
在`src/layout/index.vue`文件中引入项目配置弹层组件：
```
<script setup lang="ts">
import navbar from "./components/navbar.vue";
import appMain from "./components/appMain.vue";
import setting from "./components/settings/index.vue";
import Vertical from "./components/vertical.vue";
import tags from "./components/tags.vue";
import { useStore } from 'vuex'
const store = useStore()
import { computed } from "vue";
const sidebar = computed(() => {
  return store.state.app.sidebar;
});
</script>

<template>
  <div :class="['app-wrapper',sidebar.opened?'':'hideSidebar',sidebar.withoutAnimation?'withoutAnimation':'']">
    <!-- 侧边导航栏 -->
    <Vertical />
    <div class="main-container">
      <div class="fixed-header">
        <!-- 顶部导航栏 -->
        <navbar />
        <!-- 标签栏 -->
        <tags />
      </div>
      <!-- 主体内容 -->
      <app-main />
    </div>
    <!-- 系统设置 -->
    <setting />
  </div>
</template>
<style lang="scss" scoped>
</style>
```
此时运行项目，项目配置弹层的组件可以正常打开关闭，国际化也显示正常，接下来就是加入具体的项目配置
## 界面显示
关于界面显示的功能，先增加灰色模式、色弱模式、侧边栏logo显示隐藏功能，相对应的每个功能都需要有一个字段参数去控制

需要在`public/serverConfig.json`文件中新增具体字段参数：
```
{
  "Version": "1.0.0",
  "Title": "message.hsTitle",
  "Locale": "zh",
  "Grey": false,
  "Weak": false,
  "SidebarLogo": true
}
```
需要在`types/global.d.ts`文件中新增字段参数的数据类型声明：
```
declare interface ServerConfigs {
  Version?: string;
  Title?: string;
  Locale?: string;
  Grey?: boolean,
  Weak?: boolean,
  SidebarLogo?:boolean
}
```

需要在`src/utils/storage/responsive.ts`文件增加响应式缓存设置：
```
// 国际化 默认中文zh
locale: {
  type: Object,
  default: Storage.getData(undefined, "locale") ?? {
    locale: config.Locale ?? "zh"
  }
},
sets: {
  type: Object,
  default: Storage.getData(undefined, "sets") ?? {
    grey: config.Grey ?? false,
    weak: config.Weak ?? false,
    sidebarLogo: config.SidebarLogo ?? true,
  }
}
```
字段参数设置完成后，修改`src/layout/components/settings/index.vue`文件：
```
<script setup lang="ts">
import { reactive,getCurrentInstance,nextTick } from "vue";
import { useRouter } from "vue-router";
import { toggleClass } from "@/utils/operate";
import { storageLocal, storageSession } from "@/utils/storage";
import { emitter } from "@/utils/mitt";
const router = useRouter();
import panel from "./panel.vue";
const instance = getCurrentInstance().appContext.app.config.globalProperties.$storage;
const settings = reactive({
  greyVal: instance.sets.grey,
  weakVal: instance.sets.weak,
  logoVal: instance.sets.sidebarLogo,
});
// 清空缓存并返回登录页
function onReset() {
  storageLocal.clear();
  storageSession.clear();
  toggleClass(false, "html-grey", document.querySelector("html"));
  toggleClass(false, "html-weakness", document.querySelector("html"));
  router.push("/login");
}

//初始化项目配置
nextTick(() => {
  settings.greyVal &&
    document.querySelector("html")?.setAttribute("class", "html-grey");
  settings.weakVal &&
    document.querySelector("html")?.setAttribute("class", "html-weakness");
});

// 灰色模式设置
const greyChange = (value): void => {
  toggleClass(settings.greyVal, "html-grey", document.querySelector("html"));
  instance.sets = {
    grey: value,
    weak: instance.sets.weak,
    sidebarLogo: instance.sets.sidebarLogo,
  };
};

// 色弱模式设置
const weekChange = (value): void => {
  toggleClass(settings.weakVal,"html-weakness",document.querySelector("html"));
  instance.sets = {
    grey: instance.sets.grey,
    weak: value,
    sidebarLogo: instance.sets.sidebarLogo,
  };
};

// 侧边栏Logo
const logoChange = (value): void => {
  emitter.emit("logoChange", value);
  instance.sets = {
    grey: instance.sets.grey,
    weak: instance.sets.weak,
    sidebarLogo: value,
  };
}

</script>

<template>
  <panel>
    <el-divider>{{$t("message.hsInterfaceTitle")}}</el-divider>
    <ul class="setting">
      <li>
        <span>{{$t("message.hsGreyTitle")}}</span>
        <el-switch
          v-model="settings.greyVal"
          :inline-prompt="true"
          inactive-color="#a6a6a6"
          :active-text="$t('message.hsSwitchOn')"
          :inactive-text="$t('message.hsSwitchOff')"
          @change="greyChange"
        >
        </el-switch>
      </li>
      <li>
        <span>{{$t("message.hsColorWeaknessTitle")}}</span>
        <el-switch
          v-model="settings.weakVal"
          :inline-prompt="true"
          inactive-color="#a6a6a6"
          :active-text="$t('message.hsSwitchOn')"
          :inactive-text="$t('message.hsSwitchOff')"
          @change="weekChange"
        >
        </el-switch>
      </li>
      <li>
        <span>{{$t("message.hsSidebarLogoTitle")}}</span>
        <el-switch
          v-model="settings.logoVal"
          :inline-prompt="true"
          inactive-color="#a6a6a6"
          :active-text="$t('message.hsSwitchOn')"
          :inactive-text="$t('message.hsSwitchOff')"
          @change="logoChange"
        >
        </el-switch>
      </li>
    </ul>
    <el-divider />
    <el-button type="danger" style="width: 90%; margin: 24px 15px" @click="onReset"><i class="fa fa-sign-out"></i>{{$t("message.hsClearCookieBackLogin")}}</el-button>
  </panel>
</template>

<style lang="scss" scoped>
:deep(.el-divider__text) {
  font-size: 16px;
  font-weight: 700;
  white-space: nowrap;
}
.setting {
  width: 100%;

  li {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 25px;
  }
}
</style>
```
新增代码中使用了新的封装方法`toggleClass`，在`src/utils`文件夹下，新建`operate`文件夹，其内新建`index.ts`文件：
```
export const hasClass = (ele: RefType<any>, cls: string): any => {
  return !!ele.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"));
};
export const addClass = (
  ele: RefType<any>,
  cls: string,
  extracls?: string
): any => {
  if (!hasClass(ele, cls)) ele.className += " " + cls;
  if (extracls) {
    if (!hasClass(ele, extracls)) ele.className += " " + extracls;
  }
};
export const removeClass = (
  ele: RefType<any>,
  cls: string,
  extracls?: string
): any => {
  if (hasClass(ele, cls)) {
    const reg = new RegExp("(\\s|^)" + cls + "(\\s|$)");
    ele.className = ele.className.replace(reg, " ").trim();
  }
  if (extracls) {
    if (hasClass(ele, extracls)) {
      const regs = new RegExp("(\\s|^)" + extracls + "(\\s|$)");
      ele.className = ele.className.replace(regs, " ").trim();
    }
  }
};
export const toggleClass = (
  flag: boolean,
  clsName: string,
  target?: RefType<any>
): any => {
  const targetEl = target || document.body;
  let { className } = targetEl;
  className = className.replace(clsName, "");
  targetEl.className = flag ? `${className} ${clsName} ` : className;
};
```
在`types`文件夹下新建`index.d.ts`文件:
```
declare type RefType<T> = T | null;
```
`src/plugins/i18n/config.ts`文件中添加对应的国际化文案：
```
// 按钮配置
export const buttonConfig = {
  zh: {
    message: {
      hsLoginOut: "退出系统",
      hsfullscreen: "全屏",
      hsexitfullscreen: "退出全屏",
      hslogin: "登陆",
      hsunfold: "点击展开",
      hsfold: "点击折叠",
      hssystemSet: "打开项目配置",
      hsSwitchOn:"开",
      hsSwitchOff:"关",
    }
  },
  en: {
    message: {
      hsLoginOut: "loginOut",
      hsfullscreen: "fullScreen",
      hsexitfullscreen: "exitFullscreen",
      hslogin: "login",
      hsunfold: "unfold",
      hsfold: "fold",
      hssystemSet: "Open ProjectConfig",
      hsSwitchOn:"Y",
      hsSwitchOff:"N",
    }
  }
};

// 全局配置
export const settingsConfig = {
  zh: {
    message: {
      hsTitle:"脚手架",
      hsSettingPanelTitle:"项目配置",
      hsCloseSettingPanel:"关闭配置",
      hsInterfaceTitle:"界面显示",
      hsGreyTitle:"灰色模式",
      hsColorWeaknessTitle:"色弱模式",
      hsSidebarLogoTitle:"侧边栏Logo",
      hsClearCookieBackLogin:"清空缓存并返回登录页",
    },
  },
  en: {
    message: {
      hsTitle:"Scaffold",
      hsSettingPanelTitle:"Project config",
      hsCloseSettingPanel:"Close",
      hsInterfaceTitle:"Interface show",
      hsGreyTitle:"Grey mode",
      hsColorWeaknessTitle:"Color weakness mode",
      hsSidebarLogoTitle:"Sidebar logo",
      hsClearCookieBackLogin:"Clear cache and return to login",
    },
  },
};
```
这里侧边栏LOGO改变事件中新增了一个总线事务，需要在`src/utils/mitt.ts`中，加入新的总线事务的数据类型声明：
```
type Events = {
  openPanel:string;
  logoChange: boolean;
};

```
此时运行项目，打开项目配置，界面显示相关功能代码已成功添加，不过`switch`按钮的文字在按钮外，已添加`:inline-prompt="true"`的情况下， 出现这种情况，只可能是插件本身的问题，在之前清除`element-plus`的控制台警告时，下载了特定版本的`element-plus`，这里的问题，依然还是版本问题，先删除之前下载的版本
```
yarn remove element-plus
```
然后下载最新版本：
```
yarn add element-plus@next
```
选择最新版本（此时最新是1.2.0-beta.6），下载完成后，重新运行项目，打开项目配置，可以发现，`switch`按钮的文案已经正常的显示按钮内了。

这个时候在样式中加入灰色模式、色弱模式的相关样式代码，这两种模式的功能就算完成了，在`src/style/-public.scss`文件中加入以下样式代码：
```
/* 灰色模式 */
.html-grey {
  filter: grayscale(100%);
  -webkit-filter: grayscale(100%);
  -moz-filter: grayscale(100%);
  -ms-filter: grayscale(100%);
  -o-filter: grayscale(100%);
}

/* 色弱模式 */
.html-weakness {
  filter: invert(80%);
  -webkit-filter: invert(80%);
  -moz-filter: invert(80%);
  -ms-filter: invert(80%);
  -o-filter: invert(80%);
}
```
此时再打开项目配置，切换灰色模式、色弱模式，项目的界面风格就会跟随做出改变了。

`logo`控制显示隐藏，已增加了总线事务`logoChange`，需要在`src/layout/components/vertical.vue`文件中调用该事务：
```
# 新增及修改

import { emitter } from "@/utils/mitt";
import { computed,ref,onBeforeMount,getCurrentInstance } from "vue";

const instance = getCurrentInstance().appContext.app.config.globalProperties.$storage;
const showLogo = ref(instance.sets.sidebarLogo);
onBeforeMount(() => {
  emitter.on("logoChange", key => {
    showLogo.value = key;
  });
});


<Logo v-if="showLogo" />
```
运行项目，侧边栏LOGO的显示隐藏功能已完成，刷新页面，当前做出的界面显示操作也都能正常显示

不过此时依然还有一些问题，在将`element-plus`版本升级后，部分组件的样式出现了问题，这个需要进行细节上调整，登录页面的图标此时不见了，因是版本问题造成，这里可以先将`prefix-icon`属性去掉，重写登录模块的样式，并引入其他来源的`svg`图标，或者将其需要的`element-plus`图标在`src/plugins/element-plus/index.ts`文件中引入即可


# 消息提醒功能组件
#### mock模拟后端接口
消息提醒的具体数据由后端返回，这里先用`mock`模拟后端接口，在`mock`文件夹下，新建`app.ts`文件：
```
import { MockMethod } from "vite-plugin-mock";

const noticeList = () => {
  const result = [
    {
      key: "1",
      name: "通知",
      list: [
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/ThXAXghbEsBCCSDihZxY.png",
          title: "你收到了 12 份新周报",
          datetime: "一年前",
          description: "",
          type: "1"
        },
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/OKJXDXrmkNshAMvwtvhu.png",
          title: "你推荐的 前端高手 已通过第三轮面试",
          datetime: "一年前",
          description: "",
          type: "1"
        },
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/kISTdvpyTAhtGxpovNWd.png",
          title: "这种模板可以区分多种通知类型",
          datetime: "一年前",
          description: "",
          type: "1"
        },
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/GvqBnKhFgObvnSGkDsje.png",
          title:
            "展示标题内容超过一行后的处理方式，如果内容超过1行将自动截断并支持tooltip显示完整标题。",
          datetime: "一年前",
          description: "",
          type: "1"
        },
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/GvqBnKhFgObvnSGkDsje.png",
          title: "左侧图标用于区分不同的类型",
          datetime: "一年前",
          description: "",
          type: "1"
        },
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/GvqBnKhFgObvnSGkDsje.png",
          title: "左侧图标用于区分不同的类型",
          datetime: "一年前",
          description: "",
          type: "1"
        }
      ]
    },
    {
      key: "2",
      name: "消息",
      list: [
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/fcHMVNCjPOsbUGdEduuv.jpeg",
          title: "李白 评论了你",
          description: "长风破浪会有时,直挂云帆济沧海",
          datetime: "一年前",
          type: "2"
        },
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/fcHMVNCjPOsbUGdEduuv.jpeg",
          title: "李白 回复了你",
          description: "行路难，行路难，多歧路，今安在。",
          datetime: "一年前",
          type: "2"
        },
        {
          avatar:
            "https://gw.alipayobjects.com/zos/rmsportal/fcHMVNCjPOsbUGdEduuv.jpeg",
          title: "标题",
          description:
            "请将鼠标移动到此处，以便测试超长的消息在此处将如何处理。本例中设置的描述最大行数为2，超过2行的描述内容将被省略并且可以通过tooltip查看完整内容",
          datetime: "一年前",
          type: "2"
        }
      ]
    },
    {
      key: "3",
      name: "代办",
      list: [
        {
          avatar: "",
          title: "任务名称",
          description: "任务需要在 2021-11-16 20:00 前启动",
          datetime: "",
          extra: "未开始",
          status: "info",
          type: "3"
        },
        {
          avatar: "",
          title: "第三方紧急代码变更",
          description:
            "一拳提交于 2021-11-16，需在 2021-11-18 前完成代码变更任务",
          datetime: "",
          extra: "马上到期",
          status: "danger",
          type: "3"
        },
        {
          avatar: "",
          title: "信息安全考试",
          description: "指派小仙于 2021-12-12 前完成更新并发布",
          datetime: "",
          extra: "已耗时 8 天",
          status: "warning",
          type: "3"
        },
        {
          avatar: "",
          title: "vue-pure-admin 版本发布",
          description: "vue-pure-admin 版本发布",
          datetime: "",
          extra: "进行中",
          type: "3"
        }
      ]
    }
  ];
  return result;
}

export default [
  {
    url: "/noticeData",
    method: "post",
    response: () => {
      return {
        code: 200,
        info:"数据获取成功！",
        data: noticeList()
      };
    }
  }
] as MockMethod[];
```
#### 前端封装API接口
在`src/api`文件夹下，新建`app.ts`文件：
```
import { http } from "../utils/http";

// 登录
export const getNoticeData = (data: object) => {
  return http.request("post", "/noticeData", data);
};
```
前端接口封装好后，只需要在具体用的地方进行调用即可
#### 消息通知组件
在`src/layout/components`文件夹下，新建`notice`文件夹，并在其内新建以下4个文件

新建`type.ts`文件，声明该组件所使用数据的数据类型：
```
export interface ListItem {
  avatar: string;
  title: string;
  datetime: string;
  type: string;
  description: string;
  status?: "" | "success" | "warning" | "info" | "danger";
  extra?: string;
}

export interface TabItem {
  key: string;
  name: string;
  list: ListItem[];
}
export type infoType = {
  code?: number;
  info?: string;
  data?: TabItem[];
};
```
该数据类型最终需要根据后端返回具体字段进行声明，此处使用`mock`模拟后端返回为这些字段参数

新建`index.vue`文件：
```
<script setup lang="ts">
import { ref } from "vue";
import { infoType } from "./type";
import { getNoticeData } from "@/api/app";
import list from "./list.vue";
import { warnMessage } from "@/utils/message";

let notices = ref([]);
let activeName = ref("");
let noticesNum = ref(0);
// 获取通知消息数据
const noticeListData = async () => {
  let { code, info,data }: infoType = await getNoticeData(null);
  if(code==200){
    activeName.value = data[0].name;
    notices.value = data;
    notices.value.forEach(notice => {
      noticesNum.value += notice.list.length;
    });
  }else{
    warnMessage(info);
  }
};
noticeListData();
</script>

<template>
  <el-dropdown trigger="click" placement="bottom-end">
    <span class="dropdown-badge">
      <el-badge :value="noticesNum" :max="99">
        <el-icon class="header-notice-icon"><bell /></el-icon>
      </el-badge>
    </span>
    <template #dropdown>
      <el-dropdown-menu>
        <el-tabs v-model="activeName" class="dropdown-tabs">
          <template v-for="item in notices" :key="item.key">
            <el-tab-pane
              :label="`${item.name}(${item.list.length})`"
              :name="item.name"
            >
              <el-scrollbar max-height="330px">
                <div class="noticeList-container">
                  <list :list="item.list" />
                </div>
              </el-scrollbar>
            </el-tab-pane>
          </template>
        </el-tabs>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>

<style lang="scss" scoped>
.dropdown-badge {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 48px;
  width: 60px;
  cursor: pointer;

  .header-notice-icon {
    font-size: 18px;
  }
}

.dropdown-tabs {
  width: 336px;
  background-color: #fff;
  box-shadow: 0 2px 8px rgb(0 0 0 / 15%);
  border-radius: 4px;

  :deep(.el-tabs__header) {
    margin: 0;
  }

  :deep(.el-tabs__nav-scroll) {
    display: flex;
    justify-content: center;
  }

  :deep(.el-tabs__nav-wrap)::after {
    height: 1px;
  }

  :deep(.noticeList-container) {
    padding: 15px 24px 0 24px;
  }
}
</style>
```
新建`list.vue`文件：
```
<script setup lang="ts">
import { PropType } from "vue";
import item from "./item.vue";
import { ListItem } from "./type";

const props = defineProps({
  list: {
    type: Array as PropType<Array<ListItem>>,
    default: () => []
  }
});
</script>

<template>
  <div v-if="props.list.length">
    <item
      v-for="(item, index) in props.list"
      :noticeItem="item"
      :key="index"
    ></item>
  </div>
  <el-empty v-else description="暂无数据"></el-empty>
</template>
```
新建`item.vue`文件：
```
<script setup lang="ts">
import { ListItem } from "./type";
import { ref, PropType, nextTick } from "vue";

const props = defineProps({
  noticeItem: {
    type: Object as PropType<ListItem>,
    default: () => {}
  }
});

const titleRef = ref(null);
const descriptionRef = ref(null);
const titleTooltip = ref(false);
const descriptionTooltip = ref(false);

function hoverTitle() {
  nextTick(() => {
    titleRef.value?.scrollWidth > titleRef.value?.clientWidth
      ? (titleTooltip.value = true)
      : (titleTooltip.value = false);
  });
}

function hoverDescription(event, description) {
  // currentWidth 为文本在页面中所占的宽度，创建标签，加入到页面，获取currentWidth ,最后在移除
  let tempTag = document.createElement("span");
  tempTag.innerText = description;
  tempTag.className = "getDescriptionWidth";
  document.querySelector("body").appendChild(tempTag);
  let currentWidth = (
    document.querySelector(".getDescriptionWidth") as HTMLSpanElement
  ).offsetWidth;
  document.querySelector(".getDescriptionWidth").remove();

  // cellWidth为容器的宽度
  const cellWidth = event.target.offsetWidth;

  // 当文本宽度大于容器宽度两倍时，代表文本显示超过两行
  currentWidth > 2 * cellWidth
    ? (descriptionTooltip.value = true)
    : (descriptionTooltip.value = false);
}
</script>

<template>
  <div class="notice-container">
    <el-avatar
      v-if="props.noticeItem.avatar"
      :size="30"
      :src="props.noticeItem.avatar"
      class="notice-container-avatar"
    ></el-avatar>
    <div class="notice-container-text">
      <div class="notice-text-title">
        <el-tooltip
          popper-class="notice-title-popper"
          :disabled="!titleTooltip"
          :content="props.noticeItem.title"
          placement="top-start"
        >
          <div
            ref="titleRef"
            class="notice-title-content"
            @mouseover="hoverTitle"
          >
            {{ props.noticeItem.title }}
          </div>
        </el-tooltip>
        <el-tag
          v-if="props.noticeItem?.extra"
          :type="props.noticeItem?.status"
          size="small"
          class="notice-title-extra"
          >{{ props.noticeItem?.extra }}
        </el-tag>
      </div>

      <el-tooltip
        popper-class="notice-title-popper"
        :disabled="!descriptionTooltip"
        :content="props.noticeItem.description"
        placement="top-start"
      >
        <div
          ref="descriptionRef"
          class="notice-text-description"
          @mouseover="hoverDescription($event, props.noticeItem.description)"
        >
          {{ props.noticeItem.description }}
        </div>
      </el-tooltip>
      <div class="notice-text-datetime">
        {{ props.noticeItem.datetime }}
      </div>
    </div>
  </div>
</template>

<style>
.notice-title-popper {
  max-width: 238px;
}
</style>
<style scoped lang="scss">
.notice-container {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 12px 0;
  border-bottom: 1px solid #f0f0f0;

  .notice-container-avatar {
    margin-right: 16px;
    background: #fff;
  }

  .notice-container-text {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    flex: 1;

    .notice-text-title {
      display: flex;
      margin-bottom: 8px;
      font-weight: 400;
      font-size: 14px;
      line-height: 1.5715;
      color: rgba(0, 0, 0, 0.85);
      cursor: pointer;

      .notice-title-content {
        flex: 1;
        width: 200px;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
      }

      .notice-title-extra {
        float: right;
        margin-top: -1.5px;
        font-weight: 400;
      }
    }

    .notice-text-description,
    .notice-text-datetime {
      font-size: 12px;
      line-height: 1.5715;
      color: rgba(0, 0, 0, 0.45);
    }

    .notice-text-description {
      display: -webkit-box;
      text-overflow: ellipsis;
      overflow: hidden;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .notice-text-datetime {
      margin-top: 4px;
    }
  }
}
</style>
```
此时再运行项目，发现项目报错，是因为本项目是按需引入`element-plus`组件，这里使用了一些还未被引入的`element-plus`组件和图标，需要更新`src/plugins/element-plus/index.ts`文件：
```
import { App, Component } from "vue";
import {
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElDatePicker,
  ElForm,
  ElFormItem,
  ElLoading,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
  ElBacktop,
  ElSwitch,
  ElBadge,
  ElTabs,
  ElTabPane,
  ElAvatar,
  ElEmpty,
  ElCollapse,
  ElCollapseItem,
  ElInfiniteScroll
} from "element-plus";

import {
  Check,
  Menu,
  HomeFilled,
  SetUp,
  Edit,
  Setting,
  Lollipop,
  Link,
  Position,
  Histogram,
  RefreshRight,
  ArrowDown,
  Close,
  CloseBold,
  Bell
} from "@element-plus/icons";

const components:any[] = [
  ElTag,
  ElAffix,
  ElSkeleton,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElScrollbar,
  ElSubMenu,
  ElButton,
  ElCol,
  ElRow,
  ElSpace,
  ElDivider,
  ElCard,
  ElDropdown,
  ElDialog,
  ElMenu,
  ElMenuItem,
  ElDropdownItem,
  ElDropdownMenu,
  ElIcon,
  ElInput,
  ElDatePicker,
  ElForm,
  ElFormItem,
  ElPopover,
  ElPopper,
  ElTooltip,
  ElDrawer,
  ElPagination,
  ElAlert,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElDescriptions,
  ElDescriptionsItem,
  ElBacktop,
  ElSwitch,
  ElBadge,
  ElTabs,
  ElTabPane,
  ElAvatar,
  ElEmpty,
  ElCollapse,
  ElCollapseItem
];
// icon
export const iconComponents = [
  Check,
  Menu,
  HomeFilled,
  SetUp,
  Edit,
  Setting,
  Lollipop,
  Link,
  Position,
  Histogram,
  RefreshRight,
  ArrowDown,
  Close,
  CloseBold,
  Bell
];
const plugins = [ElLoading,ElInfiniteScroll];

export function useElementPlus(app: App) {
    components.push(...iconComponents);
    components.forEach((component: Component) => {
        app.component(component.name, component);
    });
    plugins.forEach(plugin => {
        app.use(plugin);
    });
}
```
再次运行项目，消息通知功能组件已经可以正常显示了，样式细节问题待后期统一调整

# 标签页功能组件
先完成基础的`UI`搭建，修改`src/layout/components/tags.vue`文件：
```
<script setup lang="ts">
import { ref } from "vue";
import { tagsViewsType } from "../types";

const tagsViews = ref<Array<tagsViewsType>>([
  {
    icon: 'sgn-refresh',
    text: "message.hsreload",
    divided: false,
    disabled: false,
    show: true
  },
  {
    icon: 'sgn-close',
    text: "message.hscloseCurrentTab",
    divided: false,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_left',
    text: "message.hscloseLeftTabs",
    divided: true,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_right',
    text: "message.hscloseRightTabs",
    divided: false,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_other',
    text: "message.hscloseOtherTabs",
    divided: true,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_all',
    text: "message.hscloseAllTabs",
    divided: false,
    disabled: true,
    show: true
  }
]);
</script>

<template>
  <div class="tags-view">
    <!-- 左滑动 -->
    <i class="ri-arrow-left-s-line"></i>
    <!-- 标签页 -->
    <div ref="scrollbarDom" class="scroll-container">
      <div class="tab"></div>
    </div>
    <!-- 右滑动 -->
    <i class="ri-arrow-right-s-line"></i>
    <!-- 右侧功能按钮 -->
    <ul class="right-button">
      <li><el-icon :title="$t('message.hsrefreshRoute')" class="el-icon-refresh-right rotate"><RefreshRight /></el-icon></li>
      <li>
        <el-dropdown trigger="click" placement="bottom-end">
          <el-icon><ArrowDown /></el-icon>
          <template #dropdown>
            <el-dropdown-menu>
              <el-dropdown-item
                v-for="(item, key) in tagsViews"
                :key="key"
                :divided="item.divided"
                :disabled="item.disabled">
                <i class="svg-i"><svg-icon :icon-class="item.icon" /></i>
                {{ $t(item.text) }}
              </el-dropdown-item>
            </el-dropdown-menu>
          </template>
        </el-dropdown>
      </li>
      <li><i class="svg-i"><svg-icon icon-class="sgn-full_screen" /></i></li>
    </ul>
  </div>
</template>

<style lang="scss" scoped>
</style>
```
添加新增的按钮的国际化文案，修改`src/plugins/i18n/config.ts`文件：
```

// 按钮配置
export const buttonConfig = {
  zh: {
    message: {
      hsLoginOut: "退出系统",
      hsfullscreen: "全屏",
      hsexitfullscreen: "退出全屏",
      hslogin: "登陆",
      hsunfold: "点击展开",
      hsfold: "点击折叠",
      hssystemSet: "打开项目配置",
      hsSwitchOn:"开",
      hsSwitchOff:"关",
      hsrefreshRoute: "刷新路由",
      hsreload: "重新加载",
      hscloseCurrentTab: "关闭当前标签页",
      hscloseLeftTabs: "关闭左侧标签页",
      hscloseRightTabs: "关闭右侧标签页",
      hscloseOtherTabs: "关闭其他标签页",
      hscloseAllTabs: "关闭全部标签页"
    }
  },
  en: {
    message: {
      hsLoginOut: "loginOut",
      hsfullscreen: "fullScreen",
      hsexitfullscreen: "exitFullscreen",
      hslogin: "login",
      hsunfold: "unfold",
      hsfold: "fold",
      hssystemSet: "Open ProjectConfig",
      hsSwitchOn:"Y",
      hsSwitchOff:"N",
      hsrefreshRoute: "Refresh Route",
      hsreload: "Reload",
      hscloseCurrentTab: "Close Current Tab",
      hscloseLeftTabs: "Close Left Tabs",
      hscloseRightTabs: "Close Right Tabs",
      hscloseOtherTabs: "Close Other Tabs",
      hscloseAllTabs: "Close All Tabs"
    }
  }
};
```
修改`src/layout/types.ts`文件，增加数据类型声明：
```
export type tagsViewsType = {
  icon: string;
  text: string;
  divided: boolean;
  disabled: boolean;
  show: boolean;
};
```
修改`src/layout/components/appMain.vue`文件：
```
<script setup lang="ts">
import { RouterView } from "vue-router";
</script>

<template>
  <div class="app-main">
      <router-view>
        <template #default="{ Component, route }">
          <component
              :is="Component"
              :key="route.fullPath"
              class="main-content"
            />
        </template>
      </router-view>
  </div>
</template>

<style lang="scss" scoped>
.app-main {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow-x: hidden;
}
</style>
```
新增`tags.vue`文件中的代码样式文件，在`src/style`文件夹下新建`-tags.scss`文件：
```
.tags-view {
  width: 100%;
  font-size: 14px;
  display: flex;
  align-items: center;
  color: var(--el-text-color-regular);
  background: #fff;
  position: relative;
  box-shadow: 0 0 1px #888;
  a {
    text-decoration: none;
    color: #666;
    padding: 0 4px 0 4px;
  }
  .scroll-container {
    flex: 1;
    overflow: hidden;
    padding: 5px 0;
    white-space: nowrap;
    position: relative;

    .tab {
      position: relative;
      float: left;
      list-style: none;
      overflow: visible;
      white-space: nowrap;
      transition: transform 0.5s ease-in-out;
    }
  }

  .right-button {
    display: flex;
    font-size: 16px;
    li {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 38px;
      border-right: 1px solid #ccc;
      cursor: pointer;
    }
  }
}

.ri-arrow-left-s-line {
  width: 40px;
  height: 38px;
  line-height: 38px;
  text-align: center;
  font-size: 20px;
  color: #00000073;
  box-shadow: 5px 0 5px -6px #ccc;

  &:hover {
    cursor: w-resize;
  }
}

.ri-arrow-right-s-line {
  width: 40px;
  height: 38px;
  line-height: 38px;
  text-align: center;
  font-size: 20px;
  border-right: 1px solid #ccc;
  color: #00000073;
  box-shadow: -5px 0 5px -6px #ccc;

  &:hover {
    cursor: e-resize;
  }
}
```
将`-tags.scss`文件引入到`index.scss`文件中：
```
@import "./-tags.scss";
```
## 存储标签页信息（路由信息）
基础代码完成后，需要存储标签页信息，标签页的功能主要在于将打开的路由信息缓存下来，在`src/store/modules`文件夹下新建`multiTags.ts`文件：
```
import { Module } from 'vuex'
import { multiTagsType } from "#/store";

const tagsModule: Module<multiTagsType,any> = {
  namespaced: true,
  state: {
    // 存储标签页信息（路由信息）
    multiTags: [
      {
        path: "/",
        parentPath: "/",
        meta: {
          title: "message.hshome",
          i18n: true,
          icon: "fa-house-damage",
          showLink: true
        }
      }
    ],
  },
  mutations:{},
  actions: {}
};
export default tagsModule
```
在`types/store.d.ts`文件中新增`multiTagsType`数据类型声明：
```
declare type multiTagsType = {
  multiTags: Array;
};
```
这样就有了存放标签页的地方，这里先暂时将首页设置为默认标签页，作为进入系统后的默认展示页，修改`src/layout/components/tags.vue`文件：
```
<script setup lang="ts">
import { ref,computed,ComputedRef } from "vue";
import { useStore } from 'vuex'
import { RouteConfigs,tagsViewsType } from "../types";
import { transformI18n } from "@/plugins/i18n";
const store = useStore();
let multiTags: ComputedRef<Array<RouteConfigs>> = computed(() => {
  return store.state.multiTags.multiTags;
});

const tagsViews = ref<Array<tagsViewsType>>([
  {
    icon: 'sgn-refresh',
    text: "message.hsreload",
    divided: false,
    disabled: false,
    show: true
  },
  {
    icon: 'sgn-close',
    text: "message.hscloseCurrentTab",
    divided: false,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_left',
    text: "message.hscloseLeftTabs",
    divided: true,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_right',
    text: "message.hscloseRightTabs",
    divided: false,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_other',
    text: "message.hscloseOtherTabs",
    divided: true,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_all',
    text: "message.hscloseAllTabs",
    divided: false,
    disabled: true,
    show: true
  }
]);
</script>

<template>
  <div class="tags-view">
    <!-- 左滑动 -->
    <i class="ri-arrow-left-s-line"></i>
    <!-- 标签页 -->
    <div ref="scrollbarDom" class="scroll-container">
      <div class="tab">
        <div
          v-for="(item, index) in multiTags"
          :key="index"
          :class="[
            'scroll-item is-closable',
            $route.path === item.path ? 'is-active' : '',
            $route.path === item.path
              ? 'card-active'
              : ''
          ]"
        >
          <router-link :to="item.path">{{
            transformI18n(item.meta.title, item.meta.i18n)
          }}</router-link>
          <el-icon v-if="($route.path === item.path && index !== 0)" class="el-icon-close">
            <CloseBold />
          </el-icon>
        </div>
      </div>
    </div>
    <!-- 右滑动 -->
    <i class="ri-arrow-right-s-line"></i>
    <!-- 右侧功能按钮 -->
    <ul class="right-button">
      <li><el-icon :title="$t('message.hsrefreshRoute')" class="el-icon-refresh-right rotate"><RefreshRight /></el-icon></li>
      <li>
        <el-dropdown trigger="click" placement="bottom-end">
          <el-icon><ArrowDown /></el-icon>
          <template #dropdown>
            <el-dropdown-menu>
              <el-dropdown-item
                v-for="(item, key) in tagsViews"
                :key="key"
                :divided="item.divided"
                :disabled="item.disabled">
                <i class="svg-i"><svg-icon :icon-class="item.icon" /></i>
                {{ $t(item.text) }}
              </el-dropdown-item>
            </el-dropdown-menu>
          </template>
        </el-dropdown>
      </li>
      <li><i class="svg-i"><svg-icon icon-class="sgn-full_screen" /></i></li>
    </ul>
  </div>
</template>

<style lang="scss" scoped>
</style>
```
在`src/layout/types.ts`中新增数据类型声明：
```
export type RouteConfigs = {
  path?: string;
  parentPath?: string;
  meta?: {
    title?: string;
    i18n?: boolean;
    icon?: string;
    showLink?: boolean;
    savedPosition?: boolean;
    authority?: Array<string>;
  };
  children?: RouteConfigs[];
  name?: string;
};
```
`src/style/-tags.scss`中样式修改：
```

.tags-view {
  width: 100%;
  font-size: 14px;
  display: flex;
  align-items: center;
  color: var(--el-text-color-regular);
  background: #fff;
  position: relative;
  box-shadow: 0 0 1px #888;

  .scroll-item {
    border-radius: 3px 3px 0 0;
    padding: 0 6px 0 6px;
    box-shadow: 0 0 1px #888;
    position: relative;
    margin-right: 4px;
    height: 28px;
    display: inline-block;
    line-height: 28px;
    transition: all 0.4s;
    cursor: pointer;

    .el-icon-close {
      font-size: 10px;
      color: #1890ff;
      cursor: pointer;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      transition: font-size 0.2s;

      &:hover {
        border-radius: 50%;
        color: #fff;
        background: #b4bccc;
        font-size: 13px;
      }
    }

    &.is-closable:not(:first-child) {
      &:hover {
        padding-right: 18px;

        &:not(.is-active) {
          .el-icon-close {
            animation: close 200ms ease-in forwards;
          }
        }
      }
    }
  }

  a {
    text-decoration: none;
    color: #666;
    padding: 0 4px 0 4px;
  }

  .scroll-container {
    flex: 1;
    overflow: hidden;
    padding: 5px 0;
    white-space: nowrap;
    position: relative;

    .tab {
      position: relative;
      float: left;
      list-style: none;
      overflow: visible;
      white-space: nowrap;
      transition: transform 0.5s ease-in-out;

      .scroll-item {
        transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);

        &:nth-child(1) {
          margin-left: 5px;
        }
      }
    }
  }

  .right-button {
    display: flex;
    font-size: 16px;

    li {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 38px;
      border-right: 1px solid #ccc;
      cursor: pointer;
    }
  }

}

.scroll-item.is-active {
  background-color: #eaf4fe;
  position: relative;
  color: #fff;

  &:not(:first-child) {
    padding-right: 18px;
  }

  .el-icon-close {
    transform: translate(0, -50%);
  }

  a {
    color: #1890ff;
  }
}
/* 卡片模式下鼠标移入显示蓝色边框 */
.card-in {
  color: #1890ff;

  a {
    color: #1890ff;
  }
}

/* 卡片模式下鼠标移出隐藏蓝色边框 */
.card-out {
  border: none;
  color: #666;

  a {
    color: #666;
  }
}
.ri-arrow-left-s-line {
  width: 40px;
  height: 38px;
  line-height: 38px;
  text-align: center;
  font-size: 20px;
  color: #00000073;
  box-shadow: 5px 0 5px -6px #ccc;

  &:hover {
    cursor: w-resize;
  }
}

.ri-arrow-right-s-line {
  width: 40px;
  height: 38px;
  line-height: 38px;
  text-align: center;
  font-size: 20px;
  border-right: 1px solid #ccc;
  color: #00000073;
  box-shadow: -5px 0 5px -6px #ccc;

  &:hover {
    cursor: e-resize;
  }
}
@keyframes close {
  from {
    transform: translate(-50%, -50%);
  }

  to {
    transform: translate(0, -50%);
  }
}
```
此时标签栏上默认的首页就展示出来了，接下来需要做到点击侧边栏菜单，标签栏能相应添加标签页，这里需要用到总线事务，在侧边栏组件中菜单的点击事件中，加入一个总线事务，在标签栏组件中监听该总线事务，并通过该总线事务传递的参数，对标签页做出相应的改变

在`src/layout/components/vertical.vue`文件中，为菜单添加点击事件：
```
# el-menu标签上新增：
@select="menuSelect"

# script标签内新增：
import { algorithm } from "@/utils/algorithm";
import { useRoute, useRouter } from "vue-router";
const router = useRouter().options.routes;

const menuSelect = (indexPath: string): void => {
  let parentPath = "";
  let parentPathIndex = indexPath.lastIndexOf("/");
  if (parentPathIndex > 0) {
    parentPath = indexPath.slice(0, parentPathIndex);
  }
  // 找到当前路由的信息
  // eslint-disable-next-line no-inner-declarations
  function findCurrentRoute(routes) {
    return routes.map(item => {
      if (item.path === indexPath) {
        // 切换左侧菜单 通知标签页
        emitter.emit("changLayoutRoute", {
          indexPath,
          parentPath
        });
      } else {
        if (item.children) findCurrentRoute(item.children);
      }
    });
  }
  findCurrentRoute(algorithm.increaseIndexes(router));
};
```
在`src/utils/mitt.ts`文件中新增事务数据类型声明：
```
changLayoutRoute: {
  indexPath: string;
  parentPath: string;
};
```
修改`src/layout/components/tags.vue`文件：
```
import { ref,computed,ComputedRef,onBeforeMount, } from "vue";
import { useRouter } from "vue-router";
import { emitter } from "@/utils/mitt";
const router = useRouter();

// 动态获取当前的路由标签页信息
function dynamicRouteTag(value: string, parentPath: string): void {
  const hasValue = multiTags.value.some(item => {
    return item.path === value;
  });
  // 递归寻找选中的路由，并缓存到标签页信息中
  function concatPath(arr: object[], value: string, parentPath: string) {
    if (!hasValue) {
      arr.forEach((arrItem: any) => {
        let pathConcat = parentPath + arrItem.path;
        if (arrItem.path === value || pathConcat === value) {
          store.dispatch("multiTags/handleTags",{
            path: value,
            parentPath: `/${parentPath.split("/")[1]}`,
            meta: arrItem.meta,
            name: arrItem.name
          });
        } else {
          if (arrItem.children && arrItem.children.length > 0) {
            concatPath(arrItem.children, value, parentPath);
          }
        }
      });
    }
  }
  concatPath(router.options.routes, value, parentPath);
}

onBeforeMount(() => {
  //  接收侧边栏切换传递过来的参数
  emitter.on("changLayoutRoute", ({ indexPath, parentPath }) => {
    dynamicRouteTag(indexPath, parentPath);
  });
});
```
此处接收侧边栏传递的参数，并动态获取当前路由信息，通过`vuex`的状态管理，传递当前路由数据，并在`vuex`状态管理中做缓存操作，修改`src/store/modules/multiTags.ts`文件：
```
import { Module } from 'vuex'
import { multiTagsType } from "#/store";
import { storageLocal } from "@/utils/storage";

const tagsModule: Module<multiTagsType,any> = {
  namespaced: true,
  state: {
    // 存储标签页信息（路由信息）
    multiTags: storageLocal.getItem("responsive-tags"),
  },
  mutations:{
    tagsCache:(state)=> {
      storageLocal.setItem("responsive-tags", state.multiTags);
    },
  },
  actions: {
    handleTags({state,commit},data) {
      const tagVal = data;
      // 判断tag是否已存在:
      const tagHasExits = state.multiTags.some(tag => {
        return tag.path === tagVal?.path;
      });
      if (tagHasExits) return;
      state.multiTags.push(data);
      commit('tagsCache');
    }
  }
};
export default tagsModule
```
这里在做缓存时，将标签页信息缓存到了`responsive-tags`字段中，而这里需要先在`src/utils/storage/responsive.ts`文件中增加对应的修改：
```
const configObj = Object.assign(
  {
    // 国际化 默认中文zh
    locale: {
      type: Object,
      default: Storage.getData(undefined, "locale") ?? {
        locale: config.Locale ?? "zh"
      }
    },
    sets: {
      type: Object,
      default: Storage.getData(undefined, "sets") ?? {
        grey: config.Grey ?? false,
        weak: config.Weak ?? false,
        sidebarLogo: config.SidebarLogo ?? true,
      }
    }
  },
  {
    tags: {
      type: Array,
      default: Storage.getData(undefined, "tags") ?? [
        {
          path: "/",
          parentPath: "/",
          meta: {
            title: "message.hshome",
            i18n: true,
            icon: "fa-house-damage",
            showLink: true
          }
        }
      ]
    }
  }
);
```
此时再次运行项目，点击侧边栏标签栏就能相应做出改变，标签栏的路由切换，也可以正常打开对应页面了

## 关闭标签页功能、标签页右键菜单功能
标签页上的关闭按钮，以及右侧下拉中的各种关闭操作功能，标签页右键菜单中的操作功能，都是对标签页本身的操作，接下来实现这些功能，以完善标签页的功能需求

修改`src/layout/components/tags.vue`文件：
```
<script setup lang="ts">
import { ref,unref,watch,computed,ComputedRef,onBeforeMount,getCurrentInstance,nextTick } from "vue";
import { useStore } from 'vuex'
import { useRoute, useRouter } from "vue-router";
import { RouteConfigs,tagsViewsType } from "../types";
import { transformI18n } from "@/plugins/i18n";
import { emitter } from "@/utils/mitt";
import { toggleClass, removeClass, hasClass } from "@/utils/operate";
import { templateRef, } from "@vueuse/core";
const store = useStore();
const route = useRoute();
const router = useRouter();
const activeIndex = ref<number>(-1);
const instance = getCurrentInstance();
const containerDom = templateRef<HTMLElement | null>("containerDom", null);
// 获取被缓存的标签页数据
let multiTags: ComputedRef<Array<RouteConfigs>> = computed(() => {
  return store.state.multiTags.multiTags;
});

// 声明标签页操作栏数据
const tagsViews = ref<Array<tagsViewsType>>([
  {
    icon: 'sgn-refresh',
    text: "message.hsreload",
    divided: false,
    disabled: false,
    show: true
  },
  {
    icon: 'sgn-close',
    text: "message.hscloseCurrentTab",
    divided: false,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_left',
    text: "message.hscloseLeftTabs",
    divided: true,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_right',
    text: "message.hscloseRightTabs",
    divided: false,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_other',
    text: "message.hscloseOtherTabs",
    divided: true,
    disabled: true,
    show: true
  },
  {
    icon: 'sgn-close_all',
    text: "message.hscloseAllTabs",
    divided: false,
    disabled: true,
    show: true
  }
]);

let visible = ref(false);
let buttonLeft = ref(0);
let buttonTop = ref(0);
// 当前右键选中的路由信息
let currentSelect = ref({});
// 重新加载
function onFresh() {
  // 执行刷新按钮的动画效果
  toggleClass(true, "refresh-button", document.querySelector(".rotate"));
  const { fullPath } = unref(route);
  // 替换路由，到重定向页面，重定向页面会自动跳转到需要跳转的页面
  router.replace({
    path: "/redirect" + fullPath
  });
  // 移除刷新按钮的动画效果
  setTimeout(() => {
    removeClass(document.querySelector(".rotate"), "refresh-button");
  }, 600);
}
// 删除动态标签页
function deleteDynamicTag(obj: any, current: any, tag?: string) {
  // 获取当前所在标签页在标签页缓存数据中的索引值
  let valueIndex: number = multiTags.value.findIndex((item: any) => {
    return item.path === obj.path;
  });
  // 对标签页缓存数据进行操作的封装方法
  const spliceRoute = (startIndex?: number, length?: number, other?: boolean): void => {
    if (other) {
      // 调用标签页数据的状态管理，将首页和当前标签页作为数据传递
      store.dispatch("multiTags/handleTags",{mode:"equal",value: [
        {
          path: "/",
          parentPath: "/",
          meta: {
            title: "message.hshome",
            i18n: true,
            icon: "fa-house-damage",
            showLink: true
          }
        },
        obj
      ]});
    }else{
      // 当不是关闭其他标签页事件时，通过索引去修改标签页缓存数据
      store.dispatch("multiTags/handleTags",{mode:"splice",value:'',position:{
        startIndex,
        length
      }});
    }
  };
  // 根据当前tag类型，执行标签页缓存数据操作方法
  if (tag === "other") {
    spliceRoute(1, 1, true);
  } else if (tag === "left") {
    spliceRoute(1, valueIndex - 1);
  } else if (tag === "right") {
    spliceRoute(valueIndex + 1, multiTags.value.length);
  } else {
    // 从当前匹配到的路径中删除
    spliceRoute(valueIndex, 1);
  }
  // 在标签页缓存数据处理过后，提取数组中最后一个路由信息
  store.dispatch("multiTags/handleTags",{mode:"slice"}).then(res=>{
    // 如果事件依据的路由就是当前激活tag
    if (current === route.path) {
      // 如果事件依据是删除左侧标签页，而事件依据的标签页又是当前激活标签页，则不需要路由跳转，直接返回即可
      if (tag === "left") return;
      // 自动切换到最后一个tag
      nextTick(() => {
        router.push({
          path: res[0].path
        });
      });
    } else {
      // 如果事件依据的路由不是当前激活路由，标签页缓存数据不存在了，则直接返回
      if (!multiTags.value.length) return;
      // 将当前激活的路由找出
      let isHasActiveTag = multiTags.value.some(item => {
        return item.path === route.path;
      });
      // 如果当前激活的路由不存在（被删除）则跳转到最后一个缓存的标签页
      !isHasActiveTag &&
        router.push({
          path: res[0].path
        });
    }
  });
  
}
// 标签页上的关闭按钮点击事件
function deleteMenu(item, tag?: string) {
  deleteDynamicTag(item, item.path, tag);
}
// 标签页的点击事件，右键及右侧下拉的点击事件
function onClickDrop(key, item, selectRoute?: RouteConfigs) {
  if (item && item.disabled) return;
  // 当前路由信息
  switch (key) {
    case 0:
      // 重新加载
      onFresh();
      break;
    case 1:
      // 关闭当前标签页
      selectRoute
        ? deleteMenu({
            path: selectRoute.path,
            meta: selectRoute.meta,
            name: selectRoute.name
          })
        : deleteMenu({ path: route.path, meta: route.meta });
      break;
    case 2:
      // 关闭左侧标签页
      selectRoute
        ? deleteMenu(
            {
              path: selectRoute.path,
              meta: selectRoute.meta
            },
            "left"
          )
        : deleteMenu({ path: route.path, meta: route.meta }, "left");
      break;
    case 3:
      // 关闭右侧标签页
      selectRoute
        ? deleteMenu(
            {
              path: selectRoute.path,
              meta: selectRoute.meta
            },
            "right"
          )
        : deleteMenu({ path: route.path, meta: route.meta }, "right");
      break;
    case 4:
      // 关闭其他标签页
      selectRoute
        ? deleteMenu(
            {
              path: selectRoute.path,
              meta: selectRoute.meta
            },
            "other"
          )
        : deleteMenu({ path: route.path, meta: route.meta }, "other");
      break;
    case 5:
      // 关闭全部标签页
      store.dispatch("multiTags/handleTags",{mode:"splice",value: '',position:{
        startIndex: 1,
        length: multiTags.value.length
      }});
      router.push("/");
      break;
  }
  setTimeout(() => {
    // 重新渲染点击事件的状态
    showMenuModel(route.fullPath);
  });
}

// 触发右键中菜单的点击事件
function selectTag(key, item) {
  onClickDrop(key, item, currentSelect.value);
}
// 右键菜单隐藏
function closeMenu() {
  visible.value = false;
}
// 右键菜单的菜单项是否显示
function showMenus(value: boolean) {
  Array.of(1, 2, 3, 4, 5).forEach(v => {
    tagsViews.value[v].show = value;
  });
}
// 菜单的菜单项是否被禁用
function disabledMenus(value: boolean) {
  Array.of(1, 2, 3, 4, 5).forEach(v => {
    tagsViews.value[v].disabled = value;
  });
}

// 检查当前右键的菜单两边是否存在别的菜单，如果左侧的菜单是首页，则不显示关闭左侧标签页，如果右侧没有菜单，则不显示关闭右侧标签页
function showMenuModel(currentPath: string, refresh = false) {
  let allRoute = multiTags.value;
  let routeLength = multiTags.value.length;
  // currentIndex为1时，左侧的菜单是首页，则不显示关闭左侧标签页
  let currentIndex = allRoute.findIndex(v => v.path === currentPath);
  // 如果currentIndex等于routeLength-1，右侧没有菜单，则不显示关闭右侧标签页
  showMenus(true);

  if (refresh) {
    tagsViews.value[0].show = true;
  }

  if (currentIndex === 1 && routeLength !== 2) {
    // 左侧的菜单是首页，右侧存在别的菜单
    tagsViews.value[2].show = false;
    Array.of(1, 3, 4, 5).forEach(v => {
      tagsViews.value[v].disabled = false;
    });
    tagsViews.value[2].disabled = true;
  } else if (currentIndex === 1 && routeLength === 2) {
    disabledMenus(false);
    // 左侧的菜单是首页，右侧不存在别的菜单
    Array.of(2, 3, 4).forEach(v => {
      tagsViews.value[v].show = false;
      tagsViews.value[v].disabled = true;
    });
  } else if (routeLength - 1 === currentIndex && currentIndex !== 0) {
    // 当前路由是所有路由中的最后一个
    tagsViews.value[3].show = false;
    Array.of(1, 2, 4, 5).forEach(v => {
      tagsViews.value[v].disabled = false;
    });
    tagsViews.value[3].disabled = true;
  } else if (currentIndex === 0 || currentPath === "/redirect/") {
    // 当前路由为首页
    disabledMenus(true);
  } else {
    disabledMenus(false);
  }
}
// 打开右键菜单
function openMenu(tag, e) {
  closeMenu();
  if (tag.path === "/") {
    // 右键菜单为首页，只显示刷新
    showMenus(false);
    tagsViews.value[0].show = true;
  } else if (route.path !== tag.path) {
    // 右键菜单不匹配当前路由，隐藏刷新
    tagsViews.value[0].show = false;
    showMenuModel(tag.path);
  } else if (
    // eslint-disable-next-line no-dupe-else-if
    multiTags.value.length === 2 &&
    route.path !== tag.path
  ) {
    showMenus(true);
    // 只有两个标签时不显示关闭其他标签页
    tagsViews.value[4].show = false;
  } else if (route.path === tag.path) {
    // 右键当前激活的菜单
    showMenuModel(tag.path, true);
  }

  currentSelect.value = tag;
  const menuMinWidth = 105;
  const offsetLeft = unref(containerDom).getBoundingClientRect().left;
  const offsetWidth = unref(containerDom).offsetWidth;
  const maxLeft = offsetWidth - menuMinWidth;
  const left = e.clientX - offsetLeft + 5;
  if (left > maxLeft) {
    buttonLeft.value = maxLeft;
  } else {
    buttonLeft.value = left;
  }
  buttonTop.value = e.clientY - 40;
  setTimeout(() => {
    visible.value = true;
  }, 10);
}

// 触发tags标签切换
function tagOnClick(item) {
  router.push({
    path: item?.path
  });
  // 重新判断点击事件的状态
  showMenuModel(item?.path);
}
// 鼠标移入标签页状态
function onMouseenter(item, index) {
  if (index) activeIndex.value = index;
  if (hasClass(instance.refs["dynamic" + index], "card-active")) return;
  toggleClass(true, "card-in", instance.refs["dynamic" + index]);
  toggleClass(false, "card-out", instance.refs["dynamic" + index]);
}

// 鼠标移出标签页状态
function onMouseleave(item, index) {
  activeIndex.value = -1;
  if (hasClass(instance.refs["dynamic" + index], "card-active")) return;
  toggleClass(false, "card-in", instance.refs["dynamic" + index]);
  toggleClass(true, "card-out", instance.refs["dynamic" + index]);
}
// 监听右键菜单的显示隐藏
watch(
  () => visible.value,
  val => {
    if (val) {
      document.body.addEventListener("click", closeMenu);
    } else {
      document.body.removeEventListener("click", closeMenu);
    }
  }
);
// 动态获取当前的路由标签页信息
function dynamicRouteTag(value: string, parentPath: string): void {
  const hasValue = multiTags.value.some(item => {
    return item.path === value;
  });
  // 递归寻找选中的路由，并缓存到标签页信息中
  function concatPath(arr: object[], value: string, parentPath: string) {
    if (!hasValue) {
      arr.forEach((arrItem: any) => {
        let pathConcat = parentPath + arrItem.path;
        if (arrItem.path === value || pathConcat === value) {
          store.dispatch("multiTags/handleTags",{mode:"push",value:{
            path: value,
            parentPath: `/${parentPath.split("/")[1]}`,
            meta: arrItem.meta,
            name: arrItem.name
          }});
        } else {
          if (arrItem.children && arrItem.children.length > 0) {
            concatPath(arrItem.children, value, parentPath);
          }
        }
      });
    }
  }
  concatPath(router.options.routes, value, parentPath);
}
onBeforeMount(() => {
  if (!instance) return;

  // 根据当前路由初始化操作标签页的禁用状态
  showMenuModel(route.fullPath);
  //  接收侧边栏切换传递过来的参数
  emitter.on("changLayoutRoute", ({ indexPath, parentPath }) => {
    dynamicRouteTag(indexPath, parentPath);
    setTimeout(() => {
      showMenuModel(indexPath);
    });
  });
});
</script>

<template>
  <div ref="containerDom" class="tags-view">
    <!-- 左滑动 -->
    <i class="ri-arrow-left-s-line"></i>
    <!-- 标签页 -->
    <div ref="scrollbarDom" class="scroll-container">
      <div class="tab">
        <div
          :ref="'dynamic' + index"
          v-for="(item, index) in multiTags"
          :key="index"
          :class="[
            'scroll-item is-closable',
            $route.path === item.path ? 'is-active' : '',
            $route.path === item.path
              ? 'card-active'
              : ''
          ]"
          @contextmenu.prevent="openMenu(item, $event)"
          @mouseenter.prevent="onMouseenter(item, index)"
          @mouseleave.prevent="onMouseleave(item, index)"
          @click="tagOnClick(item)"
        >
          <router-link :to="item.path">{{
            transformI18n(item.meta.title, item.meta.i18n)
          }}</router-link>
          <el-icon v-if="($route.path === item.path && index !== 0) || (index === activeIndex && index !== 0)"
            @click.stop="deleteMenu(item)" class="el-icon-close">
            <CloseBold />
          </el-icon>
        </div>
      </div>
    </div>
    <!-- 右滑动 -->
    <i class="ri-arrow-right-s-line"></i>
    <!-- 右键菜单按钮 -->
    <transition name="el-zoom-in-top">
      <ul
        v-show="visible"
        :key="Math.random()"
        :style="{ left: buttonLeft + 'px', top: buttonTop + 'px' }"
        class="contextmenu"
      >
        <div
          v-for="(item, key) in tagsViews"
          :key="key"
          style="display: flex; align-items: center"
        >
          <li v-if="item.show" @click="selectTag(key, item)">
            <i class="svg-i"><svg-icon :icon-class="item.icon" /></i>
            {{ $t(item.text) }}
          </li>
        </div>
      </ul>
    </transition>
    <!-- 右侧功能按钮 -->
    <ul class="right-button">
      <li><el-icon :title="$t('message.hsrefreshRoute')" class="el-icon-refresh-right rotate" @click="onFresh"><RefreshRight /></el-icon></li>
      <li>
        <el-dropdown trigger="click" placement="bottom-end">
          <el-icon><ArrowDown /></el-icon>
          <template #dropdown>
            <el-dropdown-menu>
              <el-dropdown-item
                v-for="(item, key) in tagsViews"
                :key="key"
                :divided="item.divided"
                :disabled="item.disabled"
                @click="onClickDrop(key, item)">
                <i class="svg-i"><svg-icon :icon-class="item.icon" /></i>
                {{ $t(item.text) }}
              </el-dropdown-item>
            </el-dropdown-menu>
          </template>
        </el-dropdown>
      </li>
      <li><i class="svg-i"><svg-icon icon-class="sgn-full_screen" /></i></li>
    </ul>
  </div>
</template>

<style lang="scss" scoped>
</style>
```
这里完善了标签页的部分功能，右键菜单，刷新路由，删除标签页等功能，其他相关联的一些页面页有修改

`src/store/modules/multiTags.ts`文件：
```
import { Module } from 'vuex'
import { multiTagsType } from "#/store";
import { storageLocal } from "@/utils/storage";

const tagsModule: Module<multiTagsType,any> = {
  namespaced: true,
  state: {
    // 存储标签页信息（路由信息）
    multiTags: storageLocal.getItem("responsive-tags"),
  },
  mutations:{
    tagsCache:(state)=> {
      storageLocal.setItem("responsive-tags", state.multiTags);
    },
  },
  actions: {
    handleTags({state,commit},data) {
      switch (data.mode) {
        case "equal":
          state.multiTags = data.value;
          commit('tagsCache');
          break;
        case "push":
          {
            const tagVal = data.value;
            // 判断tag是否已存在:
            const tagHasExits = state.multiTags.some(tag => {
              return tag.path === tagVal?.path;
            });

            if (tagHasExits) return;
            state.multiTags.push(data.value);
            commit('tagsCache');
          }
          break;
        case "splice":
          state.multiTags.splice(data.position?.startIndex, data.position?.length);
          commit('tagsCache');
          return state.multiTags;
          break;
        case "slice":
          return state.multiTags.slice(-1);
          break;
      }
    }
  }
};
export default tagsModule
```

`src/style/-tags.scss`
```

.tags-view {
  width: 100%;
  font-size: 14px;
  display: flex;
  align-items: center;
  color: var(--el-text-color-regular);
  background: #fff;
  position: relative;
  box-shadow: 0 0 1px #888;

  .scroll-item {
    border-radius: 3px 3px 0 0;
    padding: 0 6px 0 6px;
    box-shadow: 0 0 1px #888;
    position: relative;
    margin-right: 4px;
    height: 28px;
    display: inline-block;
    line-height: 28px;
    transition: all 0.4s;
    cursor: pointer;

    .el-icon-close {
      font-size: 10px;
      color: #1890ff;
      cursor: pointer;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      transition: font-size 0.2s;

      &:hover {
        border-radius: 50%;
        color: #fff;
        background: #b4bccc;
        font-size: 13px;
      }
    }

    &.is-closable:not(:first-child) {
      &:hover {
        padding-right: 18px;

        &:not(.is-active) {
          .el-icon-close {
            animation: close 200ms ease-in forwards;
          }
        }
      }
    }
  }

  a {
    text-decoration: none;
    color: #666;
    padding: 0 4px 0 4px;
  }

  .scroll-container {
    flex: 1;
    overflow: hidden;
    padding: 5px 0;
    white-space: nowrap;
    position: relative;

    .tab {
      position: relative;
      float: left;
      list-style: none;
      overflow: visible;
      white-space: nowrap;
      transition: transform 0.5s ease-in-out;

      .scroll-item {
        transition: all 0.3s cubic-bezier(0.645, 0.045, 0.355, 1);

        &:nth-child(1) {
          margin-left: 5px;
        }
      }
    }
  }

  .right-button {
    display: flex;
    font-size: 16px;

    li {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 38px;
      border-right: 1px solid #ccc;
      cursor: pointer;
    }
  }

  /* 右键菜单 */
  .contextmenu {
    margin: 0;
    background: #fff;
    position: absolute;
    list-style-type: none;
    padding: 5px 0;
    border-radius: 4px;
    color: rgba(0,0,0,.9);
    font-weight: normal;
    font-size: 13px;
    white-space: nowrap;
    outline: 0;
    box-shadow: 0 2px 8px rgb(0 0 0 / 15%);

    li {
      width: 100%;
      margin: 0;
      padding: 7px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;

      &:hover {
        background: #eee;
      }

      svg {
        display: block;
        margin-right: 0.5em;
      }
    }
  }
}

.scroll-item.is-active {
  background-color: #eaf4fe;
  position: relative;
  color: #fff;

  &:not(:first-child) {
    padding-right: 18px;
  }

  .el-icon-close {
    transform: translate(0, -50%);
  }

  a {
    color: #1890ff;
  }
}
/* 卡片模式下鼠标移入显示蓝色边框 */
.card-in {
  color: #1890ff;

  a {
    color: #1890ff;
  }
}

/* 卡片模式下鼠标移出隐藏蓝色边框 */
.card-out {
  border: none;
  color: #666;

  a {
    color: #666;
  }
}
.ri-arrow-left-s-line {
  width: 40px;
  height: 38px;
  line-height: 38px;
  text-align: center;
  font-size: 20px;
  color: #00000073;
  box-shadow: 5px 0 5px -6px #ccc;

  &:hover {
    cursor: w-resize;
  }
}

.ri-arrow-right-s-line {
  width: 40px;
  height: 38px;
  line-height: 38px;
  text-align: center;
  font-size: 20px;
  border-right: 1px solid #ccc;
  color: #00000073;
  box-shadow: -5px 0 5px -6px #ccc;

  &:hover {
    cursor: e-resize;
  }
}
/* 刷新按钮动画效果 */
.refresh-button {
  -webkit-animation: rotate 600ms linear infinite;
  -moz-animation: rotate 600ms linear infinite;
  -o-animation: rotate 600ms linear infinite;
  animation: rotate 600ms linear infinite;
}

@-webkit-keyframes rotate {
  from {
    -webkit-transform: rotate(0deg);
  }

  to {
    -webkit-transform: rotate(360deg);
  }
}

@-moz-keyframes rotate {
  from {
    -moz-transform: rotate(0deg);
  }

  to {
    -moz-transform: rotate(360deg);
  }
}

@-o-keyframes rotate {
  from {
    -o-transform: rotate(0deg);
  }

  to {
    -o-transform: rotate(360deg);
  }
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}
@keyframes close {
  from {
    transform: translate(-50%, -50%);
  }

  to {
    transform: translate(0, -50%);
  }
}
```
实现刷新页面的功能，是让路由做了一个跳转，再跳回原页面的操作，所以路由中要有添加一个中转路由，以及对应的页面

在`src/views`文件夹下新建`redirect`文件夹，在其内新建`index.vue`文件：
```
<script setup lang="ts">
import { unref } from "vue";
import { useRouter } from "vue-router";

const { currentRoute, replace } = useRouter();

const { params, query } = unref(currentRoute);
const { path } = params;

const _path = Array.isArray(path) ? path.join("/") : path;

replace({
  path: "/" + _path,
  query
});
</script>

<template>
  <div></div>
</template>
```
在`src/router/remaining.ts`中添加对应的路由：
```
import Layout from "@/layout/index.vue";


{
  path: "/redirect",
  name: "redirect",
  component: Layout,
  meta: {
    showLink: false,
    rank: 104
  },
  children: [
    {
      path: "/redirect/:path(.*)",
      name: "redirect",
      component: () => import("@/views/redirect/index.vue")
    }
  ]
}
```
完成以上内容后，再次运行项目，标签页的右键菜单功能，下拉菜单功能，刷新路由，关闭路由等操作，都可以正常进行操作了

## 存储标签页内容状态（keep alive）
上面做的是存储了标签页的路由信息，通过存储的标签页路由信息，渲染标签页，点击具体标签页则通过`router-link`链接具体页面，不过这里并没有将页面进行缓存，也没有保存页面的已操作状态，如首页选择一个日期后，切换页面后，再回到首页，日期选择已被清空，而要缓存页面内容状态，需要用到`vue`的内置组件`keep-alive`，用来做标签页的状态持久化

#### 最简单的使用方法
直接修改`src/layout/components/appMain.vue`文件，加上该组件即可：
```
<template>
  <div class="app-main">
      <router-view>
        <template #default="{ Component, route }">
          <keep-alive>
            <component
                :is="Component"
                :key="route.fullPath"
                class="main-content"
              />
          </keep-alive>
        </template>
      </router-view>
  </div>
</template>
```
此时再去首页选择日期，然后切换其他页面，再回首页，状态就被保留了下来，不过这个最简单的做法

标签页要做更灵活，需要做一些全局配置：
1. 标签页去留功能
2. 标签页状态持久化全局控制功能
3. 标签页单页面状态持久化控制功能（全局配置是为了控制项目需不需要，个体配置是为了控制哪些页面需要）
4. 标签持久化功能（目前标签做了缓存，刷新后，缓存的所有标签都还存在，这个是标签持久化，可以配置取消该功能，刷新后，只保留当前打开标签及需要默认打开的标签）

## 标签页全局配置
先在`src/public/serverConfig.json`文件中，新增控制配置：
```
{
  "Version": "1.0.0",
  "Title": "message.hsTitle",
  "Locale": "zh",
  "Grey": false,
  "Weak": false,
  "SidebarLogo": true,
  "HideTabs": false,
  "MultiTagsCache": false,
  "KeepAlive": true
}
```
在`types/global.d.ts`文件的`ServerConfigs`中添加对应的数据类型声明：
```
HideTabs?:boolean,
MultiTagsCache?:boolean,
KeepAlive?:boolean,
```
在`src/utils/storage/responsive.ts`文件`sets`缓存标签下再增加一个缓存标签：
```
tagSetting: {
  type: Object,
  default: Storage.getData(undefined, "tagSetting") ?? {
    hideTabs: config.HideTabs ?? false,
    multiTagsCache: config.MultiTagsCache ?? false,
    keepAlive: config.KeepAlive ?? true,
  }
}
```
#### 标签页状态持久化配置
要做页面状态持久化配置，全局配置默认开启，每个路由页面单独在`meta`中添加一个字段`keepAlive`，用来控制，当前路由页面是不是需要状态持久化，如果当前页面需要持久化，且全局页面状态持久化配置是开启的，那么，就将该页面路由信息存储起来，`vue`的内置组件`keep-alive`增加字段`include`，存储起来的路由信息赋值给`include`，这样就可以实现具体哪些页面需要状态持久化的灵活配置了

先在`src/store/modules/routes.ts`文件中，增加页面持久化缓存路由的存储状态管理：
```
import { Module } from 'vuex'
import { Routes,cacheType } from "#/store";
import { constantRoutesArr, ascending, filterTree } from "@/router";

const routesModule: Module<Routes,any> = {
  namespaced: true,
  state: {
    // 静态路由
    constantRoutes: [],
    // 所有路由
    wholeRoutes: [],
    // 缓存页面keepAlive
    cachePageList: []
  },
  mutations:{},
  actions: {
    // 获取所有路由（静态+动态获取部分）
    asyncActionRoutes({state},routes) {
      if(state.wholeRoutes.length > 0){
        return;
      }
      state.wholeRoutes = filterTree(
        ascending(ascending(constantRoutesArr).concat(routes))
      );
    },
    cacheOperate({state},{ mode, name }: cacheType) {
      switch (mode) {
        case "add":
          state.cachePageList.push(name);
          state.cachePageList = [...new Set(state.cachePageList)];
          break;
        case "delete":
          // eslint-disable-next-line no-case-declarations
          const delIndex = state.cachePageList.findIndex(v => v === name);
          delIndex !== -1 && state.cachePageList.splice(delIndex, 1);
          break;
      }
    },
    // 清空缓存页面
    clearAllCachePage({state}) {
      state.cachePageList = [];
    }
  }
};
export default routesModule
```
更新`types/store.d.ts`中的数据类型声明：
```
declare type cacheType = {
  mode: string;
  name?: RouteRecordName;
};
declare interface Routes {
  constantRoutes:RouteComponent
  wholeRoutes:Array,
  cachePageList:Array
}
```
这里的页面持久化，做了添加和删除功能，首先是添加，在路由守卫中去监控如果当前路由有`keepAlive`，那么就把该页面添加到缓存状态管理中，先修改路由信息，在`src/router/modules/home.ts`中添加`keepAlive`字段：
```
children: [
  {
    path: "/",
    name: "home",
    component: () => import("@/views/home/index.vue"),
    meta: {
      i18n:true,
      title: "message.hshome",
      keepAlive:true,
      showLink: true,
      sort:1
    }
  }
]
```
再修改`src/views/demo/index.vue`文件，加入表单编辑元素：
```
<script setup lang="ts">
import { ref } from 'vue'
const value1 = ref("")
</script>
<template>
  <el-date-picker v-model="value1" type="date" :placeholder="$t('message.hsDatePlaceholder')"></el-date-picker>
</template>

<style>
</style>
```
用以上两个文件做对比，`demo`页面对应的路由中，并未添加`keepAlive`字段。

然后修改`src/router/index.ts`文件，在导航守卫相关代码的开头部分加如下代码：
```
// 判断当前路由是否需要状态持久化
if (to.meta?.keepAlive) {
  const newMatched = to.matched;
  handleAliveRoute(newMatched, "add");
  // 页面整体刷新和点击标签页刷新，需要将状态持久去除
  if (_from.name === undefined || _from.name === "redirect") {
    handleAliveRoute(newMatched);
  }
}
```
该页面内再新增以上代码中使用的方法`handleAliveRoute`:
```
// 处理缓存路由（添加、删除、刷新）
const handleAliveRoute = (matched: RouteRecordNormalized[], mode?: string) => {
  switch (mode) {
    case "add":
      matched.forEach(v => {
        store.dispatch('routes/cacheOperate',{ mode: "add", name: v.name });
      });
      break;
    case "delete":
      store.dispatch('routes/cacheOperate',{ mode: "delete", name: matched[matched.length - 1].name });
      break;
    default:
      store.dispatch('routes/cacheOperate',{ mode: "delete", name: matched[matched.length - 1].name });
      useTimeoutFn(() => {
        matched.forEach(v => {
          store.dispatch('routes/cacheOperate',{ mode: "add", name: v.name });
        });
      }, 100);
  }
};
```
文件头部`vue-router`中引入`RouteRecordNormalized`，并新增`useTimeoutFn`的引入：
```
import { Router,RouteComponent,createRouter, createWebHistory, RouteRecordRaw,RouteRecordNormalized} from 'vue-router'
import { useTimeoutFn } from "@vueuse/core";
```

修改`src/layout/components/appMain.vue`文件：
```
<script setup lang="ts">
import {
  computed,
  getCurrentInstance
} from "vue";
import { RouterView } from "vue-router";
import { useStore } from 'vuex'
const store = useStore();
const instance = getCurrentInstance().appContext.app.config.globalProperties.$storage;
const keepAlive = computed(()=>{
  return instance?.tagSetting.keepAlive;
});
const cachePage = computed(()=>{
  return store.state.routes.cachePageList;
});
</script>

<template>
  <div class="app-main">
      <router-view>
        <template #default="{ Component, route }">
          <keep-alive v-if="keepAlive" :include="cachePage">
            <component
                :is="Component"
                :key="route.fullPath"
                class="main-content"
              />
          </keep-alive>
          <component
            v-else
            :is="Component"
            :key="route.fullPath"
            class="main-content"
          />
        </template>
      </router-view>
  </div>
</template>

<style lang="scss" scoped>
.app-main {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow-x: hidden;
}
</style>
```
此时如果运行项目，首页与测试页打开，分别操作，会发现首页的操作状态并没有被保存，这里做状态持久化，是通过在`vuex`中管理有`keepAlive`字段且为真的路由的`name`实现的，而路由`name`要与页面一一对应，那么页面内也需要声明`name`，且与路由中的`name`必须一致，打开`src/views/home/index.vue`文件，可以发现，这里并未定义`name`，修改该页面，在页面顶部加如下代码：
```
<script lang="ts">
export default {
  name: "home"
};
</script>
```
此时再次运行项目，再次在首页与测试页面分别进行操作，切换页面，首页的操作状态，就已经被保留了。

## 项目配置增加标签相关配置功能
修改`src/layout/components/settings/index.vue`文件：

`template`模板代码中添加以下代码：
```
<el-divider>{{$t("message.hsTagsTitle")}}</el-divider>
<ul class="setting">
  <li>
    <span>{{$t("message.hsTagsPane")}}</span>
    <el-switch
      v-model="tagSetting.tabsVal"
      :inline-prompt="true"
      inactive-color="#a6a6a6"
      :active-text="$t('message.hsSwitchOn')"
      :inactive-text="$t('message.hsSwitchOff')"
      @change="tagsChange"
    >
    </el-switch>
  </li>
  <li>
    <span>{{$t("message.hsTagsCache")}}</span>
    <el-switch
      v-model="tagSetting.multiTagsCache"
      :inline-prompt="true"
      inactive-color="#a6a6a6"
      :active-text="$t('message.hsSwitchOn')"
      :inactive-text="$t('message.hsSwitchOff')"
      @change="multiTagsCacheChange"
    >
    </el-switch>
  </li>
  <li>
    <span>{{$t("message.hsTagsPageCache")}}</span>
    <el-switch
      v-model="tagSetting.keepAlive"
      :inline-prompt="true"
      inactive-color="#a6a6a6"
      :active-text="$t('message.hsSwitchOn')"
      :inactive-text="$t('message.hsSwitchOff')"
      @change="keepAliveChange"
    >
    </el-switch>
  </li>
</ul>
```

`script`标签内增加以下代码：
```
const tagSetting = reactive({
  tabsVal:instance.tagSetting.hideTabs,
  multiTagsCache:instance.tagSetting.multiTagsCache,
  keepAlive:instance.tagSetting.keepAlive,
});

// 标签栏
const tagsChange = (value) => {
  instance.tagSetting = {
    hideTabs: value,
    multiTagsCache: instance.tagSetting.multiTagsCache,
    keepAlive: instance.tagSetting.keepAlive,
  };
};

// 标签持久化
const multiTagsCacheChange = (value) => {
  instance.tagSetting = {
    hideTabs: instance.tagSetting.hideTabs,
    multiTagsCache: value,
    keepAlive: instance.tagSetting.keepAlive,
  };
};
// 标签页持久化
const keepAliveChange = (value) => {
  instance.tagSetting = {
    hideTabs: instance.tagSetting.hideTabs,
    multiTagsCache: instance.tagSetting.multiTagsCache,
    keepAlive: value,
  };
};
```

修改`src/plugins/i18n/config.ts`文件中的全局配置部分：
```
// 全局配置
export const settingsConfig = {
  zh: {
    message: {
      hsTitle:"脚手架",
      hsSettingPanelTitle:"项目配置",
      hsCloseSettingPanel:"关闭配置",
      hsInterfaceTitle:"界面显示",
      hsGreyTitle:"灰色模式",
      hsColorWeaknessTitle:"色弱模式",
      hsSidebarLogoTitle:"侧边栏Logo",
      hsClearCookieBackLogin:"清空缓存并返回登录页",
      hsTagsTitle:"标签栏设置",
      hsTagsPane:"标签栏隐藏",
      hsTagsCache:"标签持久化",
      hsTagsPageCache:"标签页持久化",
    },
  },
  en: {
    message: {
      hsTitle:"Scaffold",
      hsSettingPanelTitle:"Project config",
      hsCloseSettingPanel:"Close",
      hsInterfaceTitle:"Interface show",
      hsGreyTitle:"Grey mode",
      hsColorWeaknessTitle:"Color weakness mode",
      hsSidebarLogoTitle:"Sidebar logo",
      hsClearCookieBackLogin:"Clear cache and return to login",
      hsTagsTitle:"Tab bar settings",
      hsTagsPane:"Tab bar hidden",
      hsTagsCache:"Tab cache",
      hsTagsPageCache:"Tab page cache",
    },
  },
};
```
配置完成后，运行项目，此前全局标签页持久化默认是开启，这里可以将其关闭，再次对首页进行操作，并切换页面后，重回首页，会发现，页面状态已经不再被保留，到这里，页面状态持久化功能就全部完成了，具体页面是否需要添加`keepAlive`，可以是后端返回的一个字段，这样就可以在后台设置具体页面是否需要状态持久化。

## 标签持久化配置
这里要实现的功能是，默认情况下在刷新页面后，已打开的标签，只保留默认必须打开的首页，以及当前所在标签页，其他已打开的标签全部删除，而只有在全局配置的标签持久化是开启状态的情况下，才实现刷新后，保留所有已打开的标签。

现在需要做的是，在刷新的情况下，获取当前项目是否已经开启标签持久化，如果未开启，则缓存中的修改为默认首页，并将当前所在标签的路由存入缓存中

修改`src/router/index.ts`文件：
```
import { Router,RouteComponent,createRouter, createWebHistory, RouteRecordRaw,RouteRecordNormalized,RouteMeta,RouteRecordName, } from 'vue-router'


# 新增两个封装方法

// 通过path获取父级路径
const getParentPaths = (path: string, routes: RouteRecordRaw[]) => {
  // 深度遍历查找
  function dfs(routes: RouteRecordRaw[], path: string, parents: string[]) {
    for (let i = 0; i < routes.length; i++) {
      const item = routes[i];
      // 找到path则返回父级path
      if (item.path === path) return parents;
      // children不存在或为空则不递归
      if (!item.children || !item.children.length) continue;
      // 往下查找时将当前path入栈
      parents.push(item.path);

      if (dfs(item.children, path, parents).length) return parents;
      // 深度遍历查找未找到时当前path 出栈
      parents.pop();
    }
    // 未找到时返回空数组
    return [];
  }

  return dfs(routes, path, []);
};

// 查找对应path的路由信息
const findRouteByPath = (path: string, routes: RouteRecordRaw[]) => {
  let res = routes.find((item: { path: string }) => item.path == path);
  if (res) {
    return res;
  } else {
    for (let i = 0; i < routes.length; i++) {
      if (
        routes[i].children instanceof Array &&
        routes[i].children.length > 0
      ) {
        res = findRouteByPath(path, routes[i].children);
        if (res) {
          return res;
        }
      }
    }
    return null;
  }
};


# 导航守卫的请求路由后的相关代码进行修改
if (store.state.routes.wholeRoutes.length === 0){
  initRouter().then((router: Router) => {
    // 标签持久化未开启的情况下
    if(!store.state.multiTags.multiTagsCache){
      const handTag = (
        path: string,
        parentPath: string,
        name: RouteRecordName,
        meta: RouteMeta
      ): void => {
        store.dispatch("multiTags/handleTags",{mode:"push",value:{
          path,
          parentPath,
          name,
          meta
        }});
      };
      const { path } = to;
      const routes = router.options.routes;
      const route = findRouteByPath(path, routes);
      const routePartent = getParentPaths(path, routes);
      handTag(
        route.path,
        routePartent[routePartent.length - 1],
        route.name,
        route.meta
      );
      return router.push(path);
    }
    router.push(to.path);
    // 刷新页面更新标签栏与页面路由匹配
    const localRoutes = storageLocal.getItem("responsive-tags");
    const optionsRoutes = router.options?.routes[0].children;
    const newLocalRoutes = [];
    optionsRoutes.forEach(ors => {
      localRoutes.forEach(lrs => {
        if (ors.path === lrs.parentPath) {
          newLocalRoutes.push(lrs);
        }
      });
    });
    storageLocal.setItem("responsive-tags",uniqBy(newLocalRoutes, "path"));
  });
}
```

然后修改`src/store/modules/multiTags.ts`文件：
```
# state部分做出修改
state: {
  // 存储标签页信息（路由信息）
  multiTags: storageLocal.getItem("responsive-tagSetting")?.multiTagsCache
  ? storageLocal.getItem("responsive-tags")
  : [
      {
        path: "/",
        parentPath: "/",
        meta: {
          title: "message.hshome",
          i18n: true,
          icon: "fa-house-damage",
          showLink: true
        }
      }
    ],
  multiTagsCache: storageLocal.getItem("responsive-tagSetting")?.multiTagsCache
},
```
`types/store.d.ts`中的数据类型也要相应做出修改：
```
declare type multiTagsType = {
  multiTags: Array;
  multiTagsCache:boolean;
};
declare interface State {
  routes: Routes;
  multiTags: multiTagsType;
}
```
点击项目配置的标签持久化事件，标签缓存也需要有相应的改变，修改`src/layout/compontents/settings/index.vue`文件：
```
// 标签持久化
const multiTagsCacheChange = (value) => {
  store.dispatch("multiTags/multiTagsCacheChange",value);
  instance.tagSetting = {
    hideTabs: instance.tagSetting.hideTabs,
    multiTagsCache: value,
    keepAlive: instance.tagSetting.keepAlive,
  };
};
```
这里新增了一个状态管理，需要在`src/store/modules/multiTags.ts`文件中添加对应代码：
```
multiTagsCacheChange({state},multiTagsCache: boolean) {
  state.multiTagsCache = multiTagsCache;
  if (multiTagsCache) {
    storageLocal.setItem("responsive-tags", state.multiTags);
  } else {
    storageLocal.removeItem("responsive-tags");
  }
},
```
完成以上内容，标签的持久化功能就完成了，可以打开项目配置，尝试开启与关闭标签持久化功能，并刷新页面，看标签是否符合预期效果。

## 标签栏显示/隐藏

修改`src/layout/components/settings/index.vue`文件中的标签栏隐藏的点击事件：
```
// 标签栏
const tagsChange = (value) => {
  emitter.emit("tagViewsChange", value);
  instance.tagSetting = {
    hideTabs: value,
    multiTagsCache: instance.tagSetting.multiTagsCache,
    keepAlive: instance.tagSetting.keepAlive,
  };
};
```
在`src/utils/mitt.ts`中新增总线事务：
```
tagViewsChange:boolean;
```
修改`src/layout/components/tags.vue`文件：
```
# 增加以下代码
const showTags = ref(instance.appContext.app.config.globalProperties.$storage.tagSetting.hideTabs);

# onBeforeMount中增加以下代码：
// 触发隐藏标签页
emitter.on("tagViewsChange", key => {
  if (unref(showTags) === key) return;
  showTags.value = key;
});

# template中tags-view标签上增加以下代码：
v-if="!showTags"
```
此时再运行项目，打开项目配置，切换标签栏隐藏按钮，标签栏就能做出对应改变了。

## 标签页视窗放大还原
标签页视口放大的情况下， 需要将侧边导航栏、header栏，全部隐藏掉，整个浏览器视口只留标签栏以及核心内容区域，需要新增一个字段控制显示隐藏，修改`public/serverConfig.json`文件：
```
"HiddenSideBar":false
```
在`src/store/modules`文件夹下，新建`settings.ts`文件：
```
import { Module } from 'vuex'
import { setType } from "#/store";
import { getConfig } from "@/config";

const settingsModule: Module<setType,any> = {
  namespaced: true,
  state: {
    // 隐藏侧边栏
    hiddenSideBar: getConfig().HiddenSideBar,
  },
  mutations:{
    CHANGE_SETTING:(state,data)=>{
      state[data.key] = data.value;
    }
  },
  actions: {
    changeSetting({commit},data) {
      console.log(data);
      commit('CHANGE_SETTING',data);
    }
  }
};
export default settingsModule
```
修改`types/global.d.ts`文件中的`ServerConfigs`，添加以下代码：
```
  HiddenSideBar?:boolean;
```
修改`types/store.d.ts`文件：
```
declare type setType = {
  hiddenSideBar: boolean;
};
declare interface State {
  routes: Routes;
  multiTags: multiTagsType;
  settings:setType;
}
```
修改`src/layout/components/tags.vue`文件：
```
# 增加以下事件
function onFullScreen(){
  store.state.settings.hiddenSideBar?store.dispatch('settings/changeSetting',{key:"hiddenSideBar",value:false}):store.dispatch('settings/changeSetting',{key:"hiddenSideBar",value:true})
}
# 右侧功能按钮最后一个li代码修改
<li v-on:click="onFullScreen"><i class="svg-i"><svg-icon :icon-class="store.state.settings.hiddenSideBar?'sgn-exit_screen':'sgn-full_screen'" /></i></li>
```

修改`src/layout/index.vue`文件：
```
<script setup lang="ts">
import navbar from "./components/navbar.vue";
import appMain from "./components/appMain.vue";
import setting from "./components/settings/index.vue";
import Vertical from "./components/vertical.vue";
import tags from "./components/tags.vue";
import { useStore } from 'vuex'
const store = useStore()
import { computed } from "vue";
const sidebar = computed(() => {
  return store.state.app.sidebar;
});
const hiddenSideBar = computed(() => {
  return store.state.settings.hiddenSideBar
});
</script>

<template>
  <div :class="['app-wrapper',sidebar.opened?'':'hideSidebar',sidebar.withoutAnimation?'withoutAnimation':'']">
    <!-- 侧边导航栏 -->
    <Vertical v-if="!hiddenSideBar" />
    <div class="main-container" :class="hiddenSideBar?'hidden-mode':''">
      <div class="fixed-header">
        <!-- 顶部导航栏 -->
        <navbar v-if="!hiddenSideBar" />
        <!-- 标签栏 -->
        <tags />
      </div>
      <!-- 主体内容 -->
      <app-main />
    </div>
    <!-- 系统设置 -->
    <setting />
  </div>
</template>


<style lang="scss" scoped>

</style>
```
修改`src/style/layout.scss`文件，新增如下样式：
```
.hidden-mode {
  padding-left: 0;
  .fixed-header {
    left: 0;
    + .app-main {
      padding-top: 38px;
    }
  }
}
```
再将右键菜单的定位问题解决一下，修改`src/layout/components/tags.vue`文件中`openMenu`方法：
```
# 将
buttonTop.value = e.clientY - 40
# 替换为
store.state.settings.hiddenSideBar
    ? (buttonTop.value = e.clientY)
    : (buttonTop.value = e.clientY - 40);
```
完成以上代码，再次运行项目，核心内容区视窗的放大与还原功能就完成了
## 动态路由详情页在标签栏显示个数
这里主要实现，类似详情页的页面，在标签栏打开，实现可同时在标签栏展示多个详情页的功能，并实现超过规定个数后，再打开新详情页，则关闭最先打开的详情页

先新建标签页操作路由模块，在`src/router/modules`文件夹下新建`tabs.ts`文件：
```
import Layout from "@/layout/index.vue";

const tabsRouter = {
  path: "/tabs",
  name: "reTabs",
  component: Layout,
  redirect: "/tabs/index",
  meta: {
    icon: "icon-wenzhangfenlei",
    title: "message.hstabs",
    i18n: true,
    showLink: true,
    rank: 8
  },
  children: [
    {
      path: "/tabs/index",
      name: "reTabs",
      component: () => import("@/views/tabs/index/index.vue"),
      meta: {
        title: "message.hstabs",
        showLink: true,
        i18n: true
      }
    },
    {
      path: "/tabs/detail/:id",
      name: "tabDetail",
      component: () => import("@/views/tabs/tabDetail/index.vue"),
      meta: {
        title: "",
        showLink: false,
        i18n: false,
        dynamicLevel: 8,
        realPath: "/tabs/detail"
      }
    }
  ]
};

export default tabsRouter;
```
在`src/plugins/i18n/config.ts`文件中的`menusConfig`中添加对应的菜单国际化文案:
```
hstabs:"标签页操作",

hstabs:"Tabs Operate",
```
添加对应的页面，在`src/views`文件夹下，新建`tabs`文件夹，在其内新建`index/index.vue`路径文件，以及`tabDetail/index.vue`路径文件：

`src/views/tabs/index/index.vue`：
```
<script setup lang="ts">
import { ref } from "vue";
import { useRouter, useRoute } from "vue-router";
import { useStore } from 'vuex'
const store = useStore()

const router = useRouter();
const route = useRoute();
const activeName = ref("tag");

function toDetail(index: number) {
  store.dispatch('multiTags/handleTags',{mode:"push", value:{
    path: `/tabs/detail/${index}`,
    parentPath: route.matched[0].path,
    name: "tabDetail",
    meta: {
      title: { zh: `No.${index} - 详情信息`, en: `No.${index} - DetailInfo` },
      showLink: false,
      i18n: false,
      dynamicLevel: 8,
      realPath: "/tabs/detail"
    }
  }});
  router.push(`/tabs/detail/${index}`);
}
</script>

<template>
  <el-collapse v-model="activeName" class="tabs-container">
    <el-collapse-item
      title="标签页复用超出限制自动关闭(使用场景: 动态路由)"
      name="tag"
    >
      <el-button
        v-for="index in 12"
        :key="index"
        size="medium"
        @click="toDetail(index)"
      >
        打开{{ index }}详情页
      </el-button>
    </el-collapse-item>
  </el-collapse>
</template>

<style lang="scss" scoped>
.tabs-container {
  padding: 10px;
  background: #fff;

  ::v-deep(.el-collapse-item__header) {
    line-height: 20px;
  }

  ::v-deep(.el-collapse-item__wrap) {
    border-bottom: none;
  }

  button {
    margin: 10px;
  }
}
</style>
```

`src/views/tabs/tabDetail/index.vue`：
```
<script setup lang="ts">
import { useRoute } from "vue-router";
const route = useRoute();
const index = route.params?.id ?? -1;
</script>

<template>
  <div>{{ index }} - 详情页内容在此</div>
</template>

<style lang="scss" scoped></style>
```
路由及路由对应页面都添加完后，需要对`src/store/modules/multiTags.ts`文件做修改，修改`handleTags`这个`action`：
```
case "push":
  const tagVal = data.value;
  // 判断tag是否已存在:
  const tagHasExits = state.multiTags.some(tag => {
    return tag.path === tagVal?.path;
  });

  if (tagHasExits) return;
  const meta = tagVal?.meta;
  const dynamicLevel = meta?.dynamicLevel ?? -1;
  if (dynamicLevel > 0) {
    // dynamicLevel动态路由可打开的数量
    const realPath = meta?.realPath ?? "";
    // 获取到已经打开的动态路由数, 判断是否大于dynamicLevel
    if (
      state.multiTags.filter(e => e.meta?.realPath ?? "" === realPath)
        .length >= dynamicLevel
    ) {
      // 关闭第一个
      const index = state.multiTags.findIndex(
        item => item.meta?.realPath === realPath
      );
      index !== -1 && state.multiTags.splice(index, 1);
    }
  }
  state.multiTags.push(data.value);
  commit('tagsCache');
  break;
```
此时运行项目，打开标签操作页，并打开详情，会发现页面跳转`404`了，这是因为在创建路由实例时，过滤了`showLink:false`的路由，这里需要修改`src/router/index.ts`文件中创建路由实例部分的代码：
```
// 创建路由实例
export const router: Router = createRouter({
    history: createWebHistory(),
    routes: ascending(constantRoutes).concat(...remainingRouter),
    scrollBehavior(to, from, savedPosition) {
      return new Promise(resolve => {
        if (savedPosition) {
          return savedPosition;
        } else {
          if (from.meta.saveSrollTop) {
            const top: number =
              document.documentElement.scrollTop || document.body.scrollTop;
            resolve({ left: 0, top });
          }
        }
      });
    }
});
```
此时再次运行项目，详情页就能正常打开了，这里在路由中限制了最多打开8个详情页，超过一个就关闭一个最先打开的，最多打开个数可自定义

不过此时代码依然有问题，在不做标签持久化的情况下，详情页类的页面打开后，刷新页面，标签栏展示是有问题的，代码还需要进行优化，修改`src/router/index.ts`的导航守卫中，标签持久化未开启部分的代码：
```
// 标签持久化未开启的情况下
if(!store.state.multiTags.multiTagsCache){
  const handTag = (
    path: string,
    parentPath: string,
    name: RouteRecordName,
    meta: RouteMeta
  ): void => {
    store.dispatch("multiTags/handleTags",{mode:"push",value:{
      path,
      parentPath,
      name,
      meta
    }});
  };
  if(to.meta?.realPath){
    const routes = router.options.routes;
    const { path } = to;
    const { realPath } = to.meta;
    const route = findRouteByPath(realPath, routes);
    const routePartent = getParentPaths(path, routes);
    handTag(
      path,
      routePartent[routePartent.length - 1],
      route.name,
      route.meta
    );
    return router.push(path);
  }else{
    const { path } = to;
    const routes = router.options.routes;
    const route = findRouteByPath(path, routes);
    const routePartent = getParentPaths(path, routes);
    handTag(
      route.path,
      routePartent[routePartent.length - 1],
      route.name,
      route.meta
    );
    return router.push(path);
  }
}
router.push(to.path);
// 刷新页面更新标签栏与页面路由匹配
const localRoutes = storageLocal.getItem("responsive-tags");
const optionsRoutes = router.options?.routes[0].children;
const newLocalRoutes = [];
optionsRoutes.forEach(ors => {
  localRoutes.forEach(lrs => {
    if (ors.path === lrs.parentPath) {
      newLocalRoutes.push(lrs);
    }
  });
});
storageLocal.setItem("responsive-tags",uniqBy(newLocalRoutes, "path"));
```
修改`src/store/modules/multiTags.ts`文件中`handleTags`的`push`部分代码：
```
case "push":
  const tagVal = data.value;
  // 判断tag是否已存在:
  const tagHasExits = state.multiTags.some(tag => {
    return tag.path === tagVal?.path;
  });
  // tag已经存在，并且realPath不存在的情况下，直接返回
  if (tagHasExits&&!tagVal?.meta?.realPath) return;
  const meta = tagVal?.meta;
  const dynamicLevel = meta?.dynamicLevel ?? -1;
  if (dynamicLevel > 0&&!tagHasExits) {
    // dynamicLevel动态路由可打开的数量
    const realPath = meta?.realPath ?? "";
    // 获取到已经打开的动态路由数, 判断是否大于dynamicLevel
    if (
      state.multiTags.filter(e => e.meta?.realPath ?? "" === realPath)
        .length >= dynamicLevel
    ) {
      // 关闭第一个
      const index = state.multiTags.findIndex(
        item => item.meta?.realPath === realPath
      );
      index !== -1 && state.multiTags.splice(index, 1);
    }
  }
  // 删除已缓存的详情路由，并将新的进行缓存
  const tagIndex = state.multiTags.findIndex(
    item => item.path === tagVal?.path
  );
  if(tagIndex !== -1){
    state.multiTags.splice(tagIndex, 1,data.value);
  }
  if (!tagHasExits){
    state.multiTags.push(data.value);
  }
  commit('tagsCache');
  break;
```
修改`src/views/tabs/tabDetail/index.vue`文件：
```
<script setup lang="ts">
import { useRouter, useRoute } from "vue-router";
import { useStore } from 'vuex'
const store = useStore()
const route = useRoute();
const index = route.params?.id ?? -1;

function tagCache(index) {
  store.dispatch('multiTags/handleTags',{mode:"push", value:{
    path: `/tabs/detail/${index}`,
    parentPath: route.matched[0].path,
    name: "tabDetail",
    meta: {
      title: { zh: `No.${index} - 详情信息`, en: `No.${index} - DetailInfo` },
      showLink: false,
      i18n: false,
      dynamicLevel: 8,
      realPath: "/tabs/detail"
    }
  }});
}
tagCache(index)
</script>

<template>
  <div>{{ index }} - 详情页内容在此</div>
</template>

<style lang="scss" scoped></style>
```
修改`src/tabs/index/index.vue`文件：
```
<script setup lang="ts">
import { ref } from "vue";
import { useRouter } from "vue-router";
const router = useRouter();
const activeName = ref("tag");
function toDetail(index: number) {
  router.push(`/tabs/detail/${index}`);
}
</script>

<template>
  <el-collapse v-model="activeName" class="tabs-container">
    <el-collapse-item
      title="标签页复用超出限制自动关闭(使用场景: 动态路由)"
      name="tag"
    >
      <el-button
        v-for="index in 12"
        :key="index"
        size="medium"
        @click="toDetail(index)"
      >
        打开{{ index }}详情页
      </el-button>
    </el-collapse-item>
  </el-collapse>
</template>

<style lang="scss" scoped>
.tabs-container {
  padding: 10px;
  background: #fff;

  ::v-deep(.el-collapse-item__header) {
    line-height: 20px;
  }

  ::v-deep(.el-collapse-item__wrap) {
    border-bottom: none;
  }

  button {
    margin: 10px;
  }
}
</style>
```
此时运行项目，打开标签页操作菜单，打开几个详情页，刷新页面，就可以做到保留当前已打开的详情页，并且标签中的标题显示页正常了。

## 标签栏左右移动功能
接下来要实现当标签过超过标签栏长度时，要能实现通过点击左右箭头实现标签栏移动功能，以及新打开标签页如在视野外，需自动移动到视野内，修改`src/layout/components/tags.vue`文件：
```
import { templateRef, useResizeObserver,useDebounceFn } from "@vueuse/core";

const translateX = ref<number>(0);
const tabDom = templateRef<HTMLElement | null>("tabDom", null);
const scrollbarDom = templateRef<HTMLElement | null>("scrollbarDom", null);

const dynamicTagView = () => {
  const index = multiTags.value.findIndex(item => {
    return item.path === route.path;
  });
  moveToView(index);
};

watch([route], () => {
  activeIndex.value = -1;
  dynamicTagView();
});

useResizeObserver(
  scrollbarDom,
  useDebounceFn(() => {
    dynamicTagView();
  }, 200)
);

const tabNavPadding = 10;
const moveToView = (index: number): void => {
  if (!instance.refs["dynamic" + index]) {
    return;
  }
  const tabItemEl = instance.refs["dynamic" + index];
  const tabItemElOffsetLeft = (tabItemEl as HTMLElement).offsetLeft;
  const tabItemOffsetWidth = (tabItemEl as HTMLElement).offsetWidth;
  // 标签页导航栏可视长度（不包含溢出部分）
  const scrollbarDomWidth = scrollbarDom.value
    ? scrollbarDom.value.offsetWidth
    : 0;
  // 已有标签页总长度（包含溢出部分）
  const tabDomWidth = tabDom.value ? tabDom.value.offsetWidth : 0;

  if (tabDomWidth < scrollbarDomWidth || tabItemElOffsetLeft === 0) {
    translateX.value = 0;
  } else if (tabItemElOffsetLeft < -translateX.value) {
    // 标签在可视区域左侧
    translateX.value = -tabItemElOffsetLeft + tabNavPadding;
  } else if (
    tabItemElOffsetLeft > -translateX.value &&
    tabItemElOffsetLeft + tabItemOffsetWidth <
      -translateX.value + scrollbarDomWidth
  ) {
    // 标签在可视区域
    translateX.value = Math.min(
      0,
      scrollbarDomWidth -
        tabItemOffsetWidth -
        tabItemElOffsetLeft -
        tabNavPadding
    );
  } else {
    // 标签在可视区域右侧
    translateX.value = -(
      tabItemElOffsetLeft -
      (scrollbarDomWidth - tabNavPadding - tabItemOffsetWidth)
    );
  }
};

const handleScroll = (offset: number): void => {
  const scrollbarDomWidth = scrollbarDom.value
    ? scrollbarDom.value?.offsetWidth
    : 0;
  const tabDomWidth = tabDom.value ? tabDom.value.offsetWidth : 0;
  if (offset > 0) {
    translateX.value = Math.min(0, translateX.value + offset);
  } else {
    if (scrollbarDomWidth < tabDomWidth) {
      if (translateX.value >= -(tabDomWidth - scrollbarDomWidth)) {
        translateX.value = Math.max(
          translateX.value + offset,
          scrollbarDomWidth - tabDomWidth
        );
      }
    } else {
      translateX.value = 0;
    }
  }
};

# 左滑动标签新增点击事件
@click="handleScroll(200)"
# 右滑动标签新增点击事件
@click="handleScroll(-200)"
# 类名为tab的标签新增以下代码
ref="tabDom"
:style="{ transform: `translateX(${translateX}px)` }"
```
此时运行项目，当标签栏打开标签过多时，左右点击事件就可以移动标签栏了，也实现了点击菜单打开标签，当前标签如在视野外，会自动滚动到视野内的功能。

## 标签样式切换功能
接下来再添加一个标签样式切换功能，预设两套标签的展现样式，可以进行切换，需要进行以下修改

`public/serverConfig.json`文件添加新字段：
```
"TagStyleMode":"card"
```
`types/global.d.ts`文件中`serverConfigs`设置字段相关数据类型声明：
```
TagStyleMode?:string;
```
`src/utils/storage/responsive.ts`文件`tagSetting`中，新增字段：
```
tagStyleMode:config.TagStyleMode??"card"
```
`src/layout/components/settings/index.vue`文件修改：
```
const tagSetting = reactive({
  tabsVal:instance.tagSetting.hideTabs,
  multiTagsCache:instance.tagSetting.multiTagsCache,
  keepAlive:instance.tagSetting.keepAlive,
  tagStyleMode:instance.tagSetting.tagStyleMode,
});

// 标签栏
const tagsChange = (value) => {
  emitter.emit("tagViewsChange", value);
  instance.tagSetting = {
    hideTabs: value,
    multiTagsCache: instance.tagSetting.multiTagsCache,
    keepAlive: instance.tagSetting.keepAlive,
    tagStyleMode: instance.tagSetting.tagStyleMode,
  };
};

// 标签持久化
const multiTagsCacheChange = (value) => {
  store.dispatch("multiTags/multiTagsCacheChange",value);
  instance.tagSetting = {
    hideTabs: instance.tagSetting.hideTabs,
    multiTagsCache: value,
    keepAlive: instance.tagSetting.keepAlive,
    tagStyleMode: instance.tagSetting.tagStyleMode,
  };
};
// 标签页持久化
const keepAliveChange = (value) => {
  instance.tagSetting = {
    hideTabs: instance.tagSetting.hideTabs,
    multiTagsCache: instance.tagSetting.multiTagsCache,
    keepAlive: value,
    tagStyleMode: instance.tagSetting.tagStyleMode,
  };
};
// 标签风格
const tagStyleModeChange = (value) => {
  instance.tagSetting = {
    hideTabs: instance.tagSetting.hideTabs,
    multiTagsCache: instance.tagSetting.multiTagsCache,
    keepAlive: instance.tagSetting.keepAlive,
    tagStyleMode: value,
  };
};

# template模板代码中新增
<li>
  <span>{{$t("message.hsTagsStyleMode")}}</span>
  <el-radio-group v-model="tagSetting.tagStyleMode" size="small" @change="tagStyleModeChange">
    <el-radio label="card">{{$t("message.hsTagsStyleCard")}}</el-radio>
    <el-radio label="smart">{{$t("message.hsTagsStyleSmart")}}</el-radio>
  </el-radio-group>
</li>
```
`src/plugins/i18n/config.ts`文件`settingsConfig`中新增国际化文案：
```
hsTagsStyleMode:"标签风格",
hsTagsStyleCard:"卡片",
hsTagsStyleSmart:"灵动",

hsTagsStyleMode:"Tab style",
hsTagsStyleCard:"Card",
hsTagsStyleSmart:"Smart",
```
`src/layout/components/tags.vue`文件修改：
```
let tagStyleMode = computed(()=>{
  return instance.appContext.app.config.globalProperties.$storage.tagSetting.tagStyleMode
});
// 鼠标移入标签页状态
function onMouseenter(item, index) {
  if (index) activeIndex.value = index;
  if (tagStyleMode.value === "card") {
    if (hasClass(instance.refs["dynamic" + index], "card-active")) return;
    toggleClass(true, "card-in", instance.refs["dynamic" + index]);
    toggleClass(false, "card-out", instance.refs["dynamic" + index]);
  } else {
    if (hasClass(instance.refs["schedule" + index], "schedule-active")) return;
    toggleClass(true, "schedule-in", instance.refs["schedule" + index]);
    toggleClass(false, "schedule-out", instance.refs["schedule" + index]);
  }
}
// 鼠标移出标签页状态
function onMouseleave(item, index) {
  activeIndex.value = -1;
  if (tagStyleMode.value === "card") {
    if (hasClass(instance.refs["dynamic" + index], "card-active")) return;
    toggleClass(false, "card-in", instance.refs["dynamic" + index]);
    toggleClass(true, "card-out", instance.refs["dynamic" + index]);
  } else {
    if (hasClass(instance.refs["schedule" + index], "schedule-active")) return;
    toggleClass(false, "schedule-in", instance.refs["schedule" + index]);
    toggleClass(true, "schedule-out", instance.refs["schedule" + index]);
  }
}

# scroll-item标签的类名绑定修改
:class="[
  'scroll-item is-closable',
  $route.path === item.path ? 'is-active' : '',
  $route.path === item.path && tagStyleMode ==='card'
    ? 'card-active'
    : ''
]"
# 标签关闭按钮图标后新增代码
<div
  :ref="'schedule' + index"
  v-if="tagStyleMode !== 'card'"
  :class="[$route.path === item.path ? 'schedule-active' : '']"
></div>
```
`src/style/-tags.scss`添加以下样式：
```

/* 灵动模式 */
.schedule-active {
  width: 100%;
  height: 2px;
  position: absolute;
  left: 0;
  bottom: 0;
  background: #1890ff;
}

/* 灵动模式下鼠标移入显示蓝色进度条 */
.schedule-in {
  width: 100%;
  height: 2px;
  position: absolute;
  left: 0;
  bottom: 0;
  background: #1890ff;
  animation: scheduleInWidth 400ms ease-in;
}

/* 灵动模式下鼠标移出隐藏蓝色进度条 */
.schedule-out {
  width: 0;
  height: 2px;
  position: absolute;
  left: 0;
  bottom: 0;
  background: #1890ff;
  animation: scheduleOutWidth 400ms ease-in;
}
@keyframes scheduleInWidth {
  from {
    width: 0;
  }

  to {
    width: 100%;
  }
}

@keyframes scheduleOutWidth {
  from {
    width: 100%;
  }

  to {
    width: 0;
  }
}
```
运行项目，切换标签风格，就可以展示不同的标签样式了


# 框架风格切换功能
需要先预设框架风格，作为管理系统的框架，常见的框架布局方式有左右布局、上下布局、上左右布局，现在就将这三种框架布局都加入到项目中，可以进行随意切换

修改`public/serverConfig.json`文件，添加新的字段：
```
"Frame": "leftRight"
```
`types/global.d.ts`文件中`ServerConfigs`中，新增数据类型声明：
```
Frame?: string;
```
`src/utils/storage/responsive.ts`文件中，新增缓存组：
```
// 框架布局
layout: {
  type: Object,
  default: Storage.getData(undefined, "layout") ?? {
    frame: config.Frame ?? "leftRight",
  }
},
```
修改`src/layout/components/settings/index.vue`文件：
```
import { reactive,getCurrentInstance,nextTick,ref } from "vue";

let layoutTheme = ref(storageLocal.getItem("responsive-layout")) || ref({frame: instanceConfig?.frame ?? "leftRight"});

// 设置框架布局模式
function setLayoutModel(frame: string) {
  layoutTheme.value.frame = frame;
  window.document.body.setAttribute("frame", frame);
  instance.layout = { frame };
}

# 新增模板代码
<el-divider>{{$t("message.hsFrameTitle")}}</el-divider>
<ul class="frame-theme">
  <el-tooltip class="item" :content="$t('message.hsLeftRightLayout')" placement="bottom">
    <li
      :class="layoutTheme.frame === 'leftRight' ? 'isSelect' : ''"
      ref="leftRightRef"
      @click="setLayoutModel('leftRight')"
    >
      <div></div>
      <div></div>
    </li>
  </el-tooltip>

  <el-tooltip class="item" :content="$t('message.hsTopBottomLayout')" placement="bottom">
    <li
      :class="layoutTheme.frame === 'topBottom' ? 'isSelect' : ''"
      ref="topBottomRef"
      @click="setLayoutModel('topBottom')"
    >
      <div></div>
      <div></div>
    </li>
  </el-tooltip>

  <el-tooltip class="item" :content="$t('message.hsTopLeftRightLayout')" placement="bottom">
    <li
      :class="layoutTheme.frame === 'topLeftRight' ? 'isSelect' : ''"
      ref="topLeftRightRef"
      @click="setLayoutModel('topLeftRight')"
    >
      <div></div>
      <div></div>
      <div></div>
    </li>
  </el-tooltip>
</ul>
```
`src/plugins/i18n/config.ts`文件`settingsConfig`中新增相关配置：
```
hsFrameTitle:"框架风格",
hsLeftRightLayout:"左右布局模式",
hsTopBottomLayout:"上下布局模式",
hsTopLeftRightLayout:"上左右布局模式",

hsFrameTitle:"Frame style",
hsLeftRightLayout:"Left and right layout",
hsTopBottomLayout:"Top and bottom layout",
hsTopLeftRightLayout:"Top left and right layout",
```
再将样式调整一下，新建`src/style/-mixin.scss`文件，用来存放自定义的一些`scss`配置及函数等：
```
@charset "UTF-8";
$pink: #ff00ff;
$red: red;

@mixin clearfix {
  &::after {
    content: "";
    display: table;
    clear: both;
  }
}
```
在`src/style/index.scss`文件中引入：
```
@charset "UTF-8";
@import "./-mixin.scss";
@import "./-settings.scss";
@import "./-public.scss";
@import "./-layout.scss";
@import "./-tags.scss";
@import "./-transition.scss";

.demo{
  color: $red;
}
```
修改`src/style/-settings.scss`文件中样式，该文件改为存放全局配置弹层相关样式：
```
.showright-panel {
  overflow: hidden;
  position: relative;
  width: calc(100% - 15px);
}
.right-panel-background {
  position: fixed;
  top: 0;
  left: 0;
  opacity: 0;
  transition: opacity 0.3s cubic-bezier(0.7, 0.3, 0.1, 1);
  background: rgba(0, 0, 0, 0.2);
  z-index: -1;
}

.right-panel {
  width: 100%;
  max-width: 300px;
  height: 100vh;
  position: fixed;
  top: 0;
  right: 0;
  box-shadow: 0 0 15px 0 rgba(0, 0, 0, 0.05);
  transition: all 0.25s cubic-bezier(0.7, 0.3, 0.1, 1);
  transform: translate(100%);
  background: #fff;
  z-index: 1500;
}

.show {
  transition: all 0.3s cubic-bezier(0.7, 0.3, 0.1, 1);

  .right-panel-background {
    z-index: 1200;
    opacity: 1;
    width: 100%;
    height: 100%;
  }

  .right-panel {
    transform: translate(0);
  }
}

.handle-button {
  width: 48px;
  height: 48px;
  position: absolute;
  left: -48px;
  text-align: center;
  font-size: 24px;
  border-radius: 6px 0 0 6px !important;
  z-index: 0;
  pointer-events: auto;
  cursor: pointer;
  color: #fff;
  line-height: 48px;
  top: 45%;
  background: rgb(24, 144, 255);

  i {
    font-size: 24px;
    line-height: 48px;
  }
}

.right-panel-items {
  margin-top: 60px;
  height: 100vh;
  overflow: auto;
}

.project-configuration {
  display: flex;
  width: 100%;
  height: 30px;
  position: fixed;
  justify-content: space-between;
  align-items: center;
  top: 15px;
  margin-left: 10px;

  i {
    font-size: 20px;
    margin-right: 20px;

    &:hover {
      cursor: pointer;
      color: red;
    }
  }
}

.el-divider--horizontal {
  width: 90%;
  margin: 20px auto 0 auto;
}

.el-divider__text {
  font-size: 16px;
  font-weight: 700;
  white-space: nowrap;
}
.setting {
  width: 100%;

  li {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 25px;
  }
}
.frame-theme {
  margin-top: 25px;
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  justify-content: space-around;
  padding: 0 5px;
  .isSelect {
    border: 2px solid #0960bd;
  }
  li {
    margin: 10px 5px;
    width: 28%;
    height: 50px;
    background: #f0f2f5;
    position: relative;
    overflow: hidden;
    cursor: pointer;
    border-radius: 4px;
    box-shadow: 0 1px 2.5px 0 rgb(0 0 0 / 18%);

    &:nth-child(1) {
      div {
        &:nth-child(1) {
          width: 30%;
          height: 100%;
          background: #1b2a47;
        }

        &:nth-child(2) {
          width: 70%;
          height: 30%;
          top: 0;
          right: 0;
          background: #fff;
          box-shadow: 0 1px 1px #e6e6e6;
          position: absolute;
        }
      }
    }

    &:nth-child(2) {
      div {
        &:nth-child(1) {
          width: 100%;
          height: 30%;
          background: #1b2a47;
        }
      }
    }

    &:nth-child(3) {
      div {
        &:nth-child(1) {
          width: 100%;
          height: 15%;
          background: #fff;
        }
        &:nth-child(2) {
          float:left;
          width: 30%;
          height: 100%;
          background: #1b2a47;
        }
        &:nth-child(3) {
          float:right;
          width: 70%;
          height: 15%;
          background: #fff;
          box-shadow: 0 1px 1px #e6e6e6;
        }
      }
    }
  }
}
```
然后删除`src/layout/components/settings/index.vue`以及`src/layout/components/settings/panel.vue`文件中的样式代码，修改`src/components/HelloWorld.vue`文件中引入的`scss`文件名：
```
@import "@/style/-mixin.scss";
```